{"version":3,"file":"index-CBejGkT1.js","sources":["../../src/core/timer.ts","../../src/utils/smooth-movement.ts","../../src/game-state-machine.ts","../../src/core/controls.ts","../../src/core/util/canvas.ts","../../src/core/emoji.ts","../../src/game/sprite-loader.ts","../../src/core/tileset.ts","../../src/core/util/color.ts","../../src/game/sprites.ts","../../src/game/game-assets.ts","../../src/core/util/image-generator.ts","../../src/core/font.ts","../../src/core/draw-engine.ts","../../src/game/constants.ts","../../src/core/game-object.ts","../../src/core/event.ts","../../src/game/entities/pentagram-attack.ts","../../src/game/grid-utils.ts","../../src/core/audio.ts","../../src/game/entities/player.ts","../../src/core/game-static-object.ts","../../src/game/entities/tree.ts","../../src/core/util/rng.ts","../../src/game/entities/house.ts","../../src/game/entities/villager.ts","../../src/game/entities/farm.ts","../../src/game/entities/village.ts","../../src/game/entities/icon.ts","../../src/game/path-findind.ts","../../src/game/entities/hp-bar.ts","../../src/game/entities/spirit.ts","../../src/game/entities/magic-animation.ts","../../src/game/entities/statue.ts","../../src/game/entities/obelisk.ts","../../src/game/game-map.ts","../../src/core/util/util.ts","../../src/game/mini-map.ts","../../src/game/dialog-box.ts","../../src/game/hud.ts","../../src/game/actions.ts","../../src/game/game-data.ts","../../src/core/story-engine.ts","../../src/game/game-story.ts","../../src/core/music-player.ts","../../src/game-states/game.state.ts","../../src/game-states/menu.state.ts","../../src/index.ts","../../src/core/state-machine.ts"],"sourcesContent":["type TimeEventHandler = {\n  callback: (() => void)\n  time: number\n  timeLeft: number\n  repeat: number\n}\n\nlet timeEvents: TimeEventHandler[] = [];\n\nexport function addTimeEvent (callback: () => void, time: number, repeat = 0, delay = 0) {\n  timeEvents.push({callback, time, timeLeft: time + delay, repeat});\n}\n\nexport function clearTimers() {\n  timeEvents = [];\n}\n\n/**\n * Updates the time events, checking if any should be executed.\n * @param delta The time in milliseconds since the last update.\n */\nexport function updateTimeEvents(delta: number) {\n  for (let i = timeEvents.length - 1; i >= 0; i--) {\n    const timeEvent = timeEvents[i];\n    if (!timeEvent) {\n      return;\n    }\n    timeEvent.timeLeft -= delta;\n    if (timeEvent.timeLeft <= 0) {\n      timeEvent.callback();\n\n      if (timeEvent.repeat-- <= 0) {\n        timeEvents.splice(i, 1); // Remove the executed event\n      } else {\n        timeEvent.timeLeft = timeEvent.time;\n      }\n    }\n  }\n}\n","import { CELL_WIDTH, CELL_HEIGHT } from '../game/constants';\n\nexport interface SmoothMovementState {\n  x: number;\n  y: number;\n  targetPos: { x: number; y: number };\n  moving: { x: number; y: number };\n  speed: number;\n}\n\n/**\n * Updates position smoothly towards target position using linear interpolation\n * @param state Object containing position, target, and movement state\n * @param timeElapsed Time elapsed since last update in milliseconds\n */\nexport function updatePositionSmoothly(state: SmoothMovementState, timeElapsed: number): void {\n  for (const axis of ['x', 'y'] as const) {\n    if (state[axis] !== state.targetPos[axis]) {\n      const d = state.targetPos[axis] - state[axis];\n      const step = Math.sign(d) * state.speed * timeElapsed / 1000;\n      if (Math.abs(step) >= Math.abs(d)) {\n        state[axis] = state.targetPos[axis];\n      } else {\n        state[axis] += step;\n      }\n    } else {\n      state.moving[axis] = 0;\n      state[axis] = Math.round(state[axis]);\n    }\n  }\n}\n\n/**\n * Sets target position in pixel coordinates based on grid cell coordinates\n * @param state Movement state object\n * @param col Grid column\n * @param row Grid row\n */\nexport function setTargetPosition(state: SmoothMovementState, col: number, row: number): void {\n  state.targetPos.x = col * CELL_WIDTH;\n  state.targetPos.y = row * CELL_HEIGHT;\n}\n\n/**\n * Moves towards a target grid position if the move is valid\n * @param state Movement state object\n * @param targetCol Target column\n * @param targetRow Target row\n * @param currentCol Current column (will be updated)\n * @param currentRow Current row (will be updated)\n * @param isValidMove Function to check if move is valid\n * @returns true if movement was initiated, false otherwise\n */\nexport function moveToGridPosition(\n  state: SmoothMovementState,\n  targetCol: number,\n  targetRow: number,\n  currentCol: { value: number },\n  currentRow: { value: number },\n  isValidMove: (col: number, row: number) => boolean\n): boolean {\n  if (!isValidMove(targetCol, targetRow)) {\n    return false;\n  }\n\n  // Calculate movement direction\n  const deltaCol = targetCol - currentCol.value;\n  const deltaRow = targetRow - currentRow.value;\n\n  // Update grid position\n  currentCol.value = targetCol;\n  currentRow.value = targetRow;\n\n  // Set movement direction\n  state.moving.x = Math.sign(deltaCol);\n  state.moving.y = Math.sign(deltaRow);\n\n  // Set target pixel position\n  setTargetPosition(state, targetCol, targetRow);\n\n  return true;\n}\n","import { StateMachine } from './core/state-machine';\nimport { State } from './core/state';\n\nexport let gameStateMachine: StateMachine;\n\nexport function createGameStateMachine(initialState: State, ...initialArguments: any[]) {\n  gameStateMachine = new StateMachine(initialState, ...initialArguments);\n}\n","class Controls {\n  isUp = false;\n  isDown = false;\n  isLeft = false;\n  isRight = false;\n  isConfirm = false;\n  // isEscape = false;\n  isAction1 = false;\n  isMoving = false;\n  inputDirection: DOMPoint;\n\n  keyMap: Map<string, boolean> = new Map();\n  previousState = {\n    isUp: this.isUp,\n    isDown: this.isDown,\n    isConfirm: this.isConfirm,\n    // isEscape: this.isEscape,\n    isAction1: this.isAction1,\n  };\n\n  constructor() {\n    document.addEventListener('keydown', event => this.toggleKey(event, true));\n    document.addEventListener('keyup', event => this.toggleKey(event, false));\n    this.inputDirection = new DOMPoint();\n  }\n\n  queryController() {\n    this.previousState.isUp = this.isUp;\n    this.previousState.isDown = this.isDown;\n    this.previousState.isConfirm = this.isConfirm;\n    // this.previousState.isEscape = this.isEscape;\n    this.previousState.isAction1 = this.isAction1;\n\n    const leftVal = (this.keyMap.get('KeyA') || this.keyMap.get('KeyQ') || this.keyMap.get('ArrowLeft')) ? -1 : 0;\n    const rightVal = (this.keyMap.get('KeyD') || this.keyMap.get('ArrowRight')) ? 1 : 0;\n    const upVal = this.keyMap.get('KeyW') || (this.keyMap.get('KeyZ') || this.keyMap.get('ArrowUp')) ? -1 : 0;\n    const downVal = (this.keyMap.get('KeyS') || this.keyMap.get('ArrowDown')) ? 1 : 0;\n    this.inputDirection.x = (leftVal + rightVal) || 0;\n    this.inputDirection.y = (upVal + downVal) || 0;\n\n    // const deadzone = 0.1;\n    // if (Math.hypot(this.inputDirection.x, this.inputDirection.y) < deadzone) {\n    //   this.inputDirection.x = 0;\n    //   this.inputDirection.y = 0;\n    // }\n\n    this.isUp = this.inputDirection.y < 0;\n    this.isDown = this.inputDirection.y > 0;\n    this.isLeft = this.inputDirection.x < 0;\n    this.isRight = this.inputDirection.x > 0;\n    this.isMoving = this.inputDirection.x !== 0 || this.inputDirection.y !== 0;\n    this.isConfirm = Boolean(this.keyMap.get('Enter'));\n    // this.isEscape = Boolean(this.keyMap.get('Escape'));\n    this.isAction1 = Boolean(this.keyMap.get('Space'));\n  }\n\n  private toggleKey(event: KeyboardEvent, isPressed: boolean) {\n    this.keyMap.set(event.code, isPressed);\n  }\n}\n\nexport const controls = new Controls();\n","/* eslint-disable id-denylist */\n// Canvas creation and context helpers for bundle size optimization\n\nexport const createCanvas = (w?: number, h?: number) => {\n  const c = document.createElement('canvas');\n  if (w) c.width = w;\n  if (h) c.height = h;\n  return c;\n};\n\nexport const getCtx = (canvas: HTMLCanvasElement) => canvas.getContext('2d')!;\n\nexport const createCanvasWithCtx = (w?: number, h?: number) => {\n  const canvas = createCanvas(w, h);\n  return [canvas, getCtx(canvas)] as const;\n};\n\nexport const setCanvasSize = (canvas: HTMLCanvasElement, w: number, h: number) => {\n  canvas.width = w;\n  canvas.height = h;\n};\n","import { createCanvasWithCtx } from './util/canvas';\n\n/**\n * Quantizes rgba color values to 8bit.\n */\nconst quantizeToPalette = (r: number, g: number, b: number, a: number) => {\n  // 1-bit transparency\n  if (a < 128) {\n    return [0, 0, 0, 0]; // transparent\n  }\n  const qr = Math.round(r / 51) * 51;\n  const qg = Math.round(g / 51) * 51;\n  const qb = Math.round(b / 51) * 51;\n\n  return [qr, qg, qb, 255];\n};\n\n/**\n * Converts an emoji to a pixelated image by quantizing the colors\n * to 8 bit and the transparency to 1 bit.\n */\nexport const emojiToPixelArt = (\n  emoji: string,\n  fontSize = 10,\n) => {\n  // Some emoji are a bit bigger than the font\n  const spriteScale = 0.25;\n  const spriteSize = Math.floor(fontSize * (1 + spriteScale));\n  const padding = Math.floor(fontSize * spriteScale / 2);\n\n  // Create temporary canvas\n  const [_, tmpCtx] = createCanvasWithCtx(spriteSize, spriteSize);\n\n  // Draw emoji in chosen font size\n  tmpCtx.font = `${fontSize}px sans-serif`;\n  tmpCtx.textBaseline = 'top';\n  tmpCtx.clearRect(0, 0, spriteSize, spriteSize);\n  tmpCtx.translate(-1, 0);\n  tmpCtx.fillText(emoji, padding, padding);\n\n  // Read pixels\n  const imgData = tmpCtx.getImageData(0, 0, spriteSize, spriteSize);\n  const data = imgData.data;\n\n  // Create new image data with quantized colors\n  const outImg = tmpCtx.createImageData(spriteSize, spriteSize);\n  const outData = outImg.data;\n  for (let i = 0; i < data.length; i += 4) {\n    const [r, g, b, a] = quantizeToPalette(\n      data[i],      // red\n      data[i + 1],  // green\n      data[i + 2],  // blue\n      data[i + 3],  // alpha\n    );\n    outData[i] = r;\n    outData[i + 1] = g;\n    outData[i + 2] = b;\n    outData[i + 3] = a;\n  }\n\n  // Create a new canvas to draw the quantized image\n  const [outCanvas, outCtx] = createCanvasWithCtx(spriteSize, spriteSize);\n  outCtx.putImageData(outImg, 0, 0);\n\n  // Create an image element from the canvas\n  const img = new Image();\n  img.src = outCanvas.toDataURL();\n  return img;\n};\n\n\n// const ctx = c.getContext(\"2d\");\n// ctx.imageSmoothingEnabled = false;\n\n\n// const font = 8;\n// const spriteSize = Math.floor(font * 1.25); // must match function logic\n\n// const emojis = ['🔥','🍀','🌼','🐓','🌷','🌹','👻','🥚','🍎'];\n\n// emojis.forEach((emoji, i) => {\n//   const col = i % (100 / spriteSize);       // column in grid\n//   const row = Math.floor(i / (100 / spriteSize)); // row in grid\n//   const x = col * spriteSize;\n//   const y = row * spriteSize;\n\n//   emojiToPixelArt(emoji, ctx, font, x, y);\n// });\n","export const generateImageData = (icon: string, iconPalette: string[]): HTMLImageElement => {\n  const transparent = '#FF00FF';\n  const palette = [transparent, ...iconPalette];\n  \n  const colorsPerByte = palette.length > 4 ? 2 : palette.length > 2 ? 3 : 6;\n  const bytesPerColor = 6 / colorsPerByte;\n  const bitMask = (1 << bytesPerColor) - 1;\n  const canvas = document.createElement('canvas');\n  const size = Math.sqrt(icon.length * colorsPerByte);\n  canvas.setAttribute('width', size.toString());\n  canvas.setAttribute('height', size.toString());\n  const ctx = canvas.getContext('2d')!;\n  const imgData = ctx.createImageData(size, size);\n  const data = imgData.data;\n  \n  let i = 0;\n  [...icon].map(c => {\n    const z = c.charCodeAt(0);\n\n    for (let bit = 0; bit < colorsPerByte; bit++) {\n      const paletteIndex = (z >> bit * bytesPerColor) & bitMask;\n      const hexColor = palette[paletteIndex] || transparent;\n      \n      // Convert hex to RGB\n      const hex = hexColor.replace('#', '');\n      const r = parseInt(hex.substring(0, 2), 16);\n      const g = parseInt(hex.substring(2, 4), 16);\n      const b = parseInt(hex.substring(4, 6), 16);\n      const a = paletteIndex ? 255 : 0;\n      \n      data[i] = r;\n      data[i + 1] = g;\n      data[i + 2] = b;\n      data[i + 3] = a;\n      i += 4;\n    }\n  });\n\n  \n  ctx.putImageData(imgData, 0, 0);\n  const img = new Image();\n  img.src = canvas.toDataURL();\n  return img;\n};\n","import { generateImageData } from '@/game/sprite-loader';\n\nexport class NewTileset<T extends string | number> {\n  public animations: Record<T, HTMLImageElement[]> = {} as Record<T, HTMLImageElement[]>;\n  public tileSize = 16;\n\n  constructor(\n    public spriteSheet: { size: number, palette: string[]; data: Record<T, string[]> },\n  ) {\n    // Process each animation (sit, idle, walk, run, etc.)\n    for (const [animationName, frames] of Object.entries(spriteSheet.data) as [T, string[]][]) {\n      this.animations[animationName] = frames.map((frameData: string) => \n        generateImageData(frameData, spriteSheet.palette)\n      );\n    }\n    this.tileSize = spriteSheet.size;\n  }\n}\n","export const hexToRgb = (hex: string) : number[] => {\n  // @ts-ignore\n  return hex.replace(\n    /^#?([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n    (_, r, g, b, a) => '#' + r + r + g + g + b + b + a + a)\n    .substring(1)\n    .match(/.{2}/g)\n    .map(x => parseInt(x, 16)\n  );\n};\n\n\nexport type Color =\n'green0' | \n'green1' | \n'green2' | \n'green3' | \n'green4' | \n'green5' | \n'green6' | \n'blue0' | \n'blue1' | \n'blue2' | \n'blue3' | \n'blue4' | \n'blue5' | \n'blue6' | \n'purple0' | \n'purple1' | \n'purple2' | \n'purple3' | \n'purple4' | \n'purple5' | \n'yellow0' | \n'yellow1' | \n'yellow2' | \n'black' | \n'white';\n\n// export const colors: Record<Color, string> = new Proxy({}, {\n//   get: (_, prop: string) => {\n//     if (typeof window === 'undefined' || typeof document === 'undefined') return '';\n//     const value = getComputedStyle(document.documentElement).getPropertyValue(`--${prop}`);\n//     return value.trim() || '';\n//   }\n// });\n\n// function getColorsFromCSS() {\n//   const root = document.documentElement;\n//   const computedStyle = getComputedStyle(root);\n  \n//   const colorKeys = [\n//     'green0', 'green1', 'green2', 'green3',\n//     'blue0', 'blue1', 'blue2', 'blue3', 'blue4', 'blue5', 'blue6',\n//     'purple0', 'purple1', 'purple2', 'purple3', 'purple4', 'purple5',\n//     'yellow0', 'yellow1', 'yellow2',\n//     'black', 'white'\n//   ];\n  \n//   const colors = {};\n//   colorKeys.forEach((key: string) => {\n//     // @ts-expect-error\n//     colors[key] = computedStyle.getPropertyValue(`--${key}`).trim();\n//   });\n  \n//   return colors;\n// }\n\nexport const colors: Record<Color, string> = {\n  green0: '#b3d7ad',\n  green1: '#9dc4a0',\n  green2: '#89b290',\n  green3: '#75a080',\n  green4: '#618e70',\n  green5: '#4d7c60',\n  green6: '#396a50',\n  blue0: '#b4ecf3',\n  blue1: '#4e9ca6',\n  blue2: '#3e8791',\n  blue3: '#2f6269',\n  blue4: '#255056',\n  blue5: '#1f4347',\n  blue6: '#13282b',\n  purple0: '#e0b8d3',\n  purple1: '#d49bc2',\n  purple2: '#b34d92',\n  purple3: '#551641',\n  purple4: '#714162',\n  purple5: '#996a8a',\n  yellow0: '#fffef9',\n  yellow1: '#f2daab',\n  yellow2: '#e6a386',\n  black: '#13282b',\n  white: '#fffef9'\n};\n","// Auto-generated icon data\n// Generated on 2025-09-04T14:10:07.197Z\n\nimport { colors } from '@/core/util/color';\nimport { CatStates, VillagerStates } from './game-assets';\n\nexport const cat = {\n  size: 10,\n  frames: 4,\n  palette: [\n    colors.black,\n  ],\n  data: {\n    [CatStates.idle]: [\n      '@@@`@PJbcxpO|AQ@@',\n      '@@@`@DJbcxpO|AQ@@',\n      '@@@@h@nag|pG|AQ@@',\n      '@@@@@@z`SxxO|AQ@@'\n    ],\n    [CatStates.walk]: [\n      '@@@`@DJbcxpO|AR@@',\n      '@@@P@HJdCy`OpC`@@',\n      '@@@@@DJbCy`OxCR@@',\n      '@@@H@DJbcxpO|AA@@'\n    ],\n    [CatStates.run]: [\n      '@@@@@@@`ZxyO~@B@@',\n      '@@@@@@J`_|xG~@E@@',\n      '@@@@@@@`ZxyO~PB@@',\n      '@@@@@@J`CxG~@D@@'\n    ],\n    [CatStates.die]: [\n      '@@@@AHJdCy`OxCb@@',\n      '@@@@@@jcC`C@@@@@',\n      '@@@@@@@@@x|oxG@@@',\n      '@@@@@@@@@@@N~yC@'\n    ],\n    [CatStates.scratch]: [\n      '@@@`@DJbcxpO|AQ@@',\n      '@@@@@BPhHN|Ka@@@',\n      '@@@D@BEqQ\\\\xG~`P@@',\n      '@@@P@DJbcxpO|AQ@@'\n    ],\n    [CatStates.scared]: [\n      '@`@H@F`Wy_~GsPD@@',\n      '@`@H@B`Qy_~GwPD@@',\n      '@`@H@F`Wy_~GsPD@@',\n      '@`@H@B`Qy_~GwPD@@'\n    ],\n    [CatStates.sleep]: [\n      '@@@@@@@@@h~_~K@@@',\n      '@@@@@@@`Bx~_~E@@@',\n      '@@@@@@@`Bx}o~A@@@',\n      '@@@@@@@@@h|~C@@@'\n    ],\n    [CatStates.attack]: [\n      '@@PA\\\\@GxFV~IL@A@@',\n      '@@PA\\\\@gxHv|AL@A@@',\n      '@@PA\\\\HGyRVxIL@A@@',\n      '@@h@N`CxXwxAL@A@@'\n    ],\n    [CatStates.sit]: [\n      '@@@@@@J`SxBG{@O@@',\n      '@@@@@@j`KxLG|AO@@',\n      '@@@@@@J`CxGGz@O@@',\n      '@@@@@@J`OxDGz@O@@'\n    ]\n  }\n};\n\nexport const villager = {\n  size: 8,\n  frames: 4,\n  palette: [\n    colors.purple0,\n    colors.blue6,\n  ],\n  data: {\n    [VillagerStates.walk]: [\n      'PUAUUQVVTUEUUajj`@B@`@',\n      '@@@TUPUUdeEUUQUUhjJH`@',\n      'PUAUUQVVTUEUUajj`@BH@@',\n      '@@@TUPUUdeEUUQUUhjJH`@'\n    ],\n    [VillagerStates.scared]: [\n      '@@@TUPUUTfEiiQUUhjJH`@',\n      '@@@UETUEeYQZZTUEjjBBH@',\n    ],\n  }\n};\n\nexport const statue = {\n  size: 16,\n  palette: [\n    colors.blue2,\n    colors.blue3,\n    colors.blue4,\n  ],\n  data: '@@@@@@@DD@@@`e@@@@jB@@@hJ@@@@O@@@@}A@@@xK@@@`o@@@p~N@@T{{E@TmoWAPUUUE@WUUu@|C@C@'\n};\n\nexport const obelisk = {\n  size: 16,\n  palette: [\n    colors.blue2,\n    colors.blue3,\n    colors.blue4,\n  ],\n  data: '@PUE@@`UUB@@VUI@@xo@@poC@@kjN@@l{@@p~C@@kjN@@|o@@p{~C@@{O@@|k@@pC@@|C@@@@@@@'\n};\n\nexport const oak = {\n  size: 16,\n  palette: [\n    colors.green6,\n    colors.green3,\n    colors.green0,\n    colors.green5,\n  ],\n  data: '@@@@@@@@@@HIIA@@@@Q[[J@@@HZ[[SA@@QR[[RJ@@QRRRRJ@@aRRRRL@@QTRRbJ@@abbTTL@@aTTbbL@@IddddI@@HaddLA@@@HIIA@@@@HIIA@@@@@II@@@@@@@@@@@',\n};\n\nexport const spruce = {\n  size: 16,\n  palette: [\n    colors.blue3,\n    colors.blue0,\n    colors.blue1,\n    colors.blue2,\n  ],\n  data: '@@@HA@@@@@@QJ@@@@@HRRA@@@@YSZK@@@H[[[[A@@H[[[[A@@a\\\\[[cL@@acc\\\\\\\\L@@a\\\\\\\\ccL@@adc\\\\dL@@IddddI@@HaddLA@@@HIIA@@@@HIIA@@@@@II@@@@@@@@@@@',\n};\n\nexport const grass = {\n  size: 16,\n  palette: [\n    colors.green4,\n    colors.green5,\n    colors.green6,\n  ],\n  data: 'PPDDAP^feYTvVVYfweYZi]YfeiMgVvYv|Vvey`YZYvCfeiiCYZVfE\\\\wYZ[qWvefFle]fvPVfuY@g[dCpsCpC@'\n};\n\nexport const house = {\n  size: 16,\n  palette: [\n    colors.blue4,\n    colors.blue2,\n    colors.blue3\n  ],\n  data: 'PU@@@PjVUU@YyGdjWU]PkAm^UUGt_PWUUuA}GTUUUUpjjjjC[_ZUNlk}ypvgVgCkjZ_N|}}@'\n};\n\nexport const ground = {\n  size: 12,\n  palette: [\n    colors.green4,\n    colors.green5,\n  ],\n  data: '@@@@@@D@@A@D@DA@DY@@PjEDA@@@@@A@@@@@@@@QQ@AdF@Pi',\n};\n","import { emojiToPixelArt } from '@/core/emoji';\nimport { NewTileset as NewTileset } from '@/core/tileset';\nimport { createCornerImage } from '@/core/util/image-generator';\nimport { generateImageData } from './sprite-loader';\nimport { cat, grass, ground, house, oak, obelisk, spruce, statue, villager } from './sprites';\nimport { colors } from '@/core/util/color';\n\nexport const enum CatStates {\n  idle,\n  walk, \n  run,\n  die,\n  scratch,\n  scared,\n  sleep,\n  attack,\n  sit,\n}\nexport const enum VillagerStates {\n  walk,\n  scared,\n} ;\n\nconst emoji = '🔥,🍀,🌼,🐓,🌷,🌹,👻,🥚,🍎'.split(',');\nexport const icons = emoji.map(e => emojiToPixelArt(e));\n\nexport class GameAssets {\n  static cat: NewTileset<CatStates>;\n  static villager: NewTileset<VillagerStates>;\n  static cornerImage: HTMLImageElement;\n  static oak: HTMLImageElement;\n  static spruce: HTMLImageElement;\n  static house: HTMLImageElement;\n  static grass: HTMLImageElement;\n  static ground: HTMLImageElement;\n  static statue: HTMLImageElement;\n  static statueGold: HTMLImageElement;\n  static obelisk: HTMLImageElement;\n  static obeliskGold: HTMLImageElement;\n\n  public static initialize() {\n    GameAssets.cat = new NewTileset<CatStates>(cat);\n    GameAssets.villager = new NewTileset<VillagerStates>(villager);\n    GameAssets.cornerImage = createCornerImage();\n    GameAssets.oak = generateImageData(oak.data, oak.palette);\n    GameAssets.spruce = generateImageData(spruce.data, spruce.palette);\n    GameAssets.house = generateImageData(house.data, house.palette);\n    GameAssets.grass = generateImageData(grass.data, grass.palette);\n    GameAssets.ground = generateImageData(ground.data, ground.palette);\n    \n    const goldPalette = [colors.yellow0, colors.yellow1, colors.yellow2];\n    GameAssets.statue = generateImageData(statue.data, statue.palette);\n    GameAssets.statueGold = generateImageData(statue.data, goldPalette);\n    GameAssets.obelisk = generateImageData(obelisk.data, obelisk.palette);\n    GameAssets.obeliskGold = generateImageData(obelisk.data, goldPalette);\n  }\n}\n","import { colors } from './color';\nimport { createCanvasWithCtx } from './canvas';\n\n/**\n * Creates a 16x16 image with transparent background and colored corners\n * @param cornerColor The color to use for the 3x3 corner pixels\n * @returns HTMLImageElement ready to be used with drawImage\n */\nexport function createCornerImage(cornerColor: string = colors.purple4): HTMLImageElement {\n  // Create temporary canvas\n  const [canvas, ctx] = createCanvasWithCtx(16, 16);\n\n  // Clear to transparent\n  ctx.clearRect(0, 0, 16, 16);\n\n  // Set corner color\n  ctx.fillStyle = cornerColor;\n\n  // Draw 2x2 arrow corners (3 pixels each, 1 transparent)\n  \n  // Top-left corner arrow (pointing inward)\n  ctx.fillRect(0, 0, 1, 1); // top-left pixel\n  ctx.fillRect(1, 0, 1, 1); // top-right pixel  \n  ctx.fillRect(0, 1, 1, 1); // bottom-left pixel\n  // (1,1) is transparent\n  \n  // Top-right corner arrow (pointing inward)\n  ctx.fillRect(14, 0, 1, 1); // top-left pixel\n  ctx.fillRect(15, 0, 1, 1); // top-right pixel\n  ctx.fillRect(15, 1, 1, 1); // bottom-right pixel\n  // (14,1) is transparent\n  \n  // Bottom-left corner arrow (pointing inward)\n  ctx.fillRect(0, 14, 1, 1); // top-left pixel\n  ctx.fillRect(0, 15, 1, 1); // bottom-left pixel\n  ctx.fillRect(1, 15, 1, 1); // bottom-right pixel\n  // (1,14) is transparent\n  \n  // Bottom-right corner arrow (pointing inward)\n  ctx.fillRect(15, 14, 1, 1); // top-right pixel\n  ctx.fillRect(14, 15, 1, 1); // bottom-left pixel\n  ctx.fillRect(15, 15, 1, 1); // bottom-right pixel\n  // (14,14) is transparent\n\n  // Convert canvas to image\n  const img = new Image();\n  img.src = canvas.toDataURL();\n  \n  return img;\n}\n","import { hexToRgb, colors } from '@/core/util/color';\nimport { createCanvasWithCtx } from '@/core/util/canvas';\n\nexport const tinyFont = /* font-start */'6v7ic,6trd0,6to3o,6nvic,55eyo,2np50,2jcjo,3ugt8,34ao,7k,glc,1,opzc,3xdeu,3sapz,8rhfz,8ri26,1bzky,9j1ny,3ws2u,9dv9k,3xb1i,3xbmu,2t8g,2t8s,26ndv,ajmo,fl5ug,3x7nm,n75t,54br,59u0e,53if,rlev,4jrb,1yjk4,4eav,55q95,18zsz,mi3r,574tl,1aedd,ljn9,a1bd,4f1i,a1fs,549t,53ig,5832,1dwsh,6iw6,6ix0,cbsa,6gix,6fk4,aky7,7mbws,cvtyq,deehh,2sfi3'/* font-end */.split(',');\n\n// Character cache: charCode-color-size -> Canvas\nconst characterCanvases: { [key: string]: HTMLCanvasElement } = {};\n\nexport const FULL_HEART = '#';\nexport const TWO_THIRDS_HEART = '$';\nexport const ONE_THIRD_HEART = '%';\nexport const EMPTY_HEART = '&';\nexport const COLCHEIA = '*';\nexport const HOUSE = '^';\n\nexport const TELEPORT = '[';\nexport const SCRATCH = '\\\\';\nexport const MAGIC = ']';\n\nexport type DrawTextProps = {\n  text: string\n  x: number\n  y: number\n  color?: string\n  textAlign?: CanvasTextAlign\n  textBaseline?: CanvasTextBaseline\n  size?: number\n  space?: number\n}\n\nconst getCharacterData = (letter: string) => {\n  if (letter === '0') return { paddedBinary: '0'.repeat(25), leftmostCol: 0, charWidth: 5 };\n  \n  const paddedBinary = String(parseInt(letter, 36).toString(2)).padStart(25, '0');\n  let leftmostCol = 5;\n  let rightmostCol = -1;\n  \n  // Find leftmost and rightmost columns with set bits\n  for (let col = 0; col < 5; col++) {\n    for (let row = 0; row < 5; row++) {\n      const bitIndex = row * 5 + col;\n      if (paddedBinary[bitIndex] === '1') {\n        leftmostCol = Math.min(leftmostCol, col);\n        rightmostCol = Math.max(rightmostCol, col);\n      }\n    }\n  }\n  \n  const charWidth = rightmostCol >= leftmostCol ? rightmostCol - leftmostCol + 1 : 1;\n  return { paddedBinary, leftmostCol, charWidth };\n};\n\nconst getCharacterWidth = (letter: string): number => {\n  return getCharacterData(letter).charWidth;\n};\n\nconst createCharacterCanvas = (character: string, size: number, color: string): HTMLCanvasElement => {\n  const letter = character === ' ' ? '0' : tinyFont[character.charCodeAt(0) - 35];\n  const { paddedBinary, leftmostCol, charWidth } = getCharacterData(letter);\n  \n  const scaledWidth = charWidth * size;\n  const letterHeight = 5 * size;\n  \n  const [canvas, ctx] = createCanvasWithCtx(scaledWidth, letterHeight);\n  \n  const [r, g, b, a] = hexToRgb(color);\n  const fillStyle = `rgba(${r}, ${g}, ${b}, ${(a || 255) / 255})`;\n  \n  // Draw character bitmap\n  paddedBinary.split('').forEach((bit, bitIndex) => {\n    if (bit !== '0') {\n      const col = bitIndex % 5;\n      const row = Math.floor(bitIndex / 5);\n      \n      // Skip empty left columns\n      if (col < leftmostCol) return;\n      \n      const adjustedCol = col - leftmostCol;\n      \n      ctx.fillStyle = fillStyle;\n      ctx.fillRect(adjustedCol * size, row * size, size, size);\n    }\n  });\n\n  return canvas;\n};\n\nconst getCharacterCanvas = (character: string, size: number, color: string): HTMLCanvasElement => {\n  const cacheKey = `${character.charCodeAt(0)}-${color}-${size}`;\n  \n  if (!characterCanvases[cacheKey]) {\n    characterCanvases[cacheKey] = createCharacterCanvas(character, size, color);\n  }\n  \n  return characterCanvases[cacheKey];\n};\n\nexport const drawText = (\n  c: CanvasRenderingContext2D,\n  text: string,\n  x: number,\n  y: number,\n  color = colors.white,\n  textAlign = 0, // 0=left, 1=center, 2=right\n  textBaseline = 0, // 0=top, 1=middle, 2=bottom  \n  size = 2,\n  space = 1\n) => {\n  x = Math.round(x);\n  y = Math.round(y);\n  if (!text) text = ' ';\n  \n  // Calculate variable width for text\n  const spacing = space * size;\n  const characters = text.replace('!', '@').toUpperCase().split('');\n  \n  // Calculate positions and total width\n  let totalWidth = 0;\n  const charPositions: { char: string; x: number; charWidth: number }[] = [];\n  \n  characters.forEach((character, i) => {\n    const letter = character === ' ' ? '0' : tinyFont[character.charCodeAt(0) - 35];\n    const charWidth = getCharacterWidth(letter) * size;\n    \n    charPositions.push({ char: character, x: totalWidth, charWidth });\n    totalWidth += charWidth + (i < characters.length - 1 ? spacing : 0);\n  });\n  \n  const letterHeight = 5 * size;\n  const offsetX = textAlign === 0 ? 0 : textAlign === 1 ? Math.round(totalWidth / 2) : totalWidth;\n  const offsetY = textBaseline === 0 ? 0 : textBaseline === 1 ? Math.round(letterHeight / 2) : letterHeight;\n  \n  // Draw each character synchronously\n  charPositions.forEach(({ char, x: charX, charWidth }) => {\n    if (char === ' ') return; // Skip spaces\n    \n    const canvas = getCharacterCanvas(char, size, color);\n    c.drawImage(canvas, 0, 0, charWidth, letterHeight, x - offsetX + charX, y - offsetY, charWidth, letterHeight);\n  });\n};\n\n\n","import { GameAssets } from '@/game/game-assets';\nimport { drawText } from './font';\nimport { colors } from './util/color';\nimport { getCtx } from './util/canvas';\n\nconst makeCircle = (\n  ctx: CanvasRenderingContext2D,\n  centerX: number,\n  centerY: number,\n  radiusX: number,\n  radiusY: number,\n  skew = 0,\n) => {\n  // Draw ellipse using scaled circle algorithm\n  for (let y = -radiusY; y <= radiusY; y++) {\n    // Calculate the half-width at this y position using ellipse equation\n    const normalizedY = y / radiusY;\n    const halfWidth = Math.round(radiusX * Math.sqrt(1 - normalizedY * normalizedY));\n    \n    if (halfWidth > 0) {\n      const offset = Math.round(skew * Math.abs(y));\n      const currentY = centerY + y;\n      \n      if (y >= 0) {\n        ctx.rect(centerX - halfWidth - offset, currentY, halfWidth * 2, 1);\n      } else {\n        ctx.rect(centerX - halfWidth + offset, currentY, halfWidth * 2, 1);\n      }\n    }\n  }\n};\n\nclass DrawEngine {\n  ctx1: CanvasRenderingContext2D;\n  ctx2: CanvasRenderingContext2D;\n  ctx3: CanvasRenderingContext2D;\n  ctx4: CanvasRenderingContext2D;\n\n  // Canvas dimensions (cached for performance)\n  canvasWidth = 0;\n  canvasHeight = 0;\n\n  // Camera properties\n  cameraX = 0;\n  cameraY = 0;\n  zoom = 1;\n  targetCameraX = 0;\n  targetCameraY = 0;\n  targetZoom = 1;\n  cameraLerpSpeed = 0.08; // Adjust for faster/slower camera\n\n  constructor() {\n    this.ctx1 = getCtx(c1);\n    this.ctx2 = getCtx(c2);\n    this.ctx3 = getCtx(c3);\n    this.ctx4 = getCtx(c4);\n    GameAssets.initialize();\n    this.resizeCanvas();\n    window.addEventListener('resize', () => this.resizeCanvas());\n    window.addEventListener('orientationchange', () => this.resizeCanvas());\n  }\n\n  resizeCanvas() {\n    const aspectRatio = 4 / 3;\n    const gameWidth = 1200;\n    const gameHeight = Math.round(gameWidth / aspectRatio);\n    this.canvasWidth = gameWidth;\n    this.canvasHeight = gameHeight;\n    const ctxs: CanvasRenderingContext2D[] = [this.ctx1, this.ctx2, this.ctx3, this.ctx4];\n    for (const ctx of ctxs) {\n      // eslint-disable-next-line id-denylist\n      ctx.canvas.width = gameWidth;\n      // eslint-disable-next-line id-denylist\n      ctx.canvas.height = gameHeight;\n      ctx.imageSmoothingEnabled = false;\n    }\n  }\n\n  \n  // eslint-disable-next-line class-methods-use-this\n  drawCircumference(\n    ctx: CanvasRenderingContext2D,\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    color: string,\n    strokeWidth: number,\n  ) {\n    ctx.save();\n    ctx.beginPath();\n    makeCircle(ctx, centerX, centerY, radiusX, radiusY);\n    makeCircle(ctx, centerX, centerY, radiusX - strokeWidth, radiusY - strokeWidth);\n    ctx.clip('evenodd');\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.fillRect(centerX - radiusX, centerY - radiusY, radiusX*2, radiusY*2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  drawText(\n    text: string,\n    x: number,\n    y: number,\n    color?: string,\n    textAlign = 0,\n    textBaseline = 0,\n    size = 2,\n    space = 1,\n    context?: CanvasRenderingContext2D\n  ) {\n    drawText(context || this.ctx1, text, x, y, color, textAlign, textBaseline, size, space);\n  }\n\n  static drawImage(\n    ctx: CanvasRenderingContext2D,\n    img: HTMLImageElement,\n    x: number,\n    y: number,\n    mirrored?: boolean,\n    imgWidth?: number,\n    imgWeight?: number,\n  ) {\n    if (mirrored) {\n      ctx.save();\n      ctx.scale(-1, 1);\n      x = -x - (imgWidth ?? img.width);\n    }\n    ctx.drawImage(\n      img,\n      x,\n      y,\n      imgWidth ?? img.width,\n      imgWeight ?? img.height,\n    );\n    if (mirrored) {\n      ctx.restore();\n    }\n  }\n\n  drawBackgroundImage(\n    img: HTMLImageElement,\n    x: number,\n    y: number,\n    mirrored?: boolean,\n    imgWidth?: number,\n    imgHeight?: number,\n  ) {\n    DrawEngine.drawImage(this.ctx1, img, x, y, mirrored, imgWidth, imgHeight);\n  }\n\n  /**\n   * Sets the camera position and zoom level.\n   * @param x The x-coordinate of the object where the camera should focus\n   * @param y The y-coordinate of the object where the camera should focus\n   * @param zoom The zoom level of the camera\n   */\n  setCamera(x: number, y: number, zoom: number = 1, immediate = false) {\n    this.targetCameraX = x;\n    this.targetCameraY = y;\n    this.targetZoom = zoom;\n    const cx = this.canvasWidth / 2 - 32;\n    const cy = this.canvasHeight / 2 - 64;\n    if (immediate) {\n      this.cameraX = x;\n      this.cameraY = y;\n      this.zoom = zoom;\n    }\n    this.ctx1.setTransform(\n      this.zoom, 0, 0, this.zoom,\n      cx - this.cameraX * this.zoom,\n      cy - this.cameraY * this.zoom,\n    );\n  }\n\n  updateCamera() {\n    this.cameraX += (this.targetCameraX - this.cameraX) * this.cameraLerpSpeed;\n    if (Math.abs(this.targetCameraX - this.cameraX) < 0.01) {\n      this.cameraX = this.targetCameraX;\n    }\n    this.cameraY += (this.targetCameraY - this.cameraY) * this.cameraLerpSpeed;\n    if (Math.abs(this.targetCameraY - this.cameraY) < 0.01) {\n      this.cameraY = this.targetCameraY;\n    }\n    this.zoom += (this.targetZoom - this.zoom) * this.cameraLerpSpeed;\n    if (Math.abs(this.targetZoom - this.zoom) < 0.02) {\n      this.zoom = this.targetZoom;\n    }\n  }\n\n  resetCamera() {\n    this.ctx1.setTransform(1, 0, 0, 1, 0, 0);\n  }\n\n  clear() {\n    this.resetCamera();\n    this.ctx1.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n    this.ctx1.fillStyle = colors.green3;\n    this.ctx1.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n    this.ctx2.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n    this.ctx3.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n  }\n\n  /**\n   * Converts world coordinates to screen coordinates, accounting for camera transforms\n   * @param worldX World X coordinate\n   * @param worldY World Y coordinate\n   * @param zoom Current zoom level (defaults to 7, matching game state)\n   * @returns Screen coordinates { x, y }\n   */\n  worldToScreen(worldX: number, worldY: number, zoom: number = 7): { x: number; y: number } {\n    const cx = this.canvasWidth / 2 - 32;\n    const cy = this.canvasHeight / 2 - 64;\n\n    return {\n      x: cx + (worldX - this.cameraX) * zoom,\n      y: cy + (worldY - this.cameraY) * zoom\n    };\n  }\n}\n\nexport const drawEngine = new DrawEngine();\n","import { Circle, Path } from './types';\n\nexport const CELL_WIDTH = 12;\nexport const CELL_HEIGHT = 12;\n\nexport const MAX_LIVES = 9;\nexport const MAX_MAGIC = 6;\nexport const MAX_REPAIR = 20;\n\nexport const NOTIFICATION_DURATION = 5000;\n\nexport const paths: Path[] = [\n  // Main path\n  [\n    [69, 100, 3],\n    [76, 113, 4],\n    [89, 114, 5],\n    [104, 86, 3],\n    [99, 59, 3],\n    [85, 46, 2],\n    [86, 28, 2],\n    [74, 38, 2],\n    [60, 39, 2],\n    [48, 30, 2],\n    [46, 43, 2],\n    [38, 61, 3],\n    [50, 73, 4],\n    [38, 84, 3],\n    [46, 123, 3],\n    [36, 133, 2],\n    [48, 141, 3],\n    [94, 133, 4],\n    [113, 109, 5],\n    [122, 74, 6],\n    [113, 56, 0.9],\n  ],\n\n  // Smaller paths\n  [[45, 49, 0.9], [71, 51, 0.9]],\n\n  // Northwest village path\n  [[119, 54, 1], [129, 29, 1]],\n];\n\nexport const clearings: Circle[] = [\n  // Peak\n  { x: 64, y: 88, r: 6 },\n  { x: 75, y: 88, r: 6 },\n  { x: 69, y: 95, r: 6 },\n\n  // Northeast village\n  { x: 129, y: 28, r: 10 },\n\n  // Eye\n  { x: 71, y: 51, r: 3 },\n];\n\nexport const statues = {\n  heart: { x: 76, y: 84, name: 'heart' },\n  moon: { x: 129, y: 19, name: 'moon' },\n  ear: { x: 49, y: 29, name: 'ear' },\n  eye: { x: 71, y: 50, name: 'eye' },\n  foot: { x: 35, y: 131, name: 'foot' },\n  tail: { x: 114, y: 56, name: 'tail' },\n} as const;\n","import { CELL_WIDTH, CELL_HEIGHT } from '@/game/constants';\nimport { drawEngine } from './draw-engine';\nimport { updatePositionSmoothly, SmoothMovementState } from '../utils/smooth-movement';\n\ninterface Tileset<T extends (string | number)> {\n  animations: Record<T, HTMLImageElement[]>;\n  tileSize: number;\n}\n\nexport class GameObject<T extends (string | number)> implements SmoothMovementState {\n  animationTime = 0;\n  animationFrame = 0;\n  aD = 150; // Duration for each animation frame in milliseconds\n  animationLoop = true;\n  col: number;\n  row: number;\n  moving = { x: 0, y: 0 };\n  targetPos: { x: number; y: number };\n\n  constructor(\n    private readonly tileset: Tileset<T>,\n    public x: number,\n    public y: number,\n    public type: string,\n    public animation: T,\n    public speed: number = 0,\n    public mirrored: boolean = false,\n  ) {\n    this.col = Math.ceil(x / CELL_WIDTH);\n    this.row = Math.ceil(y / CELL_HEIGHT);\n    this.animationTime = Math.random() * this.aD;\n    this.targetPos = { x: this.x, y: this.y };\n  }\n\n  setPos(col: number, row: number) {\n    this.col = col;\n    this.row = row;\n    this.x = col * CELL_WIDTH;\n    this.y = row * CELL_HEIGHT;\n    this.targetPos = { x: this.x, y: this.y };\n  }\n\n  update(timeElapsed: number) {\n    if (!this.animationLoop && this.animationFrame === (this.tileset.animations[this.animation].length - 1)) {\n      return;\n    }\n    this.animationTime += timeElapsed;\n    this.animationFrame = Math.floor(this.animationTime / this.aD) % this.tileset.animations[this.animation].length;\n  }\n\n  updatePositionSmoothly(timeElapsed: number) {\n    updatePositionSmoothly(this, timeElapsed);\n    if (this.moving.x !== 0) {\n      this.mirrored = this.moving.x < 0;\n    }\n  }\n\n  draw() {\n    const animation = this.tileset.animations[this.animation];\n    if (animation[this.animationFrame]) {\n      drawEngine.drawBackgroundImage(\n        animation[this.animationFrame],\n        this.x - (this.tileset.tileSize - CELL_WIDTH) / 2,\n        this.y - (this.tileset.tileSize - CELL_HEIGHT) / 2,\n        this.mirrored,\n      );\n    }\n  }\n\n}\n","const listeners: Array<{ eventName: string; handler: EventListener }> = [];\n\nexport const on = (event: number, listener: (detail: any) => void) => {\n  const eventName = String(event);\n  const handler = (e: Event) => {\n    listener((e as CustomEvent).detail);\n  };\n  document.addEventListener(eventName, handler);\n  listeners.push({ eventName, handler });\n};\n\nexport const emit = (event: number, data?: any) => {\n  const eventName = String(event);\n  document.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n};\n\nexport const clearEvents = () => {\n  for (const { eventName, handler } of listeners) {\n    document.removeEventListener(eventName, handler);\n  }\n  listeners.length = 0;\n};\n","import { colors } from '@/core/util/color';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\n\nconst linePixels = (x0: number, y0: number, x1: number, y1: number): [number, number][] => {\n  const pixels: [number, number][] = [];\n  let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n  let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n  let err = dx + dy, e2: number;\n\n  for (;;) {\n    pixels.push([x0, y0]);\n    if (x0 === x1 && y0 === y1) break;\n    e2 = 2 * err;\n    if (e2 >= dy) { err += dy; x0 += sx; }\n    if (e2 <= dx) { err += dx; y0 += sy; }\n  }\n  return pixels;\n};\n\nconst pentagramVertices = (cx: number, cy: number, pentagramRotation: number, radius: number): [number, number][] => {\n  const points: [number, number][] = [];\n  for (let i = 0; i < 5; i++) {\n    const angle = (2 * Math.PI * (i * 2 % 5)) / 5 - Math.PI / 2 + pentagramRotation;\n    const x = Math.round(cx + radius * Math.cos(angle));\n    const y = Math.round(cy + radius * Math.sin(angle));\n    points.push([x, y]);\n  }\n  return points;\n};\n\nconst _rotations = [Math.PI / 2, Math.PI, 3 * Math.PI / 2] as const;\n\nexport class PentagramAnimation {\n  cx: number;\n  cy: number;\n  allPixels: [number, number][];\n  totalDuration: number;\n\n  constructor(\n    public ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    public animationDone: () => void,\n    private pentagramRotation: typeof _rotations[number] = Math.PI / 2,\n    private radius: number = 12,\n    private offset = 0,\n    private elapsed = 0,\n    private speed = 300,\n    private trailLength = 16,\n    private cycles = 0,\n    private maxCycles = 1,\n    private active = true,\n  ) {\n    this.cx = x + CELL_WIDTH / 2;\n    this.cy = y + CELL_HEIGHT / 2;\n\n    const points = pentagramVertices(this.cx, this.cy, pentagramRotation, radius);\n\n    this.allPixels = [];\n    for (let i = 0; i < 5; i++) {\n      const [x0, y0] = points[i];\n      const [x1, y1] = points[(i + 1) % 5];\n      this.allPixels.push(...linePixels(x0, y0, x1, y1));\n    }\n    this.totalDuration = this.allPixels.length * this.maxCycles * 1000 / this.speed;\n  }\n\n  update(timeElapsed: number): void {\n    if (!this.active) return;\n\n    const totalPixelsAdvanced = (this.elapsed / 1000) * this.speed;\n    const newOffset = Math.floor(totalPixelsAdvanced) % this.allPixels.length;\n    \n    // Check for cycle completion\n    if (newOffset < this.offset) {\n      this.cycles++;\n      if (this.cycles >= this.maxCycles) {\n        this.active = false;\n        this.animationDone();\n        return;\n      }\n    };\n    \n    this.offset = newOffset;\n    this.elapsed += timeElapsed;\n  }\n\n  draw(): void {\n    if (!this.active) return;\n\n    this.ctx.fillStyle = colors.white;\n    const effectiveTrailLength = Math.min(this.trailLength, this.offset);\n    \n    for (let i = 0; i < effectiveTrailLength; i++) {\n      const idx = (this.offset - i + this.allPixels.length) % this.allPixels.length;\n      const [x, y] = this.allPixels[idx];\n      this.ctx.fillRect(x, y, 1, 1);\n    }\n  }\n\n  isActive(): boolean {\n    return this.active;\n  }\n}\n","export const forEachSurroundingCell = (\n  centerCol: number,\n  centerRow: number,\n  callback: (col: number, row: number) => void,\n  includeCenter: boolean = false\n) => {\n  for (let deltaRow = -1; deltaRow <= 1; deltaRow++) {\n    for (let deltaCol = -1; deltaCol <= 1; deltaCol++) {\n      if (!includeCenter && deltaRow === 0 && deltaCol === 0) continue;\n      callback(centerCol + deltaCol, centerRow + deltaRow);\n    }\n  }\n};\n","\nconst t = (i: number, n: number)=>(n-i)/n;\n\n// Reuse a single AudioContext to avoid memory leaks\nlet audioCtx: AudioContext | null = null;\n\n// Sound player\nexport const playSound = (f: (i: number) => number) => {\n  if (!audioCtx) audioCtx = new AudioContext();\n  const m = audioCtx.createBuffer(1,96e3,48e3);\n  const b = m.getChannelData(0);\n  for(let i = 96e3; i--;) b[i] = f(i);\n  const s = audioCtx.createBufferSource();\n  s.buffer=m;\n  s.connect(audioCtx.destination);\n  s.start();\n};\n\n// Sound\n// export const ooof = (pitch: number) => playSound((i: number) => {\n//   var n=2e4;\n//   if (i > n) return 0;\n//   var q = t(i,n);\n//   return 0.2 * Math.tan(Math.cbrt(Math.sin(i/(145 - 5 * pitch))))*q*q;\n// });\n\n// export const doorSound = () => playSound((i: number) => {\n//   return 0.1 * Math.sin(i/50 + Math.random()*50) * (8000 - i%8000) / 5000 * Math.exp(-i/8000);\n// });\n\nexport const step = (length = 1) => playSound((i: number) => {\n  const n = 2e3 * length;\n  return i > n ? 0 : 0.15 * (Math.random() * 2 - 1) * Math.sin((Math.PI * i) / n);\n});\n\nexport const attack5 = () => playSound((i: number) => {\n  const n = 29e3;\n  if (i > n) return 0;\n  const decay = i > n * 0.6 ? Math.pow(0.9999, i - n * 0.6) : 1;\n  const phase = 5 * Math.sin(5 * Math.round(5 * i / n));\n  return decay * 0.2 * Math.sin(i/(30 - phase) + Math.random()) * (8000 - i%6000) / 5000;\n});\n\nexport const attack = () => playSound((i: number) => {\n  const n = 10e3;\n  if (i > n) return 0;\n  const phase = 5 * Math.sin(5 * Math.round(5 * i / n));\n  return Math.pow(0.998, i / 10) * 0.2 * Math.sin(i/(40 - phase) + Math.random()) * (8000 - i%6000) / 5000;\n});\n\nexport const repair = (pitch: number) => playSound((i: number) => {\n  return Math.sin(i/(21 - pitch) + Math.sin(i/2000)*5) * Math.exp(-i/4000) * (i/96000) * 9;\n});\n\nexport const highRepair = (pitch: number) => playSound((i: number) => {\n  // Musical scale: each pitch step multiplies frequency by 12th root of 2\n  // Lower pitch number = higher frequency (smaller period)\n  const freq = 80 * Math.pow(2, -pitch / 12); // Base frequency decreases with pitch\n  const phase = i * 2 * Math.PI / freq + Math.sin(i/1800) * 4;\n  // Church organ sound with harmonics (fundamental + octave + perfect fifth)\n  const fundamental = Math.sin(phase);\n  const octave = Math.sin(phase * 2) * 0.5;      // One octave up (2x frequency)\n  const fifth = Math.sin(phase * 3) * 0.3;       // Perfect fifth (3x frequency) \n  const octave2 = Math.sin(phase * 4) * 0.2;     // Two octaves up (4x frequency)\n  return (fundamental + octave + fifth + octave2) * Math.exp(-i/6000) * (i/96000) * 6;\n});\n\nexport const hissAndSpit = () => playSound((i: number) => {\n  const n = 10e3;\n  if (i > n) return 0;\n  const q = (n - i) / n;\n  return ((Math.random() * 2 - 1) * Math.sin(i * 0.003) * 0.6 + Math.sin(i / (15 + Math.sin(i / 500) * 8)) * Math.exp(-i / 2000) * 0.4) * q * q * 0.3;\n});\n\nexport const heal = () => playSound((i: number) => {\n  const n = 6e3;\n  if (i > n) return 0;\n  var q = (n - i) / n;\n  return 0.5 * Math.sin(i*0.01*Math.sin(0.007*i+Math.sin(i/1200))+Math.sin(i/800))*q*q;\n});\n\nexport const exorcise = () => {\n  const x = ~(Math.random() * 1000);\n  return playSound((i: number) => {\n    return Math.sin(i/(10 + i/8000 - i/12000) & x + Math.sin(i/2000)*5) * Math.exp(-i/4000) * (i/96000) * 9;\n  });\n};\n","import { CatStates, GameAssets } from '@/game/game-assets';\nimport { GameObject } from '../../core/game-object';\nimport { controls } from '../../core/controls';\nimport { GameMap } from '../game-map';\nimport { CELL_HEIGHT, CELL_WIDTH, statues } from '../constants';\nimport { emit, on } from '@/core/event';\nimport { addTimeEvent } from '@/core/timer';\nimport { Spirit } from './spirit';\nimport { GameData } from '../game-data';\nimport { PentagramAnimation } from './pentagram-attack';\nimport { forEachSurroundingCell } from '../grid-utils';\nimport { drawEngine } from '@/core/draw-engine';\nimport { GameEvent } from '../event-manifest';\nimport { attack, attack5, step } from '@/core/audio';\n\nconst ANIMATION_SLOW = 600;\nconst ANIMATION_NORMAL = 150;\nconst ANIMATION_FAST = 75;\n\nconst STEP_SOUND_TIME = 200;\n\nexport class Player extends GameObject<CatStates> {\n  type = 'cat';\n  sleeping = true;\n  sitting = false;\n  attacking = false;\n  scared = false;\n  inVillage = false;\n  pentagramAttack: PentagramAnimation | null = null;\n  stepSoundTimer = 0;\n  sittingTimer = 0;\n\n  constructor(col: number, row: number, public map: GameMap, public gameData: GameData) {\n    super(\n      GameAssets.cat,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'cat',\n      CatStates.sleep,\n      80,\n    );\n\n    // Initialize looking direction to the right\n    this.map.playerLookingAt = { col: col + 1, row };\n\n    on(GameEvent.TELEPORT, () => {\n      this.setPos(statues.heart.x, statues.heart.y + 1);\n    });\n\n    on(GameEvent.WAKE_UP, () => {\n      this.sleeping = false;\n      this.sitting = true;\n    });\n\n    on(GameEvent.ENABLE_SCRATCH, () => {\n      this.sitting = false;\n    });\n\n    on(GameEvent.ATTACK_PLAYER, () => {\n      this.scared = true;\n      addTimeEvent(() => {\n        this.scared = false;\n      }, 600);\n    });\n\n    on(GameEvent.GAME_OVER, () => {\n      this.animation = CatStates.die;\n      this.animationTime = 0;\n      this.animationLoop = false;\n    });\n  }\n\n  updateAnimation(timeElapsed: number) {\n    super.update(timeElapsed);\n\n    switch(this.animation) {\n      case CatStates.sleep:\n      case CatStates.sit:\n        this.aD = ANIMATION_SLOW;\n        break;\n      case CatStates.scared:\n        this.aD = ANIMATION_FAST;\n        break;\n      default:\n        this.aD = ANIMATION_NORMAL;\n        break;\n    }\n  }\n\n  update(timeElapsed: number) {\n    if (this.animation === CatStates.die) return;\n\n    if (this.animation === CatStates.run) {\n      this.stepSoundTimer -= timeElapsed;\n      if (this.stepSoundTimer <= 0) {\n        step();\n        this.stepSoundTimer = STEP_SOUND_TIME;\n      }\n    } else {\n      this.stepSoundTimer = 0;\n    }\n\n    const cellVillage = this.map.grid[this.row][this.col].village;\n    if (!this.inVillage && cellVillage) {\n      this.inVillage = true;\n      emit(GameEvent.ENTER_VILLAGE, cellVillage);\n    } else if (this.inVillage && !cellVillage) {\n      this.inVillage = false;\n    }\n\n    // DEBUG\n    coords.innerText = `${this.col},${this.row}`;\n\n    if (this.gameData.cutscene) {\n      return;\n    }\n    \n    if(this.scared && !this.isSurrounded()) {\n      this.animation = CatStates.scared;\n    } else if (this.sleeping) {\n      this.animation = CatStates.sleep;\n    } else if (this.sitting) {\n      this.animation = CatStates.sit;\n    } else if (this.attacking) {\n      this.animation = this.pentagramAttack ? CatStates.attack : CatStates.scratch;\n    } else {\n      super.updatePositionSmoothly(timeElapsed);\n\n\n      if (!this.moving.y && controls.inputDirection.y) {\n        const newRow = this.row + controls.inputDirection.y;\n        \n        if (!this.map.grid[newRow][this.col].content) {\n          this.animation = CatStates.run;\n          this.moving.y = controls.inputDirection.y;\n          this.targetPos.y += controls.inputDirection.y * CELL_HEIGHT;\n          this.row = newRow;\n          // Update looking direction after movement to point ahead\n          this.map.playerLookingAt = { col: this.col, row: this.row + controls.inputDirection.y };\n        } else {\n          // Blocked movement - still update looking direction to attempted target\n          this.map.playerLookingAt = { col: this.col, row: this.row + controls.inputDirection.y };\n        }\n      }\n\n      if (!this.moving.x && controls.inputDirection.x) {\n        this.mirrored = controls.isLeft;\n        const newCol = this.col + controls.inputDirection.x;\n        \n        if (!this.map.grid[this.row][newCol].content) {\n          this.animation = CatStates.run;\n          this.moving.x = controls.inputDirection.x;\n          this.targetPos.x += controls.inputDirection.x * CELL_WIDTH;\n          this.col = newCol;\n          // Update looking direction after movement to point ahead  \n          this.map.playerLookingAt = { col: this.col + controls.inputDirection.x, row: this.row };\n        } else {\n          // Blocked movement - still update looking direction to attempted target\n          this.map.playerLookingAt = { col: this.col + controls.inputDirection.x, row: this.row };\n        }\n      }\n\n      if (!this.moving.x && !this.moving.y) {\n        this.animation = CatStates.idle;\n        this.sittingTimer += timeElapsed;\n        if (this.sittingTimer > 2000) {\n          this.animation = CatStates.sit;\n        }\n      } else {\n        this.sittingTimer = 0;\n      }\n\n      // When not attacking, check if playerLookingAt is empty;\n      // If playerLookingAt is empty, look into 4 directions;\n      // If one of the directions is type spirit, set that direction as playerLookingAt;\n      // Else if one of the directions is a statue or obelisk, set that direction as playerLookingAt.\n      if (!this.attacking) {\n        this.autoSelectTarget();\n      }\n\n      if (!this.attacking && controls.isAction1 && !controls.previousState.isAction1) {\n        this.attacking = true;\n        this.animationTime = 0;\n        this.sittingTimer = 0;\n\n        if (!this.pentagramAttack && this.isSurrounded()) {\n          this.pentagramAttack = new PentagramAnimation(\n            drawEngine.ctx1,\n            this.x,\n            this.y,\n            () => {\n              this.pentagramAttack = null;\n              this.attackAllEnemiesAround();\n              this.attacking = false;\n              attack5();\n            },\n          );\n        } else {\n          // Check if there is an enemy right in front\n          addTimeEvent(() => this.attackEnemyInFront(), 500);\n          addTimeEvent(() => {\n            this.attacking = false;\n          }, this.aD * 5);\n        }\n      }\n    }\n    this.pentagramAttack?.update(timeElapsed);\n  }\n\n  // Deals 5 damage to all spirits\n  // in the 9 cells around the cat.\n  attackAllEnemiesAround() {\n    forEachSurroundingCell(this.col, this.row, (col, row) => {\n      const cell = this.map.grid[row][col];\n      if (cell.content?.type === 'spirit') {\n        const spirit = cell.content as Spirit;\n        spirit.takeDamage(5);\n      }\n    });\n  }\n\n  // Returns true if there are 3 or more spirits\n  // in the 9 cells around the cat.\n  isSurrounded() {\n    let spiritCount = 0;\n    forEachSurroundingCell(this.col, this.row, (col, row) => {\n      const cell = this.map.grid[row][col];\n      if (cell.content?.type === 'spirit') {\n        spiritCount++;\n      }\n    });\n    return spiritCount >= 3;\n  }\n\n  draw() {\n    super.draw();\n    this.pentagramAttack?.draw();\n  }\n\n  private autoSelectTarget() {\n    // Check if current looking position is empty\n    const currentCell = this.map.getLookingAt();\n    if (currentCell?.content) {\n      return; // Already looking at something\n    }\n\n    // Check 4 directions around player\n    const directions = [\n      { col: this.col + 1, row: this.row, facing: 'right' },\n      { col: this.col - 1, row: this.row, facing: 'left' },\n      { col: this.col, row: this.row + 1, facing: 'down' },\n      { col: this.col, row: this.row - 1, facing: 'up' },\n    ];\n\n    let spiritTarget = null;\n    let statueTarget = null;\n    let spiritFacing = null;\n    let statueFacing = null;\n\n    for (const dir of directions) {\n      const cell = this.map.grid[dir.row][dir.col];\n      if (!cell.content) continue;\n\n      const contentType = cell.content.type;\n\n      // Prioritize spirits first\n      if (contentType === 'spirit') {\n        spiritTarget = { col: dir.col, row: dir.row };\n        spiritFacing = dir.facing;\n        break; // Spirit has highest priority, stop searching\n      }\n\n      // Store statue/obelisk as backup\n      if ((contentType === 'statue' || contentType === 'obelisk') && !statueTarget) {\n        statueTarget = { col: dir.col, row: dir.row };\n        statueFacing = dir.facing;\n      }\n    }\n\n    // Set target and facing based on priority: spirit > statue/obelisk\n    if (spiritTarget) {\n      this.map.playerLookingAt = spiritTarget;\n      if (spiritFacing === 'left') this.mirrored = true;\n      else if (spiritFacing === 'right') this.mirrored = false;\n      // Optionally handle up/down facing if needed\n    } else if (statueTarget) {\n      this.map.playerLookingAt = statueTarget;\n      if (statueFacing === 'left') this.mirrored = true;\n      else if (statueFacing === 'right') this.mirrored = false;\n      // Optionally handle up/down facing if needed\n    }\n  }\n\n  private attackEnemyInFront() {\n    // Check if there's a spirit at the target position\n    const cell = this.map.getLookingAt();\n    if (cell.content && cell.content.type === 'spirit') {\n      const spirit = cell.content as Spirit;\n      spirit.takeDamage(1);\n      attack();\n    } else if (cell.content && cell.content.type === 'field') {\n      cell.content = null;\n      step(3);\n    }\n  }\n}\n","import { CELL_HEIGHT, CELL_WIDTH } from '@/game/constants';\nimport { Drawable } from '@/game/Drawable';\nimport { drawEngine } from './draw-engine';\n\nexport class GameStaticObject implements Drawable {\n  public col: number;\n  public row: number;\n  public offsetX: number;\n  public offsetY: number;\n\n  constructor(\n    public img: HTMLImageElement,\n    public x: number,\n    public y: number,\n    public type: string,\n  ) {\n    this.col = Math.ceil(x / CELL_WIDTH);\n    this.row = Math.ceil(y / CELL_HEIGHT);\n    this.offsetX = x - Math.round((img.width - CELL_WIDTH) / 2);\n    this.offsetY = y - Math.round((img.height - CELL_HEIGHT) / 2);\n  }\n\n  draw() {\n    drawEngine.drawBackgroundImage(this.img, this.offsetX, this.offsetY);\n  }\n}\n","import { GameAssets } from '@/game/game-assets';\nimport { drawEngine } from '@/core/draw-engine';\nimport { CELL_WIDTH, CELL_HEIGHT } from '@/game/constants';\nimport { GameStaticObject } from '@/core/game-static-object';\n\nexport class Tree extends GameStaticObject {\n  private neighbors: { top: boolean; bottom: boolean; left: boolean; right: boolean } = {\n    top: false,\n    bottom: false,\n    left: false,\n    right: false,\n  };\n\n  constructor(\n    public x: number,\n    public y: number,\n    treeType: 'oak' | 'spruce',\n  ) {\n    super(\n      GameAssets[treeType],\n      x,\n      y,\n      treeType,\n    );\n  }\n\n  setNeighbors(neighbors: { top: boolean; bottom: boolean; left: boolean; right: boolean }) {\n    this.neighbors = neighbors;\n  }\n\n  draw() {\n    if (this.neighbors.right) {\n      drawEngine.drawBackgroundImage(this.img, Math.round(this.offsetX + CELL_WIDTH / 2), this.offsetY - CELL_HEIGHT / 2);\n    }\n    super.draw();\n  }\n}\n","// Seeded \"random\" number generator for deterministic randomness\nexport class SeededRandom {\n  constructor(public rngSeed: number = 47) {}\n  \n  next(): number {\n    this.rngSeed = (this.rngSeed * 9301 + 49297) % 233280;\n    return this.rngSeed / 233280;\n  }\n  \n  range(min: number, max: number): number {\n    return min + this.next() * (max - min);\n  }\n}\n","import { GameAssets } from '../game-assets';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { GameStaticObject } from '@/core/game-static-object';\n\nexport class House extends GameStaticObject {\n  name;\n\n  constructor(col: number, row: number, name = '') {\n    super(\n      GameAssets.house,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'house',\n    );\n    this.name = name;\n  }\n}\n","import { GameObject } from '@/core/game-object';\nimport { GameAssets, VillagerStates } from '../game-assets';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { GameMap } from '../game-map';\nimport { emit } from '@/core/event';\nimport { GameEvent } from '../event-manifest';\n\nexport class Villager extends GameObject<VillagerStates> {\n  lastDirection: { x: number; y: number } | null = null;\n  moveTimer: number = 0;\n  moveInterval: number = 1000;\n  isScared = false;\n\n  constructor(col: number, row: number, private map: GameMap) {\n    super(\n      GameAssets.villager,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'villager',\n      VillagerStates.walk,\n      10,\n    );\n  }\n\n  update(timeElapsed: number): void {\n    super.update(timeElapsed);\n\n    this.moveTimer += timeElapsed;\n    if (this.seesCat()) {\n      if (!this.isScared && this.moveTimer >= this.moveInterval) {\n        this.moveTimer = 0;\n        this.isScared = true;\n      }\n      if (this.moveTimer % (this.moveInterval / 5) < timeElapsed) {\n        emit(GameEvent.SCARED);\n      }\n      this.animation = VillagerStates.scared;\n      this.aD = 50;\n    } else {\n      this.isScared = false;\n      this.aD = 150;\n      if (this.moveTimer >= this.moveInterval) {\n        this.takeNextStep();\n        this.moveTimer = 0;\n      }\n      this.updatePositionSmoothly(timeElapsed);\n    }\n  }\n\n  // Looks around for an empty cell to move to.\n  // Has 50% chance of moving forward in the same direction as before.\n  // Otherwise moves in a random direction, if that direction is free. \n  takeNextStep(): void {\n    const directions = [\n      { x: 0, y: -1 },\n      { x: 0, y: 1 }, \n      { x: 1, y: 0 },\n      { x: -1, y: 0 }\n    ];\n\n    // 80% chance to continue in same direction\n    if (this.lastDirection && Math.random() < 0.8) {\n      const newCol = this.col + this.lastDirection.x;\n      const newRow = this.row + this.lastDirection.y;\n      if (this.isValidMove(newCol, newRow)) {\n        this.col = newCol;\n        this.row = newRow;\n        this.targetPos = { x: newCol * CELL_WIDTH, y: newRow * CELL_HEIGHT };\n        this.lastDirection = this.lastDirection;\n        this.animation = VillagerStates.walk;\n        return;\n      }\n    }\n\n    // Try random directions without shuffling\n    for (let i = 0; i < 10; i++) {\n      const dir = directions[Math.floor(Math.random() * 4)];\n      const newCol = this.col + dir.x;\n      const newRow = this.row + dir.y;\n      if (this.isValidMove(newCol, newRow)) {\n        this.col = newCol;\n        this.row = newRow;\n        this.targetPos = { x: newCol * CELL_WIDTH, y: newRow * CELL_HEIGHT };\n        this.lastDirection = dir;\n        this.animation = VillagerStates.walk;\n        return;\n      }\n    }\n  }\n\n  private isValidMove(col: number, row: number): boolean {\n    // Check if cell is empty\n    const cell = this.map.grid[row][col];\n    return cell.content === null;\n  }\n\n  /**\n   * Checks 2 cells in front in the movement direction for a cat.\n   */\n  seesCat(): boolean {\n    if (!this.lastDirection) return false;\n\n    for (let i = 1; i <= 2; i++) {\n      const checkCol = this.col + this.lastDirection.x * i;\n      const checkRow = this.row + this.lastDirection.y * i;\n      \n      const cell = this.map.grid[checkRow]?.[checkCol];\n      if (cell?.content?.type === 'cat') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n","import { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { GameStaticObject } from '@/core/game-static-object';\nimport { GameAssets } from '../game-assets';\n\nexport class Farm extends GameStaticObject {\n  constructor(col: number, row: number) {\n    super(\n      GameAssets.grass,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'field',\n    );\n  }\n}\n","import { SeededRandom } from '@/core/util/rng';\nimport { House } from './house';\nimport { GameMap } from '../game-map';\nimport { Villager } from './villager';\nimport { Farm } from './farm';\n\nexport class Village {\n  houses: House[] = [];\n  farms: Farm[] = [];\n  villagers: Villager[] = [];\n\n  constructor(\n    public name: string,\n    public center: { x: number; y: number },\n    public radius: number,\n    public houseCount: number,\n    public population: number,\n  ) {\n    this.center = center;\n    this.radius = radius;\n  }\n\n  private generatePosition(rng: SeededRandom, existing: { x: number; y: number }[], map: GameMap): { x: number; y: number } {\n    let col: number;\n    let row: number;\n    do {\n      const angle = rng.range(0, Math.PI * 2);\n      const distance = rng.range(1, this.radius - 1);\n      col = Math.round(this.center.x + Math.cos(angle) * distance);\n      row = Math.round(this.center.y + Math.sin(angle) * distance);\n    } while (\n      col < 0 ||\n      row < 0 ||\n      map.get(col, row)?.content !== null ||\n      existing.some(item => item.x === col && item.y === row)\n    );\n    return { x: col, y: row };\n  }\n\n  generateHouses(rng: SeededRandom, map: GameMap): House[] {\n    for (let i = 0; i < this.houseCount; i++) {\n      const pos = this.generatePosition(rng, this.houses, map);\n      const houseCol = pos.x + pos.x % 2;\n      const houseRow = pos.y + pos.y % 2;\n      this.houses.push(new House(houseCol, houseRow));\n    }\n    return this.houses;\n  }\n\n  generateFarms(rng: SeededRandom, map: GameMap): Farm[] {\n    const farmCount = this.houseCount;\n    for (let i = 0; i < farmCount; i++) {\n      const pos = this.generatePosition(rng, this.farms, map);\n      \n      // Create a 2x2 farm block\n      for (let dx = 0; dx < 2; dx++) {\n        for (let dy = 0; dy < 2; dy++) {\n          this.farms.push(new Farm(pos.x + dx, pos.y + dy));\n        }\n      }\n    }\n    return this.farms;\n  }\n\n  generateVillagers(rng: SeededRandom, map: GameMap): Villager[] {\n    for (let i = 0; i < this.population; i++) {\n      const pos = this.generatePosition(rng, this.farms, map);\n      this.villagers.push(new Villager(pos.x, pos.y, map));\n    }\n    return this.villagers;\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\n\nexport class Icon {\n  x: number;\n  y: number;\n\n  constructor(\n    public readonly icon: HTMLImageElement,\n    public col: number,\n    public row: number,\n    public type: string,\n  ) {\n    this.x = Math.round(this.col * CELL_WIDTH + (CELL_WIDTH - this.icon.width) / 2);\n    this.y = Math.round(this.row * CELL_HEIGHT + (CELL_HEIGHT - this.icon.height) / 2);\n  }\n\n  draw() {\n    drawEngine.drawBackgroundImage(this.icon, this.x, this.y);\n  }\n}\n","import { Cell } from './types';\n\nexport interface Coords {\n  col: number;\n  row: number;\n}\n\nexport interface Position {\n  x: number;\n  y: number;\n}\n\nexport interface PathNode {\n  pos: Position;\n  distance: number;\n  previous?: PathNode;\n}\n\n// Directions: north, south, east, west\nconst directions: ReadonlyArray<Readonly<{ x: number; y: number }>> = [\n  { x: 0, y: -1 }, // north\n  { x: 0, y: 1 },  // south\n  { x: 1, y: 0 },  // east\n  { x: -1, y: 0 }  // west\n] as const;\n\n/**\n * Breadth-first search to find the nearest cell that matches a condition\n * @param grid - 2D array representing the game map\n * @param start - Starting position {x, y}\n * @param matchCondition - Function that returns true if the cell satisfies the condition\n * @param maxSteps - Maximum number of steps to search\n * @returns The position of the matching cell, or null if not found\n */\nexport function findNearestMatch<T>(\n  grid: T[][],\n  start: Position,\n  matchCondition: (cell: T, x: number, y: number) => boolean,\n  maxSteps: number\n): Position | null {\n  const rowCount = grid.length;\n  const colCount = grid[0]?.length || 0;\n\n  if (colCount === 0 || rowCount === 0) return null;\n\n  // Check if starting position matches\n  if (matchCondition(grid[start.y][start.x], start.x, start.y)) {\n    return start;\n  }\n\n  const visited = new Set<string>();\n  const queue: PathNode[] = [{ pos: start, distance: 0 }];\n  visited.add(`${start.x},${start.y}`);\n\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n\n    // Check all 4 directions\n    for (const dir of directions) {\n      const newX = current.pos.x + dir.x;\n      const newY = current.pos.y + dir.y;\n      const newDistance = current.distance + 1;\n\n      // Check max steps only\n      if (newDistance > maxSteps) {\n        continue;\n      }\n\n      const key = `${newX},${newY}`;\n      if (visited.has(key)) {\n        continue;\n      }\n\n      visited.add(key);\n\n      // Check if this cell matches our condition\n      if (matchCondition(grid[newY][newX], newX, newY)) {\n        return { x: newX, y: newY };\n      }\n\n      // Add to queue for further exploration\n      queue.push({\n        pos: { x: newX, y: newY },\n        distance: newDistance,\n        previous: current\n      });\n    }\n  }\n\n  return null; // No matching cell found within maxSteps\n}\n\nconst toKey = (col: number, row: number) => {\n  return `${col},${row}`;\n};\n\n// const fromKey = (key): Coords => {\n//   const [col ,row] = key.split(',').map(Number);\n//   return { col, row };\n// };\n\nconst reconstructPath = (parents: Record<string, Coords>, start: Coords, goal: Coords) => {\n  const path: Coords[] = [];\n  let current = goal;\n  while (current != start) {\n    path.unshift(current);\n    current = parents[toKey(current.col, current.row)];\n  }\n  path.unshift(start);\n  return path;\n};\n\n/**\n * Uses breadth-first-search to find the shortest path from\n * start to goal, and returns the path as an array of coords.\n * The path will take at most maxSteps steps.\n * This algo assumes that the map is fully enclosed by a boundary\n * so it is not checking whether the coordinates are valid.\n */\nexport const findShortestPath = (\n  grid: Cell[][],\n  start: Coords,\n  goal: Coords,\n  maxSteps = 100,\n) => {\n  let steps = maxSteps;\n\n  // Start from person A’s position.\n  // Keep a queue of cells to explore.\n  const queue: Coords[] = [start];\n\n  // Keep a record of which cells you’ve already visited, so you don’t loop back.\n  const visited = new Set();\n\n  // Keep a map of coords->cells that keeps track of the paths taken\n  const parents: Record<string, Coords> = {};\n\n  while (queue.length !== 0 && steps--) {\n    // Get the oldest cell from the queue\n    const current = queue.shift() as Coords;\n    if (current.col === goal.col && current.row === goal.row) {\n      return reconstructPath(parents, start, goal);\n    }\n\n    // Check the 4 immediate neighbours\n    const neighbours = directions.map(({x, y}) => grid[current.row + y][current.col + x]);\n    neighbours.forEach((neighbour) => {\n      if (!visited.has(neighbour)) {\n        visited.add(neighbour);\n        if (neighbour.content === null || (neighbour.x == goal.col && neighbour.y == goal.row)) {\n          parents[toKey(neighbour.x, neighbour.y)] = current;\n          queue.push({ col: neighbour.x, row: neighbour.y });\n        }\n      }\n    });\n  }\n};\n\n","import { drawEngine } from '@/core/draw-engine';\nimport { colors } from '@/core/util/color';\nimport { CELL_WIDTH } from '../constants';\n\nconst defaultColors: [string, string, string, string] = [colors.blue1, colors.blue2, colors.purple5, colors.purple4];\n\nexport const drawHpBar = (\n  hp: number,\n  maxHp: number,\n  x: number,\n  y: number,\n  colorHP = defaultColors,\n) => {\n  const hpRatio = Math.max(0, Math.min(1, hp / maxHp));\n  const barWidth = CELL_WIDTH;\n  const barHeight = 1;\n  const hpWidth = Math.ceil(barWidth * hpRatio);\n  const barX = x;\n  const barY = y - 5;\n\n  drawEngine.ctx1.fillStyle = colorHP[0];\n  drawEngine.ctx1.fillRect(barX, barY, hpWidth, barHeight);\n  drawEngine.ctx1.fillStyle = colorHP[1];\n  drawEngine.ctx1.fillRect(barX, barY + 1, hpWidth, barHeight);\n\n  drawEngine.ctx1.fillStyle = colorHP[2];\n  drawEngine.ctx1.fillRect(\n    barX + hpWidth,\n    barY,\n    barWidth - hpWidth,\n    barHeight,\n  );\n  drawEngine.ctx1.fillStyle = colorHP[3];\n  drawEngine.ctx1.fillRect(\n    barX + hpWidth,\n    barY +\n    1,\n    barWidth - hpWidth, barHeight,\n  );\n};\n","import { emojiToPixelArt } from '@/core/emoji';\nimport { Icon } from './icon';\nimport { drawEngine } from '@/core/draw-engine';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { GameMap } from '../game-map';\nimport { updatePositionSmoothly, SmoothMovementState, setTargetPosition } from '@/utils/smooth-movement';\nimport { Coords, findShortestPath } from '../path-findind';\nimport { addTimeEvent } from '@/core/timer';\nimport { emit, on } from '@/core/event';\nimport { drawHpBar } from './hp-bar';\nimport { GameEvent } from '../event-manifest';\nimport { exorcise } from '@/core/audio';\n\nexport type SpiritType = '☁️' | '👻' | '👹' | '🧿' | '🦀' | '🌵' | '🥨' | '🧚🏻‍♀️' | '💀';\n\ninterface SpiritSpecies {\n  type: SpiritType,\n  icon: HTMLImageElement,\n  level: number,\n}\n\nexport const spirits = ([\n  '☁️', '🥨', '🌵', '🧚🏻‍♀️', '🦀', '👻', '👹', '🧿', '💀'\n] as const).reduce<Record<SpiritType, SpiritSpecies>>((acc, type, index) => {\n  acc[type] = { icon: emojiToPixelArt(type), type, level: Math.ceil((index) / 2) };\n  return acc;\n}, {} as Record<SpiritType, SpiritSpecies>);\n\nconst enum SpiritState {\n  DYING,\n  IDLE,\n  MOVING,\n  WINDING,\n  ATTACKING,\n  RESTING\n}\n\nexport class Spirit extends Icon implements SmoothMovementState {\n\n  aD = 2000;\n  animationTime = 0;\n  opacity = 0;\n  species: SpiritSpecies;\n  map: GameMap;\n  searchRadius = 9;\n  moveTimer = 0;\n  moveInterval = 600;\n  targetPos: { x: number; y: number };\n  moving = { x: 0, y: 0 };\n  speed = 20;\n  maxHp: number;\n  hp: number;\n  dead = false;\n  recoil = false;\n  \n  // Simplified state system\n  state: number = SpiritState.IDLE;\n  attackTimer = 0;\n  attackDuration = 1000;\n  attackTarget: Coords | null = null;\n  attackOffsetX = 0;\n  attackOffsetY = 0;\n\n  constructor(\n    col: number,\n    row: number,\n    type: SpiritType,\n    map: GameMap,\n  ) {\n    super(spirits[type].icon, col, row, 'spirit');\n    this.species = spirits[type];\n    this.map = map;\n    this.targetPos = { x: this.x, y: this.y };\n    this.maxHp = Math.round(Math.pow(1.5, this.species.level + 1));\n    this.hp = this.maxHp;\n\n    on(GameEvent.END_SEQUECE_START, () => {\n      this.state = SpiritState.DYING;\n    });\n  }\n\n  updateAnimation(timeElapsed: number) {\n    if (this.hp <= 0) {\n      this.opacity -= timeElapsed / this.aD;\n    };\n\n    this.animationTime += timeElapsed * Math.pow(this.species.level + 0.5, 2);\n    if (this.opacity < 1) {\n      this.opacity += timeElapsed / this.aD;\n    }\n    if (this.animationTime >= this.aD) {\n      this.animationTime -= this.aD;\n    }\n  }\n\n  update(timeElapsed: number) {\n    switch (this.state) {\n      case SpiritState.DYING:\n        break;\n      case SpiritState.IDLE:\n      case SpiritState.MOVING:\n        updatePositionSmoothly(this, timeElapsed);\n        const playerCoords = this.lookAroundForPlayer();\n        if (playerCoords) {\n          this.moveTimer += timeElapsed;\n          if (this.moveTimer >= this.moveInterval) {\n            this.moveTowardsPlayer(playerCoords);\n            this.moveTimer = 0;\n          }\n        }\n        break;\n\n      case SpiritState.WINDING:\n      case SpiritState.ATTACKING:\n      case SpiritState.RESTING:\n        this.updateAttack(timeElapsed);\n        break;\n    }\n  }\n\n  private updateAttack(timeElapsed: number) {\n    this.attackTimer += timeElapsed;\n    const progress = this.attackTimer / this.attackDuration;\n    \n    if (!this.attackTarget) {\n      this.state = SpiritState.IDLE;\n      return;\n    }\n\n    const dirX = this.attackTarget.col - this.col;\n    const dirY = this.attackTarget.row - this.row;\n\n    if (progress < 0.7) {\n      // Winding up\n      if (this.state !== SpiritState.WINDING) this.state = SpiritState.WINDING;\n      const windProgress = progress / 0.7;\n      this.attackOffsetX = -dirX * windProgress * 3;\n      this.attackOffsetY = -dirY * windProgress * 3;\n    } else if (progress < 0.73) {\n      // Attacking\n      if (this.state !== SpiritState.ATTACKING) this.state = SpiritState.ATTACKING;\n      const attackProgress = (progress - 0.7) / 0.03;\n      this.attackOffsetX = dirX * (-3 + CELL_WIDTH * attackProgress);\n      this.attackOffsetY = dirY * (-3 + CELL_WIDTH * attackProgress);\n    } else if (progress < 1.0) {\n      // Resting (returning)\n      if (this.state !== SpiritState.RESTING) {\n        this.state = SpiritState.RESTING;\n        \n        // Only emit if player is still in the target cell\n        const cell = this.map.grid[this.attackTarget.row][this.attackTarget.col];\n        if (cell.content?.type === 'cat') {\n          emit(GameEvent.ATTACK_PLAYER, this.species.level);\n        }\n      }\n      const restProgress = (progress - 0.73) / 0.27;\n      this.attackOffsetX = dirX * 3 * (1 - restProgress);\n      this.attackOffsetY = dirY * 3 * (1 - restProgress);\n    } else {\n      // Attack complete\n      this.state = SpiritState.IDLE;\n      this.attackTimer = 0;\n      this.attackTarget = null;\n      this.attackOffsetX = 0;\n      this.attackOffsetY = 0;\n    }\n  }\n\n  private lookAroundForPlayer(): Coords | null {\n    // Search in a box around the spirit using the search radius\n    for (let dx = -this.searchRadius; dx <= this.searchRadius; dx++) {\n      for (let dy = -this.searchRadius; dy <= this.searchRadius; dy++) {\n        const searchCol = this.col + dx;\n        const searchRow = this.row + dy;\n\n        const cell = this.map.grid[searchRow][searchCol];\n        if (cell.content?.type === 'cat') {\n          return { col: searchCol, row: searchRow };\n        }\n      }\n    }\n    \n    return null;\n  }\n\n  private moveTowardsPlayer(playerCoords: Coords) {\n    const path = findShortestPath(\n      this.map.grid,\n      { col: this.col, row: this.row },\n      playerCoords,\n    );\n    if (path && path.length > 2) {\n      this.state = SpiritState.MOVING;\n      const nextStep = path[1];\n      setTargetPosition(this, nextStep.col, nextStep.row);\n      this.col = nextStep.col;\n      this.row = nextStep.row;\n      this.targetPos.x = nextStep.col * CELL_WIDTH;\n      this.targetPos.y = nextStep.row * CELL_HEIGHT;\n    } else if (path?.length === 2) {\n      // Start attack\n      this.state = SpiritState.WINDING;\n      this.attackTarget = path[1];\n      this.attackTimer = 0;\n    }\n  }\n\n  draw() {\n    const phase = Math.sin((this.animationTime / this.aD) * 2 * Math.PI);\n    drawEngine.ctx1.save();\n    drawEngine.ctx1.globalAlpha = this.opacity;\n\n    // Shadow\n    const shadow = Math.round(2 + 1 * phase) / 10;\n    drawEngine.ctx1.fillStyle = `rgba(0,0,0,${shadow})`;\n    drawEngine.ctx1.fillRect(\n      this.x + 3 + this.attackOffsetX,\n      this.y + CELL_HEIGHT * 3 / 4 + this.attackOffsetY,\n      this.icon.width - 6,\n      CELL_HEIGHT / 4 + 1,\n    );\n\n    if (this.hp < this.maxHp) {\n      drawHpBar(this.hp, this.maxHp, this.x, this.y);\n    }\n\n    // Icon\n    drawEngine.ctx1.save();\n    if (this.recoil) {\n      drawEngine.ctx1.filter = 'sepia(1) saturate(2) hue-rotate(260deg) brightness(0.7)';\n    }\n    drawEngine.ctx1.translate(\n      this.attackOffsetX,\n      this.attackOffsetY + Math.round(\n        (phase - 1) * 2\n      )\n    );\n    super.draw();\n    drawEngine.ctx1.restore();\n    drawEngine.ctx1.restore();\n  }\n\n  takeDamage(damage: number = 1): boolean {\n    this.hp -= damage;\n    this.recoil = true;\n    addTimeEvent(() => {\n      this.recoil = false;\n    }, 150);\n    if (this.hp <= 0) {\n      addTimeEvent(() => {\n        exorcise();\n        this.dead = true;\n      }, 1500);\n    }\n    return this.hp <= 0;\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { colors } from '@/core/util/color';\n\nexport class MagicCircleAnimation {\n  animationTimer = 0;\n  static animationDuration = 1500;\n  progress = 0;\n  cx: number;\n  cy: number;\n  isDone = false;\n\n  constructor(\n    private x: number,\n    private y: number,\n  ) {\n    this.cx = this.x + CELL_WIDTH / 2;\n    this.cy = this.y + CELL_HEIGHT / 2;\n  }\n\n  update(timeElapsed: number) {\n    this.animationTimer += timeElapsed;\n    this.progress = this.animationTimer / MagicCircleAnimation.animationDuration;\n\n    if (this.progress >= 1) {\n      this.isDone = true;\n    }\n  }\n\n  draw() {\n    if (this.isDone) return;\n\n    const animationProgress = (3 * this.progress) % 1;\n    \n    const maxWidth = c2.width / drawEngine.zoom;\n    const maxHeight = c2.height / drawEngine.zoom;\n    const rx = maxWidth * animationProgress;\n    const ry = maxHeight * animationProgress;\n    drawEngine.drawCircumference(\n      drawEngine.ctx1,\n      this.cx,\n      this.cy,\n      rx,\n      ry,\n      colors.white,\n      8,\n    );\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { GameAssets } from '../game-assets';\nimport { CELL_HEIGHT, CELL_WIDTH, MAX_REPAIR } from '../constants';\nimport { Spirit, spirits } from './spirit';\nimport { GameMap } from '../game-map';\nimport { GameData } from '../game-data';\nimport { drawHpBar } from './hp-bar';\nimport { colors } from '@/core/util/color';\nimport { drawEngine } from '@/core/draw-engine';\nimport { GameStaticObject } from '@/core/game-static-object';\nimport { MagicCircleAnimation } from './magic-animation';\nimport { addTimeEvent } from '@/core/timer';\n\nexport class Statue extends GameStaticObject {\n  static readonly State = {\n    BROKEN: 0,\n    ANIMATING: 1,\n    REPAIRED: 2\n  } as const;\n\n  spirits: Spirit[] = [];\n  maxSpirits = 4;\n  spawnTimer = 0;\n  spawnInterval = 1000;\n  spawnChance = 0.10;\n  spawnRadius = 10;\n  repair = 0;\n  state: number = Statue.State.BROKEN;\n  animationTime = 0;\n  spiritsExorcised = false;\n  lastClearTime = 0;\n\n  magicCircleAnimation: MagicCircleAnimation | null = null;\n\n  /**\n   * Animation duration\n   */\n  aD = 800;\n\n  constructor(\n    col: number,\n    row: number,\n    public map: GameMap,\n    public gameData: GameData,\n    public name: string,\n  ) {\n    super(\n      GameAssets.statue,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'statue',\n    );\n  }\n\n  updateAnimation(timeElapsed: number) {\n    this.animationTime += timeElapsed;\n  }\n\n  update(timeElapsed: number) {\n    this.spawnTimer += timeElapsed;\n\n    if (this.state === Statue.State.BROKEN && this.repair >= MAX_REPAIR) {\n      this.state = Statue.State.ANIMATING;\n      this.spiritsExorcised = false; // Reset flag when starting animation\n      this.lastClearTime = 0; // Reset clear timer\n      this.magicCircleAnimation = new MagicCircleAnimation(this.x, this.y);\n    } else if (this.magicCircleAnimation) {\n      this.magicCircleAnimation.update(timeElapsed);\n      if (this.magicCircleAnimation.isDone) {\n        this.state = Statue.State.REPAIRED;\n        this.magicCircleAnimation = null;\n      }\n    }\n    \n    if (this.spawnTimer >= this.spawnInterval) {\n      this.spawnTimer = 0;\n\n      if (Math.random() < this.spawnChance) {\n        if (this.spirits.length < (this.maxSpirits + this.gameData.getLevel())) {\n          // Spawn new spirit\n          this.spawnSpirit();\n        } else if (this.spirits.length > 0) {\n          // Replace spirits with full HP\n          const replaceSpirit = this.spirits\n            .filter((spirit) => spirit.hp === spirit.maxHp)\n            [Math.round(Math.random() * this.spirits.length - 1)];\n          if (replaceSpirit) {\n            replaceSpirit.dead = true;\n            this.spawnSpirit();\n          }\n        }\n      }\n    }\n\n    this.spirits = this.spirits.filter(spirit => !spirit.dead);\n  }\n\n  draw() {\n    super.draw();\n    if (this.repair > 0 && this.repair < MAX_REPAIR) {\n      drawHpBar(this.repair, MAX_REPAIR, this.x, this.y, [colors.yellow1, colors.yellow2, colors.blue5, colors.blue6]);\n    }\n    if (this.state === Statue.State.REPAIRED) {\n      this.drawFaries();\n    }\n  }\n\n  postDraw() {\n    if (this.magicCircleAnimation) {\n      this.magicCircleAnimation.draw();\n    \n      if (this.magicCircleAnimation.animationTimer - this.lastClearTime >= 20) {\n        const progress = this.magicCircleAnimation.progress;\n        this.map.clearCircleWithJitter(this.col, this.row, 20 * progress, true, 2, 0.3);\n        this.lastClearTime = this.magicCircleAnimation.animationTimer;\n      }\n      \n      // Only exorcise spirits once at the beginning of the animation\n      if (!this.spiritsExorcised) {\n        this.spirits.forEach((spirit, i) => {\n          addTimeEvent(() => {\n            spirit.takeDamage(spirit.hp);\n          }, i * 100);\n        });\n        this.spiritsExorcised = true;\n      }\n    }\n  }\n\n  drawFaries() {\n    const radius = 3;\n    drawEngine.ctx1.fillStyle = colors.purple0;\n    \n    for (let i = 0; i < 5; i++) {\n      const t = (this.animationTime + this.aD * 0.5 * i) / this.aD;\n      const theta = (i * 2 * Math.PI) / 3; // 0, 120°, 240°\n      // Offset distance from statue center\n      const offsetDist = 3; // adjust as needed\n      const offsetX = Math.cos(theta) * offsetDist;\n      const offsetY = Math.sin(theta) * offsetDist;\n\n      // Infinity path at t, rotated by theta\n      const x0 = radius * 2 * Math.sin(t);\n      const y0 = radius * Math.sin(2 * t);\n      const x = x0 * Math.cos(theta) - y0 * Math.sin(theta);\n      const y = x0 * Math.sin(theta) + y0 * Math.cos(theta);\n\n      // Final position: statue center + offset + rotated path\n      const px = Math.round(this.x + CELL_WIDTH / 2 + offsetX + x);\n      const py = Math.round(this.y + CELL_HEIGHT / 3 + offsetY + y);\n\n      drawEngine.ctx1.fillRect(px, py, 1, 1);\n    }\n  }\n\n  private spawnSpirit() {\n    // Find a random empty cell within a 20x20 area around the statue\n    const emptyCells: { x: number; y: number }[] = [];\n    const spawnRadius = Math.round(this.gameData.getLevel() + this.spawnRadius);\n    \n    // Collect all empty cells within the search radius\n    for (let dx = -spawnRadius; dx <= spawnRadius; dx++) {\n      for (let dy = -spawnRadius; dy <= spawnRadius; dy++) {\n        const x = this.col + dx;\n        const y = this.row + dy;\n        \n        // Check if cell is empty\n        if (this.map.grid[y][x].content === null) {\n          emptyCells.push({ x, y });\n        }\n      }\n    }\n\n    // Select a random empty cell\n    if (emptyCells.length > 0) {\n      const randomIndex = Math.floor(Math.random() * emptyCells.length);\n      const selectedPosition = emptyCells[randomIndex];\n      \n      // TODO: only spawn spirits of the appropriate level for the current game\n      const spiritTypes = Object.values(spirits)\n        .filter((spirit) => spirit.level < this.gameData.getLevel());\n      if (spiritTypes.length === 0) return;\n\n      const randomType = spiritTypes[Math.floor(Math.random() * spiritTypes.length)];\n      \n      const spirit = new Spirit(selectedPosition.x, selectedPosition.y, randomType.type, this.map);\n      this.spirits.push(spirit);\n      \n      // Place the spirit directly in the map\n      this.map.set(selectedPosition.x, selectedPosition.y, spirit);\n    }\n  }\n}\n","import { GameAssets } from '../game-assets';\nimport { CELL_HEIGHT, CELL_WIDTH, MAX_REPAIR } from '../constants';\nimport { GameMap } from '../game-map';\nimport { drawHpBar } from './hp-bar';\nimport { colors } from '@/core/util/color';\nimport { emit } from '@/core/event';\nimport { GameEvent } from '../event-manifest';\nimport { GameStaticObject } from '@/core/game-static-object';\nimport { repair } from '@/core/audio';\nimport { MagicCircleAnimation } from './magic-animation';\n\nexport class Obelisk extends GameStaticObject {\n  map: GameMap;\n  name = 'barrier obelisk';\n  repair = 0;\n  magicCircleAnimation: MagicCircleAnimation | null = null;\n  \n  constructor(map: GameMap) {\n    const col = 69;\n    const row = 88; \n    super(\n      GameAssets.obelisk,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'obelisk',\n    );\n    this.map = map;\n    this.map.set(this.col, this.row, this);\n  }\n\n  update(timeElapsed: number) {\n    this.magicCircleAnimation?.update(timeElapsed);\n  }\n\n  startAnimation () {\n    this.magicCircleAnimation = new MagicCircleAnimation(this.x, this.y);\n  }\n\n  draw() {\n    super.draw();\n    if (this.repair > 0) {\n      drawHpBar(this.repair, MAX_REPAIR, this.x, this.y, [colors.yellow1, colors.yellow2, colors.blue5, colors.blue6]);\n    }\n  }\n\n  postDraw() {\n    this.magicCircleAnimation?.draw();\n  }\n\n  attemptRepair() {\n    const maxProgress = 1; //this.map.gameData.magic / MAX_MAGIC;\n    const maxRepair = MAX_REPAIR * maxProgress;\n    if (this.repair < maxRepair) {\n      this.repair ++;\n      repair(2 * this.repair - 10);\n    } else {\n      repair(-10);\n      emit(GameEvent.NOT_ENOUGH_MAGIC);\n    }\n\n    if (this.repair === MAX_REPAIR) {\n      emit(GameEvent.END_SEQUECE_START);\n    }\n  }\n}\n","import { Tree } from './entities/tree';\nimport { SeededRandom } from '@/core/util/rng';\nimport { Village } from './entities/village';\nimport { CELL_HEIGHT, CELL_WIDTH, clearings, paths, statues } from './constants';\nimport { Statue } from './entities/statue';\nimport { Cell, Path } from './types';\nimport { Drawable } from './Drawable';\nimport { on } from '@/core/event';\nimport { Spirit } from './entities/spirit';\nimport { Coords } from './path-findind';\nimport { drawEngine } from '@/core/draw-engine';\nimport { GameAssets } from './game-assets';\nimport { GameData } from './game-data';\nimport { GameEvent } from './event-manifest';\nimport { Farm } from './entities/farm';\nimport { forEachSurroundingCell } from './grid-utils';\nimport { House } from './entities/house';\nimport { Obelisk } from './entities/obelisk';\n\nexport class GameMap {\n  grid: Cell[][];\n  villages: Village[] = [];\n  private rng: SeededRandom;\n  playerLookingAt: Coords = { col: 0, row: 0 };\n  statues: Statue[] = [];\n  obelisk: Obelisk;\n\n  constructor(\n    public readonly colCount: number,\n    public readonly rowCount: number,\n    public gameData: GameData,\n  ) {\n    this.rng = new SeededRandom();\n\n    this.grid = Array.from({ length: rowCount }, (_a, y) =>\n      Array.from({ length: colCount }, (_b, x) => {\n        // Determine tree species based on distance from Heart Peak (70, 90)\n        const dx = x - 70;\n        const dy = y - 90;\n        const distanceFromHeartPeak = Math.sqrt(dx * dx + dy * dy);\n        \n        let treeType: 'oak' | 'spruce';\n        if (distanceFromHeartPeak <= 40) {\n          // Within 20 cell radius of Heart Peak: 90% spruce, 10% oak\n          treeType = this.rng.next() < 0.9 ? 'spruce' : 'oak';\n        } else {\n          // Rest of map: 20% spruce, 80% oak\n          treeType = this.rng.next() < 0.2 ? 'spruce' : 'oak';\n        }\n        \n        const tree = new Tree(\n          x * CELL_WIDTH - (16 - CELL_WIDTH) / 2, // Adjust x to center the image\n          y * CELL_HEIGHT - (16 - CELL_HEIGHT) / 2, // Adjust y to center the image\n          treeType\n        );\n        return { x, y, content: tree };\n      })\n    );\n\n    this.villages = [\n      new Village('Heart Peak', { x: 70, y: 90 }, 12, 0, 0),\n      new Village('Pine Rest', { x: 99, y: 100 }, 6, 2, 3),\n      new Village('Oak Branch', { x: 42, y: 51 }, 4, 3, 4),\n      new Village('Cat Foot', { x: 48, y: 140 }, 5, 4, 5),\n      new Village('Black Tail', { x: 113, y: 107 }, 4, 5, 8),\n      new Village('Moon Town', { x: 129, y: 29 }, 8, 12, 25),\n    ];\n\n\n    // Clear paths with jitter\n    for (const path of paths) {\n      for (let i = 0; i < path.length - 1; i++) {\n        const from = { x: path[i][0], y: path[i][1] };\n        const to = { x: path[i + 1][0], y: path[i + 1][1] };\n        const pathWidth = path[i][2];\n        this.clearPathWithJitter(from, to, pathWidth);\n      }\n    }\n\n    // Clear circular areas with jitter\n    for (const clearing of clearings) {\n      this.clearCircleWithJitter(clearing.x, clearing.y, clearing.r);\n    }\n\n    // Calculate neighbor information for each tree\n    for (let y = 0; y < rowCount; y++) {\n      for (let x = 0; x < colCount; x++) {\n        const cell = this.grid[y][x];\n        if (cell.content instanceof Tree) {\n          const neighbors = {\n            top: this.grid[y - 1]?.[x]?.content instanceof Tree,\n            bottom: this.grid[y + 1]?.[x]?.content instanceof Tree,\n            left: this.grid[y]?.[x - 1]?.content instanceof Tree,\n            right: this.grid[y]?.[x + 1]?.content instanceof Tree,\n          };\n          cell.content.setNeighbors(neighbors);\n        }\n      }\n    }\n\n    for (const village of this.villages) {\n      village.generateFarms(this.rng, this)\n        .forEach(farm => {\n          this.grid[farm.row][farm.col].content = farm;\n        });\n      village.generateHouses(this.rng, this)\n        .forEach(house => {\n          this.grid[house.row][house.col].content = house;\n        });\n      village.generateVillagers(this.rng, this)\n        .forEach(villager => {\n          this.grid[villager.row][villager.col].content = villager;\n        });\n\n      // Set cell.village for each cell in the village radius\n      const { x: centerX, y: centerY } = village.center;\n      const radius = village.radius;\n      for (let y = centerY - radius; y <= centerY + radius; y++) {\n      for (let x = centerX - radius; x <= centerX + radius; x++) {\n          const dx = x - centerX;\n          const dy = y - centerY;\n          if (dx * dx + dy * dy <= radius * radius) {\n            this.grid[y][x].village = village;\n          }\n        }\n      }\n\n      // Generate starting home\n      this.set(61, 84, new House(61, 84, 'home'));\n    }\n\n    this.fillCenterWithGrass(1.0);\n\n    this.obelisk = new Obelisk(this);\n\n    for (const statueProps of Object.values(statues)) {\n      const { x, y, name } = statueProps;\n      const fullName = `cat ${name} altar`;\n      const statue = new Statue(x, y, this, this.gameData, fullName);\n      // Place farms in the 8 squares around the statue\n      forEachSurroundingCell(x, y, (farmCol, farmRow) => {\n        const cell = this.grid[farmRow][farmCol];\n        cell.content = new Farm(farmCol, farmRow);\n      });\n      this.grid[y][x].content = statue;\n      this.statues.push(statue);\n    }\n\n    on(GameEvent.SPAWN_FIRST_SPIRIT, () => {\n      this.set(64, 89, new Spirit(64, 89, '☁️', this));\n    });\n  }\n\n  getLookingAt() {\n    return this.grid[this.playerLookingAt.row][this.playerLookingAt.col];\n  }\n\n  get(col: number, row: number) {\n    if (row < 0 || row >= this.rowCount || col < 0 || col >= this.colCount) {\n      return null;\n    }\n    return this.grid[row][col];\n  }\n\n  clearPlants(col: number, row: number) {\n    if(\n      this.grid[row][col].content instanceof Tree\n      || this.grid[row][col].content instanceof Farm\n    ) {\n      this.grid[row][col].content = null;\n    }\n  }\n\n  // Fill the center area with fields to limit player movements\n  // until they finish the onboarding.\n  // Then clear out a path from where the player starts, to the obelisk,\n  // and to the heart statue.\n  fillCenterWithGrass(converage: number) {\n    const heartsPeak = this.villages[0];\n    const radius = 12;\n    const { x: centerX, y: centerY } = heartsPeak.center;\n    for (let y = centerY - radius; y <= centerY + radius; y++) {\n      for (let x = centerX - radius; x <= centerX + radius; x++) {\n        const cell = this.grid[y][x];\n        if (!cell.content && this.rng.next() <= converage) {\n          cell.content = new Farm(cell.x, cell.y);\n        } else if (cell.content instanceof Farm && this.rng.next() > converage) {\n          cell.content = null;\n        }\n      }\n    }\n    \n    const villagePath: Path = [\n      [61, 86, 2],\n      [69, 88, 0.9],\n      [75, 89, 0.9],\n      [76, 84, 0.9],\n    ];\n    for (let i = 0; i < villagePath.length - 1; i++) {\n      const from = { x: villagePath[i][0], y: villagePath[i][1] };\n      const to = { x: villagePath[i + 1][0], y: villagePath[i + 1][1] };\n      const pathWidth = villagePath[i][2];\n      this.clearPathWithJitter(from, to, pathWidth);\n    }\n  }\n\n  clearPathWithJitter(\n    from: { x: number, y: number },\n    to: { x: number, y: number },\n    pathWidth: number,\n  ) {\n    // Bresenham's line algorithm for any angle\n    const dx = Math.abs(to.x - from.x);\n    const dy = Math.abs(to.y - from.y);\n    const sx = from.x < to.x ? 1 : -1;\n    const sy = from.y < to.y ? 1 : -1;\n    let err = dx - dy;\n\n    let x = from.x;\n    let y = from.y;\n\n    const halfWidth = pathWidth / 2;\n\n    while (true) {\n      // Add jitter to the clearing area\n      const jitterAmount = pathWidth < 1 ? 0 : 1.2; // Adjust for more/less randomness\n      const jitterX = Math.ceil(this.rng.range(-jitterAmount, jitterAmount));\n      const jitterY = Math.ceil(this.rng.range(-jitterAmount, jitterAmount));\n\n      // Clear area around the current position with jitter\n      for (let ox = -halfWidth; ox <= halfWidth; ox++) {\n        for (let oy = -halfWidth; oy <= halfWidth; oy++) {\n          const clearX = Math.ceil(x + ox + jitterX);\n          const clearY = Math.ceil(y + oy + jitterY);\n          this.clearPlants(clearX, clearY);\n          if (pathWidth < 1) {\n            if (this.rng.next() > 0.5) {\n              this.clearPlants(clearX + 1, clearY);\n            } else {\n              this.grid[clearY][clearX].content = new Farm(clearX, clearY);\n              this.grid[clearY][clearX + 1].content = new Farm(clearX, clearY);\n            }\n          } else if (this.rng.next() > 0.1) {\n            if (this.rng.next() > 0.05) {\n              // Add probability for partial clearing to create natural edges\n              this.clearPlants(clearX, clearY);\n            } else {\n              this.grid[clearY][clearX].content = new Farm(clearX, clearY);\n            }\n          }\n        }\n      }\n\n      // Check if we've reached the destination\n      if (x === to.x && y === to.y) break;\n\n      const e2 = 2 * err;\n      if (e2 > -dy) {\n        err -= dy;\n        x += sx;\n      }\n      if (e2 < dx) {\n        err += dx;\n        y += sy;\n      }\n    }\n  }\n\n  clearCircleWithJitter(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    fieldsOnly = false,\n    border = 99,\n    probability = 1,\n  ) {\n    for (let y = 0; y < this.rowCount; y++) {\n      for (let x = 0; x < this.colCount; x++) {\n        const dx = x - centerX;\n        const dy = y - centerY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Add jitter to radius for natural edge\n        const jitterRadius = this.rng.range(-radius, radius) / 6;\n        const adjustedRadius = radius + jitterRadius;\n\n        // Calculate inner radius based on borderRatio\n        const innerRadius = adjustedRadius - border;\n        \n        if (distance >= innerRadius && distance <= adjustedRadius) {\n          // Add probability for partial clearing near edges\n          const edgeDistance = adjustedRadius - distance;\n          const clearProbability = Math.min(1, edgeDistance / 2 + 0.7) * probability;\n\n          if (this.rng.next() < clearProbability) {\n            const isFarm = this.grid[y][x].content instanceof Farm;\n            if (!fieldsOnly || fieldsOnly && isFarm) {\n              this.grid[y][x].content = null;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  set(col: number, row: number, content: Drawable | null) {\n    if (this.grid[row] && this.grid[row][col]) {\n      this.grid[row][col].content = content;\n    }\n  }\n\n  update(timeElapsed: number, isCutscene: boolean) {\n    for (const row of this.grid) {\n      for (const cell of row) {\n        if (cell.content) {\n          cell.content.updateAnimation?.(timeElapsed);\n          if (!isCutscene) {\n            cell.content.update?.(timeElapsed);\n            if (cell.x != cell.content.col || cell.y != cell.content.row) {\n              this.grid[cell.content.row][cell.content.col].content = cell.content;\n              cell.content = null;\n            }\n            if (cell.content && (cell?.content as Spirit)?.dead) {\n              this.set(cell.content.col, cell.content.row, null);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  draw(cx: number, cy: number) {\n    const zoom = drawEngine.zoom;\n    const renderWidth = (drawEngine.canvasWidth / zoom) / 2 + 50;\n    const renderHeight = (drawEngine.canvasHeight / zoom) / 2 + 50;\n    const seenRadius = 75;\n    const seenRadiusSquared = seenRadius * seenRadius;\n\n    // Compute visible cell bounds\n    const minCol = Math.max(0, Math.floor((cx - renderWidth) / CELL_WIDTH));\n    const maxCol = Math.min(this.colCount - 1, Math.ceil((cx + renderWidth) / CELL_WIDTH));\n    const minRow = Math.max(0, Math.floor((cy - renderHeight) / CELL_HEIGHT));\n    const maxRow = Math.min(this.rowCount - 1, Math.ceil((cy + renderHeight) / CELL_HEIGHT));\n\n    // First pass: draw ground\n    for (let row = minRow; row <= maxRow; row++) {\n      for (let col = minCol; col <= maxCol; col++) {\n        const cell = this.grid[row][col];\n        const x = cell.x * CELL_WIDTH;\n        const y = cell.y * CELL_HEIGHT;\n        drawEngine.drawBackgroundImage(GameAssets.ground, x, y);\n      }\n    }\n\n    // Second pass: draw content, collect postDraw\n    const postDrawDrawables: Drawable[] = [];\n    let drawHighlight = false;\n    for (let row = minRow; row <= maxRow; row++) {\n      for (let col = minCol; col <= maxCol; col++) {\n        const cell = this.grid[row][col];\n        const x = cell.x * CELL_WIDTH;\n        const y = cell.y * CELL_HEIGHT;\n        const dx = x - cx;\n        const dy = y - cy;\n\n        // Seen radius for minimap\n        const distanceSquared = dx * dx + dy * dy;\n        if (distanceSquared <= seenRadiusSquared) {\n          cell.seen = true;\n        }\n\n        if (\n          cell.y === this.playerLookingAt.row &&\n          cell.x === this.playerLookingAt.col &&\n          cell.content &&\n          cell.content.type !== 'oak' && cell.content.type !== 'spruce'\n        ) {\n          drawHighlight = true;\n        }\n\n        cell?.content?.draw();\n        if (cell?.content?.postDraw) {\n          postDrawDrawables.push(cell?.content);\n        }\n      }\n    }\n\n    // Third pass: postDraw\n    // @ts-expect-error -- postDraw is definitely defined\n    postDrawDrawables.forEach(drawable => drawable.postDraw());\n\n    if (drawHighlight) {\n      drawEngine.drawBackgroundImage(\n        GameAssets.cornerImage,\n        this.playerLookingAt.col * CELL_WIDTH - (16 - CELL_WIDTH) / 2,\n        this.playerLookingAt.row * CELL_HEIGHT - (16 - CELL_HEIGHT) / 2\n      );\n    }\n  }\n}\n","\nexport const easeInOutSine = (x: number, min: number, max: number): number => {\n  const ease = -(Math.cos(Math.PI * x) - 1) / 2;\n  return min + ease * max;\n};\n\n/**\n * Converts a value from 0 to 1 to an exponential ease.\n * @param x value from 0 to 1\n * @returns value from 0 to 1\n */\nexport const easeInExpo = (x: number, ease = 5): number => {\n  return x === 1 ? 1 : 1 - Math.pow(2, -ease * x);\n};\n","import { colors } from '@/core/util/color';\nimport { GameMap } from './game-map';\nimport { Player } from './entities/player';\nimport { drawEngine } from '@/core/draw-engine';\n\n/* eslint-disable quote-props */\nconst pixelColors: Record<string, string> = {\n  'oak': colors.green3,\n  'spruce': colors.blue2,\n  'house': colors.blue4,\n  'field': colors.yellow1,\n  'statue': colors.blue6,\n  'unseen': colors.blue5,\n  'default': colors.yellow2,\n};\n/* eslint-enable quote-props */\n\n\nexport class MiniMap {\n  private lastUpdate = 0;\n  private updateInterval = 100; // Update once per second\n\n  constructor(private map: GameMap) { }\n\n  update(timeElapsed: number) {\n    this.lastUpdate += timeElapsed;\n  }\n\n  public draw(player: Player) {\n    if (this.lastUpdate < this.updateInterval) {\n      return;\n    }\n\n    this.lastUpdate = 0;\n    const ctx = drawEngine.ctx4;\n    const mapSize = 160;\n    const margin = 10;\n    const x = ctx.canvas.width - mapSize - margin; // Bottom right with margin\n    const y = ctx.canvas.height - mapSize - margin;\n\n    // Clear previous minimap\n    ctx.clearRect(x, y, mapSize, mapSize);\n\n    // Draw map pixels\n    for (let my = 0; my < mapSize; my++) {\n      for (let mx = 0; mx < mapSize; mx++) {\n        const cell = this.map.grid[my][mx];\n\n        if (!cell.seen) {\n          ctx.fillStyle = pixelColors.unseen;\n        } else {\n          ctx.fillStyle = pixelColors[cell.content?.type || 'default'] ?? pixelColors.default;\n        }\n\n        ctx.fillRect(x + mx, y + my, 1, 1);\n      }\n    }\n\n    if (player.col >= 0 && player.col < mapSize && player.row >= 0 && player.row < mapSize) {\n      ctx.fillStyle = colors.purple4;\n      ctx.beginPath();\n      ctx.arc(x + player.col, y + player.row, 2, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { on } from '@/core/event';\nimport { StoryEngineEvent } from '@/core/story-engine';\nimport { colors } from '@/core/util/color';\n\nexport class DialogBox {\n  dialog: string | null = null;\n\n  constructor() {\n    on(StoryEngineEvent.STORY_DIALOG, (dialog) => {\n      this.dialog = dialog;\n    });\n\n    on(StoryEngineEvent.STORY_STATE_EXIT, () => {\n      this.dialog = null;\n    });\n  }\n\n  draw () {\n    if (this.dialog) {\n      const boxHeight = 160; // same as minimap\n      const margin = 20; // same as minimap\n      const boxWidth = c3.width - boxHeight - margin*3;\n      const x = margin;\n      const y = c3.height - boxHeight - margin;\n      drawEngine.ctx3.fillStyle = colors.purple4;\n      drawEngine.ctx3.fillRect(x+5, y+5, boxWidth, boxHeight);\n      drawEngine.ctx3.fillStyle = colors.purple0;\n      drawEngine.ctx3.fillRect(x, y, boxWidth-5, boxHeight-5);\n\n      this.dialog.split('\\n').forEach((dialog, i) => {\n        drawEngine.drawText(\n          dialog,\n          x + margin * 2,\n          y + margin * 2 + i * 40,\n          dialog[0] === '>' ? colors.purple4 : colors.black,\n          0, // left\n          0, // top\n          5,\n          1,\n          drawEngine.ctx3\n        );\n      });\n\n      drawEngine.drawText(\n          'press (space) to continue',\n          x + boxWidth - margin,\n          y + boxHeight - margin,\n          colors.purple4,\n          2, // right\n          2, // bottom\n          3,\n          1,\n          drawEngine.ctx3\n        );\n    }\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { colors } from '@/core/util/color';\nimport { easeInOutSine } from '@/core/util/util';\nimport { MiniMap } from './mini-map';\nimport { GameMap } from './game-map';\nimport { Player } from './entities/player';\nimport { Actions } from './actions';\nimport { GameData } from './game-data';\nimport { MAX_LIVES, MAX_MAGIC, NOTIFICATION_DURATION } from './constants';\nimport { DialogBox } from './dialog-box';\nimport { MAGIC, EMPTY_HEART, FULL_HEART, ONE_THIRD_HEART, TWO_THIRDS_HEART } from '@/core/font';\nimport { on } from '@/core/event';\nimport { GameEvent } from './event-manifest';\nimport { Village } from './entities/village';\n\nexport class HUD {\n  miniMap: MiniMap;\n  dialogBox: DialogBox;\n  renderSuperstition = false;\n  renderLives = false;\n  renderMagic = false;\n  villageName = '';\n  villageNameTimer = 0;\n\n  constructor(\n    public map: GameMap,\n    public player: Player,\n    public actions: Actions,\n    public gameData: GameData,\n  ) {\n    this.miniMap = new MiniMap(map);\n    this.dialogBox = new DialogBox();\n\n    on(GameEvent.ENABLE_SCRATCH, () => {\n      this.renderLives = true;\n    });\n\n    on(GameEvent.NOT_ENOUGH_MAGIC, () => {\n      this.renderMagic = true;\n    });\n\n    on(GameEvent.ENTER_VILLAGE, (village: Village) => {\n      this.villageName = village.name;\n      this.villageNameTimer = 3000;\n    });\n\n    on(GameEvent.SCARED, () => {\n      this.renderSuperstition = true;\n    });\n  }\n\n  update(timeElapsed: number) {\n    this.miniMap.update(timeElapsed);\n    this.villageNameTimer -= timeElapsed;\n  }\n\n  draw() {\n    this.renderLives && this.drawLives();\n    this.renderMagic && this.drawMagic();\n    this.drawGoals();\n    this.renderSuperstition && this.drawSuperstition();\n    this.drawActions();\n    this.drawInfoBox();\n    this.renderLives && this.miniMap.draw(this.player);\n    this.dialogBox.draw();\n  }\n\n  drawActions() {\n    const actions = this.actions.actions;\n    if (!actions || !actions[0].enabled) {\n      return;\n    }\n\n    const boxWidth = 120;\n    const boxHeight = 120;\n    const spacing = 10;\n    const totalWidth = actions.length * boxWidth + (actions.length - 1) * spacing;\n    const startX = Math.round((drawEngine.ctx3.canvas.width - totalWidth) / 2);\n    const y = drawEngine.ctx3.canvas.height - boxHeight - 10;\n\n    actions.forEach(({ type, color, symbol }, index) => {\n      const x = startX + index * (boxWidth + spacing);\n\n      // Draw background box\n      drawEngine.ctx3.fillStyle = colors.purple0;\n      drawEngine.ctx3.fillRect(x, y, boxWidth, boxHeight);\n\n      // Draw symbol (large font)\n      drawEngine.drawText(\n        symbol,\n        x + boxWidth / 2,\n        y + 30,\n        color,\n        1, // center\n        1, // middle\n        7,\n        1,\n        drawEngine.ctx3\n      );\n\n      // Draw action name\n      drawEngine.drawText(\n        type,\n        x + boxWidth / 2,\n        y + 95,\n        colors.black,\n        1, // center\n        1, // middle\n        3,\n        1,\n        drawEngine.ctx3\n      );\n    });\n  }\n\n  drawLives() {\n    const x = 16;\n    const y = 16;\n    const fullHearts = Math.floor(this.gameData.lives);\n    const emptyHearts = Math.floor(MAX_LIVES - this.gameData.lives);\n    const halfHearts = MAX_LIVES - fullHearts - emptyHearts;\n    const partialHearts = this.gameData.lives - fullHearts;\n    const text = FULL_HEART.repeat(fullHearts)\n      + (partialHearts > 0.3 ? TWO_THIRDS_HEART : ONE_THIRD_HEART).repeat(halfHearts)\n      + EMPTY_HEART.repeat(emptyHearts);\n    const size = 5;\n\n    const boxW = (text.length * 6 + 1) * size;\n    const boxH = 7 * size;\n    drawEngine.ctx3.fillStyle = colors.purple0;\n    drawEngine.ctx3.fillRect(x, y, boxW, boxH);\n    drawEngine.drawText(text, x + size, y + size, colors.purple4, 0, 0, size, 1, drawEngine.ctx3);\n  }\n\n  drawMagic() {\n    let x = c3.width - 16;\n    const y = 16;\n    const fullMagic = this.gameData.magic;\n    const emptyMagic = this.gameData.maxMagic - this.gameData.magic;\n    const noMagic = MAX_MAGIC - this.gameData.maxMagic;\n\n    const size = 5;\n    const charWidth = (5 + 1) * size;\n\n    const boxW = MAX_MAGIC * charWidth + size;\n    const boxH = 7 * size;\n    drawEngine.ctx3.fillStyle = colors.yellow1;\n    drawEngine.ctx3.fillRect(x - boxW + size, y, boxW, boxH);\n\n    let text = MAGIC.repeat(fullMagic);\n    x -= text.length * charWidth;\n    drawEngine.drawText(text, x + size, y + size, colors.blue2, 0, 0, size, 1, drawEngine.ctx3);\n\n    text = MAGIC.repeat(emptyMagic);\n    x -= text.length * charWidth;\n    drawEngine.drawText(text, x + size, y + size, colors.blue3, 0, 0, size, 1, drawEngine.ctx3);\n\n    text = MAGIC.repeat(noMagic);\n    x -= text.length * charWidth;\n    drawEngine.drawText(text, x + size, y + size, colors.yellow2, 0, 0, size, 1, drawEngine.ctx3);\n  }\n\n  drawGoals() {\n    const goals = this.gameData.goals;\n\n    const baseX = 16;\n    const y = 16 + 7 * 5 + 10; // lives y  + lives box height + margin\n    const boxW = 510;\n    const boxH = 5 * 7 + 30;\n    const size = 3;\n    const padding = 5;\n    const aD = 200; // 100ms slide animation\n    \n    goals.filter(goal => goal.time > 0)\n    .forEach((goal, i) => {\n      const {label, time} = goal;\n      const boxY = y + (boxH + padding) * i;\n      \n      // Calculate animation offset based on remaining time\n      let offsetX = 0;\n      const distanceX = boxW + baseX;\n      if (time > NOTIFICATION_DURATION - aD) {\n        // Sliding in from left (appearing)\n        const progress = (NOTIFICATION_DURATION - time) / aD;\n        const easedProgress = easeInOutSine(progress, 0, 1);\n        offsetX = -distanceX * (1 - easedProgress);\n      } else if (time < aD) {\n        // Sliding out to left (disappearing)\n        const progress = time / aD;\n        const easedProgress = easeInOutSine(progress, 0, 1);\n        offsetX = -distanceX * (1 - easedProgress);\n      }\n      \n      const x = baseX + offsetX;\n      \n      drawEngine.ctx3.fillStyle = colors.purple4;\n      drawEngine.ctx3.fillRect(x, boxY, boxW, boxH);\n      drawEngine.drawText(\n        'GOAL',\n        x + size + padding,\n        boxY + padding,\n        colors.white,\n        0, // left\n        0, // top\n        size + 1,\n        1,\n        drawEngine.ctx3\n      );\n      drawEngine.drawText(\n        label,\n        x + size + padding + 20,\n        35 + boxY + padding,\n        colors.purple0,\n        0, // left\n        0, // top\n        size,\n        1,\n        drawEngine.ctx3\n      );\n    });\n  }\n\n  drawSuperstition() {\n    const text = 'superstition';\n    const size = 3;\n    const charWidth = 5;\n    const padding = 5;\n    const boxW = (text.length * size + padding * 2) * charWidth;\n    const boxH = 35;\n    const x = Math.round(c3.width / 2 - boxW / 2);\n    const y = 16;\n\n    // Background\n    drawEngine.ctx3.fillStyle = colors.purple0;\n    drawEngine.ctx3.fillRect(x, y, boxW, 62);\n\n    drawEngine.ctx3.fillStyle = colors.blue5;\n    drawEngine.ctx3.fillRect(x + padding, y + padding, boxW - 2 * padding, boxH - 2 * padding);\n\n    drawEngine.ctx3.fillStyle = this.gameData.superstition > 0.9 ? colors.purple4 : colors.blue2;\n    const barSize = Math.round(this.gameData.superstition * (boxW - 2 * padding) / 3) * 3;\n    drawEngine.ctx3.fillRect(x + padding, y + padding, barSize, boxH - 2 * padding);\n\n    drawEngine.drawText(text, c3.width / 2, y + boxH + size, colors.blue5, 1, 0, size, 1, drawEngine.ctx3);\n  }\n\n  drawInfoBox() {\n    if(this.villageNameTimer > 0) {\n      const t = this.villageNameTimer;\n      const tNorm = Math.max(0, Math.min(1, Math.min(t / 150, (3000 - t) / 150)));\n      const opacity = easeInOutSine(tNorm, 0, 1);\n      drawEngine.ctx3.globalAlpha = opacity;\n      this.drawInfo(`^^ ${this.villageName}`, 170);\n      drawEngine.ctx3.globalAlpha = 1;\n    }\n\n    if (this.map.playerLookingAt) {\n      const cell = this.map.getLookingAt();\n      if (cell?.content?.name) {\n        this.drawInfo(cell.content.name, c3.height - 170);\n      }\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  drawInfo(text: string, y: number) {\n    const boxWidth = 350;\n    const boxHeight = 35;\n    drawEngine.ctx3.fillStyle = colors.purple5;\n    drawEngine.ctx3.fillRect(\n      c3.width / 2 - boxWidth / 2 + 4,\n      y - 6 * 3 - 4,\n      boxWidth - 8,\n      boxHeight + 8,\n    );\n    drawEngine.ctx3.fillStyle = colors.yellow2;\n    drawEngine.ctx3.fillRect(\n      c3.width / 2 - boxWidth / 2,\n      y - 6 * 3,\n      boxWidth,\n      boxHeight,\n    );\n    drawEngine.drawText(\n      text,\n      c3.width / 2,\n      y,\n      colors.purple4,\n      1, // center\n      1, // middle\n      3,\n      1,\n      drawEngine.ctx3\n    );\n  }\n}\n","import { GameMap } from './game-map';\nimport { Player } from './entities/player';\nimport { MAX_REPAIR, statues } from './constants';\nimport { colors } from '@/core/util/color';\nimport { emit, on } from '@/core/event';\nimport { MAGIC, SCRATCH, TELEPORT } from '@/core/font';\nimport { controls } from '@/core/controls';\nimport { Statue } from './entities/statue';\nimport { Obelisk } from './entities/obelisk';\nimport { addTimeEvent } from '@/core/timer';\nimport { GameEvent } from './event-manifest';\nimport { repair } from '@/core/audio';\nimport { Cell } from './types';\nimport { Spirit } from './entities/spirit';\nimport { Farm } from './entities/farm';\nimport { House } from './entities/house';\n\ntype ActionType = 'teleport' | 'scratch' | 'repair' | 'sleep';\ntype Action = {\n  type: ActionType,\n  color: string,\n  enabled: boolean,\n  symbol: string,\n}\n\nconst actions: Action[] = [\n  {\n    type: 'scratch',\n    color: colors.purple4,\n    enabled: false,\n    symbol: SCRATCH,\n  },\n  {\n    type: 'teleport',\n    color: colors.blue2,\n    enabled: true,\n    symbol: TELEPORT,\n  },\n  {\n    type: 'repair',\n    color: colors.green3,\n    enabled: true,\n    symbol: MAGIC,\n  },\n  {\n    type: 'sleep',\n    color: colors.yellow2,\n    enabled: true,\n    symbol: 'z',\n  },\n];\n\nexport class Actions {\n  map: GameMap;\n  player: Player;\n  actions: Action[] = [];\n\n  constructor(map: GameMap, player: Player) {\n    this.map = map;\n    this.player = player;\n\n    on(GameEvent.ENABLE_SCRATCH, () => {\n      this.actions[0].enabled = true;\n    });\n  }\n\n  // Update available actions based on player's current position\n  update(): void {\n    const cellInFront = this.map.getLookingAt();\n\n    const canTeleport  = this.canTeleport(cellInFront);\n    const canRestore = this.canRestore(cellInFront);\n    const canSleep = this.canSleep(cellInFront);\n    const canAttack = this.canAttack(cellInFront);\n\n    this.actions = [\n      canAttack ? actions[0]\n      : canTeleport ? actions[1]\n      : canRestore ? actions[2]\n      : canSleep ? actions[3]\n      : actions[0]\n    ];\n\n    if (controls.isAction1 && !controls.previousState.isAction1) {\n      switch (true) {\n        case canAttack:\n          // Attack happens somewhere else\n          break;\n        \n        case canTeleport:\n          emit(GameEvent.TELEPORT);\n          break;\n        \n        case canRestore:\n          this.doRestore(cellInFront);\n          break;\n\n        case canSleep:\n          emit(GameEvent.SLEEP);\n\n      \n        default:\n          break;\n      }\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  doRestore(cellInFront: Cell) {\n    emit(GameEvent.RESTORE);\n    const object = cellInFront.content as Statue | Obelisk;\n    if (object.repair < MAX_REPAIR) {\n      if (object instanceof Statue) {\n        object.repair++;\n        repair(object.repair);\n        if (object.repair >= MAX_REPAIR) {\n          addTimeEvent(() => {\n            emit(GameEvent.STATUE_RESTORED, this.map.gameData.maxMagic);\n          }, 4000);\n        }\n      } else if (object instanceof Obelisk) {\n        object.attemptRepair();\n      }\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  private canRestore(cellInFront: Cell): boolean {\n    const object = cellInFront.content as Statue | Obelisk;\n    const type = object?.type;\n    return (\n      (type === 'statue' || type === 'obelisk')\n    ) && object.repair < MAX_REPAIR;\n  }\n\n  private canTeleport(cellInFront: Cell) {\n    return cellInFront.content instanceof Statue\n      && this.player.col != statues.heart.x\n      && cellInFront.content.state === Statue.State.REPAIRED;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  private canSleep(cellInFront: Cell) {\n    return cellInFront.content instanceof House\n      && cellInFront.content.name === 'home';\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  private canAttack(cellInFront: Cell) {\n    return cellInFront.content instanceof Spirit\n      || cellInFront.content instanceof Farm;\n  }\n}\n","import { emit, on } from '@/core/event';\nimport { MAX_LIVES, NOTIFICATION_DURATION } from './constants';\nimport { SceneProps } from './game-story';\nimport { GameEvent } from './event-manifest';\nimport { addTimeEvent } from '@/core/timer';\nimport { heal, hissAndSpit } from '@/core/audio';\n\ninterface Goal {\n  label: string,\n  time: number,\n}\n\nexport class GameData {\n  cutscene = false;\n  lives = MAX_LIVES;\n  maxMagic = 0;\n  magic = 0;\n  superstition = 0;\n  goals: Goal[] = [];\n  hasClearedIntro = false;\n  win = false;\n\n  constructor() {\n    on(GameEvent.SCARED, () => {\n      this.superstition = Math.min(1, this.superstition + 0.01);\n    });\n\n    on(GameEvent.CUTSCENE_START, () => {\n      this.cutscene = true;\n    });\n\n    on(GameEvent.CUTSCENE_END, (scene: SceneProps) => {\n      this.cutscene = false;\n      if (scene.goals) {\n        scene.goals.forEach(goal => {\n          this.goals.push({\n            label: goal,\n            time: NOTIFICATION_DURATION,\n          });\n        });\n      }\n    });\n\n    on(GameEvent.ATTACK_PLAYER, (level: number) => {\n      this.lives -= (level + 1) / 3;\n      this.lives = Math.round(this.lives * 3) / 3;\n      this.lives = Math.round(this.lives * 10) / 10;\n      hissAndSpit();\n      if (this.lives <= 0) {\n        this.lives = 0;\n        emit(GameEvent.GAME_OVER);\n      }\n    });\n\n    on(GameEvent.STATUE_RESTORED, () => {\n      this.maxMagic++;\n      this.magic = this.maxMagic;\n      this.heal();\n\n      emit(GameEvent.NEXT_STATUE_DIALOG, this.maxMagic);\n    });\n\n    on(GameEvent.SLEEP, () => {\n      this.heal();\n    });\n  }\n\n  heal() {\n    let i = 0;\n    for (let lives = Math.floor(this.lives) + 1; lives <= MAX_LIVES; lives++) {\n      addTimeEvent(() => {\n        this.lives = lives;\n        heal();\n      }, 500 + 800 * (i++));\n    }\n  }\n\n  update(timeElapsed: number) {\n    this.goals.forEach(goal => goal.time -= timeElapsed);\n  }\n\n  getLevel() {\n    return this.superstition * 4 + this.maxMagic;\n  }\n}\n","import { controls } from './controls';\nimport { emit, on } from '@/core/event';\n\nexport interface DialogState {\n  dialogs: string[];\n  isDone?: boolean;\n}\n\nexport interface Script {\n  [stateKey: string]: DialogState;\n}\n\nexport const enum StoryEngineEvent {\n  // Story events\n  STORY_STATE_ENTER = 1,\n  STORY_STATE_EXIT = 2,\n  STORY_DIALOG = 3,\n};\n\nexport class Story<T extends Script> {\n  private currentStateKey: keyof T | null = null;\n  private currentDialogIndex = 0;\n  public isActive = false;\n  private previousSpacePressed = false;\n  public currentState: keyof T | null = null;\n  \n  fullText = '';\n  visibleCharacters = 0;\n  textAnimationTimer = 0;\n  charactersPerSecond = 20;\n  textAnimationState = 2; // 0=typing, 1=complete, 2=waiting\n\n  constructor(private readonly script: T) {\n    on(StoryEngineEvent.STORY_STATE_ENTER, (stateKey: keyof T) => {\n      this.enterState(stateKey);\n    });\n  }\n\n  public enterState(stateKey: keyof T) {\n    if (!this.script[stateKey]) {\n      return;\n    }\n\n    this.currentStateKey = stateKey;\n    this.currentState = stateKey;\n    this.currentDialogIndex = 0;\n    this.isActive = true;\n    this.previousSpacePressed = false;\n\n    this.showCurrentDialog();\n  }\n\n  update(timeElapsed: number) {\n    if (!this.isActive || !this.currentStateKey) {\n      return;\n    }\n\n    const spacePressed = controls.keyMap.get('Space');\n    const spaceJustPressed = spacePressed && !this.previousSpacePressed;\n    this.previousSpacePressed = spacePressed || false;\n\n    // Update typewriter animation\n    if (this.textAnimationState === 0) { // typing\n      this.textAnimationTimer += timeElapsed;\n      const targetCharacters = Math.floor((this.textAnimationTimer / 1000) * this.charactersPerSecond);\n      \n      if (targetCharacters >= this.fullText.length) {\n        // Animation complete\n        this.visibleCharacters = this.fullText.length;\n        this.textAnimationState = 1; // complete\n        this.emitCurrentVisibleText();\n      } else if (targetCharacters > this.visibleCharacters) {\n        // Show more characters\n        this.visibleCharacters = targetCharacters;\n        this.emitCurrentVisibleText();\n      }\n    }\n\n    if (spaceJustPressed) {\n      this.handleSpacePress();\n    }\n  }\n\n  private handleSpacePress() {\n    if (!this.currentStateKey) {\n      return;\n    }\n\n    if (this.textAnimationState === 0) { // typing\n      // Skip typing animation - show full text immediately\n      this.visibleCharacters = this.fullText.length;\n      this.textAnimationState = 1; // complete\n      this.emitCurrentVisibleText();\n      return;\n    }\n\n    if (this.textAnimationState === 1) { // complete\n      // Move to next dialog or exit\n      const currentState = this.script[this.currentStateKey];\n      \n      if (this.currentDialogIndex < currentState.dialogs.length - 1) {\n        // Move to next dialog\n        this.currentDialogIndex++;\n        this.showCurrentDialog();\n      } else {\n        // All dialogs complete, exit state\n        this.exitCurrentState();\n      }\n    }\n  }\n\n  private emitCurrentVisibleText() {\n    const visibleText = this.fullText.substring(0, this.visibleCharacters);\n    emit(StoryEngineEvent.STORY_DIALOG, visibleText);\n  }\n\n  private showCurrentDialog() {\n    if (!this.currentStateKey) {\n      return;\n    }\n\n    const currentState = this.script[this.currentStateKey];\n    currentState.isDone = true;\n    this.fullText = currentState.dialogs[this.currentDialogIndex];\n    \n    // Reset typewriter animation\n    this.visibleCharacters = 0;\n    this.textAnimationTimer = 0;\n    this.textAnimationState = 0; // typing\n    \n    // Start with empty text\n    this.emitCurrentVisibleText();\n  }\n\n  private exitCurrentState() {\n    if (!this.currentStateKey) {\n      return;\n    }\n\n    const stateKey = this.currentStateKey;\n    this.isActive = false;\n    this.currentStateKey = null;\n    this.currentState = null;\n    this.currentDialogIndex = 0;\n    \n    emit(StoryEngineEvent.STORY_STATE_EXIT, stateKey);\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { emit, on } from '@/core/event';\nimport { DialogState, Story, StoryEngineEvent } from '@/core/story-engine';\nimport { addTimeEvent } from '@/core/timer';\nimport { GameEvent } from './event-manifest';\nimport { MAX_MAGIC } from './constants';\n\nexport interface SceneProps extends DialogState {\n  goals?: string[],\n};\n\nconst enum Scene {\n  intro = 1,\n  spirit,\n  barrier,\n  temple,\n  noMagic,\n  magicRestored,\n  villagers,\n  end,\n}\n\nconst script = {} as Record<Scene, SceneProps>;\n\n// Use programmatic assignment to avoid preserving enum string names\nscript[Scene.intro] = {\n  dialogs: [\n    'Zzzzz...',\n    'Yawwwn...',\n    'How long was i sleeping?...',\n  ],\n};\n\nscript[Scene.spirit] = {\n  dialogs: [\n    'Evil spirits?',\n    'Has the magic barrier failed\\nwhile I slept??',\n    'This one seems weak.',\n    \"I'll exorcise it and then\\ngo check the barrier\",\n    '> Use (space) to attack',\n  ],\n  goals: ['find magic barrier obelisk'],\n};\n\nscript[Scene.barrier] = {\n  dialogs: [\n    'I have no magic power left!',\n    'My magic comes from villagers\\nworshiping me...',\n    'Something must be wrong with\\nthe cat altar.',\n  ],\n  goals: ['repair the cat altar'],\n};\n\nscript[Scene.noMagic] = {\n  dialogs: [\n    \"I don't have enough magic!\",\n    'Something must be wrong with\\nthe cat altars in the valley',\n  ],\n};\n\nscript[Scene.temple] = {\n  dialogs: [\n    'My magic has increased a little.',\n    'But the other altars...\\nthey must be damaged too.',\n  ],\n  goals: [\n    'repair all 5 temples',\n    'restore the forest magic barrier',\n  ],\n};\n\nscript[Scene.villagers] = {\n  dialogs: [\n    'Villagers are very supersticious.',\n    'I should not let them see me,\\nthat will empower the evil spirits.',\n  ],\n};\n\nscript[Scene.magicRestored] = {\n  dialogs: [\n    'I have restore my full magic power',\n    'Now I am able to restore the\\nmagic barrier again.',\n  ],\n  goals: [\n    'restore the forest magic barrier',\n  ]\n};\n\nscript[Scene.end] = {\n  dialogs: [\n    'The barrier is restored.',\n    'The altars are back online.',\n    'The spirits are resting in peace.',\n    'Time for a well deserved nap...',\n  ],\n};\n\nconst postIntro = () => {\n  emit(GameEvent.WAKE_UP);\n  emit(GameEvent.SPAWN_FIRST_SPIRIT);\n  drawEngine.cameraLerpSpeed = 0.08;\n};\n\nexport class GameStory {\n  story: Story<typeof script>;\n\n  constructor() {\n    this.story = new Story({...script});\n\n    on(StoryEngineEvent.STORY_STATE_EXIT, (label: Scene) => {\n      emit(GameEvent.CUTSCENE_END, script[label]);\n      if (label === Scene.intro) {\n        postIntro();\n        addTimeEvent(() => {\n          emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.spirit);\n        }, 3000);\n      }\n      if(label === Scene.spirit) {\n        emit(GameEvent.ENABLE_SCRATCH);\n      }\n      if (label === Scene.end) {\n        addTimeEvent(() => emit(GameEvent.FADE_OUT), 3000);\n      }\n    });\n\n    on(StoryEngineEvent.STORY_STATE_ENTER, () => {\n      emit(GameEvent.CUTSCENE_START);\n    });\n\n    on(GameEvent.NOT_ENOUGH_MAGIC, () => {\n      if (script[Scene.barrier].isDone) {\n        emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.noMagic);\n      } else {\n        emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.barrier);\n      }\n    });\n\n    on(GameEvent.NEXT_STATUE_DIALOG, (magicLevel: number) => {\n      if (magicLevel < MAX_MAGIC) {\n        emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.temple);\n      } else {\n        emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.magicRestored);\n      }\n    });\n\n    on(GameEvent.SCARED, () => {\n      if (!script[Scene.villagers].isDone) {\n        emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.villagers);\n      }\n    });\n\n    on(GameEvent.GAME_END, () => {\n      emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.end);\n    });\n    \n\n    // addTimeEvent(() => this.story.enterState(Scene.intro), 1000);\n    setTimeout(() => {\n      postIntro();\n      emit(GameEvent.ENABLE_SCRATCH);\n    }, 10);\n  }\n\n  update (timeElapsed: number) {\n    this.story.update(timeElapsed);\n  }\n}\n","class MusicPlayer {\n  audioContext: AudioContext | undefined;\n  startTime = 0;\n  isPlaying = false;\n  buffer: AudioBuffer | undefined;\n  musicProcessorNode: AudioWorkletNode | undefined;\n\n  async start() {\n    if (this.isPlaying) return;\n\n    this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    await this.audioContext.resume();\n    await this.audioContext.audioWorklet.addModule('music-worklet.js');\n\n    this.musicProcessorNode = new AudioWorkletNode(this.audioContext, 'mp');\n    \n    this.musicProcessorNode.connect(this.audioContext.destination);\n    this.isPlaying = true;\n  }\n\n  startMelody() {\n    this.musicProcessorNode?.port.postMessage(0);\n  }\n\n  pause() {\n    this.musicProcessorNode?.port.postMessage(1);\n  }\n\n  unpause() {\n    this.musicProcessorNode?.port.postMessage(2);\n  }\n\n  stop() {\n    if (this.isPlaying) {\n      this.musicProcessorNode?.disconnect();\n      this.isPlaying = false;\n    }\n  }\n}\n\nexport default new MusicPlayer();\n","import { State } from '@/core/state';\nimport { drawEngine } from '@/core/draw-engine';\nimport { Player } from '@/game/entities/player';\nimport { GameMap } from '@/game/game-map';\nimport { HUD } from '@/game/hud';\nimport { Actions } from '@/game/actions';\nimport { GameData } from '@/game/game-data';\nimport { GameStory } from '@/game/game-story';\nimport { addTimeEvent, updateTimeEvents } from '@/core/timer';\nimport musicPlayer from '@/core/music-player';\nimport { clearEvents, emit, on } from '@/core/event';\nimport { GameEvent } from '@/game/event-manifest';\nimport { gameStateMachine } from '@/game-state-machine';\nimport { menuState } from './menu.state';\nimport { MAX_LIVES } from '@/game/constants';\nimport { GameAssets } from '@/game/game-assets';\nimport { highRepair } from '@/core/audio';\nimport { MagicCircleAnimation } from '@/game/entities/magic-animation';\n\nexport class GameState implements State {\n  map!: GameMap;\n  cat!: Player;\n  hud!: HUD;\n  actions!: Actions;\n  gameData!: GameData;\n  story!: GameStory;\n  playMusic = true;\n  zoomOffset = 0;\n  cameraFollowsCat = true;\n  cameraPos: {x: number, y:number} = {x:0, y:0};\n\n  onLeave() {\n    musicPlayer.stop();\n    drawEngine.ctx4.clearRect(0, 0, c4.width, c4.height);\n    clearEvents();\n  }\n\n  onEnter() {\n    if (this.playMusic) {\n      musicPlayer.start();\n    }\n    \n    on(GameEvent.ENABLE_SCRATCH, () => {\n      musicPlayer.startMelody();\n    });\n    on(GameEvent.PAUSE, () => {\n      musicPlayer.pause();\n    });\n    on(GameEvent.UNPAUSE, () => {\n      musicPlayer.unpause();\n    });\n\n    on(GameEvent.GAME_OVER, () => {\n      addTimeEvent(() => gameStateMachine.setState(menuState), 3000);\n    });\n\n    on(GameEvent.FADE_OUT, () => {\n      addTimeEvent(() => gameStateMachine.setState(menuState), 6000);\n    });\n\n    on(GameEvent.END_SEQUECE_START, () => {\n      // Final statue camera pan\n      const interval = 3000;\n      const delay = 1000;\n      musicPlayer.pause();\n\n      // Turn each statue golden and exorcise all spirits\n      this.map.statues.forEach((statue, i) => {\n        addTimeEvent(() => {\n          this.cameraFollowsCat = false;\n          this.cameraPos = { x: statue.x, y: statue.y};\n          drawEngine.setCamera(this.cameraPos.x, this.cameraPos.y, 5, true);\n          addTimeEvent(() => {\n            statue.img = GameAssets.statueGold;\n            statue.maxSpirits = -99;\n            statue.spirits.forEach(spirit => spirit.takeDamage(spirit.hp));\n            highRepair(i);\n          }, interval * 0.5);\n        }, delay + interval * i);\n      });\n\n      // Turn the obelisk golden\n      addTimeEvent(() => {\n        this.cameraFollowsCat = false;\n        const obelisk = this.map.obelisk;\n        this.cameraPos = { x: obelisk.x, y: obelisk.y};\n        drawEngine.setCamera(this.cameraPos.x, this.cameraPos.y, 5, true);\n\n        let time = interval * 1.5;\n        addTimeEvent(() => {\n          obelisk.img = GameAssets.obeliskGold;\n          let repeat = 0;\n          addTimeEvent(() => {\n            highRepair(this.map.statues.length + (repeat++));\n          }, 250, 4);\n        }, time);\n        time += 250 * 4;\n        addTimeEvent(() => {\n          obelisk.startAnimation();\n        }, time);\n        time += MagicCircleAnimation.animationDuration * 2;\n        addTimeEvent(() => {\n          musicPlayer.start();\n        }, time);\n        addTimeEvent(() => {\n          emit(GameEvent.GAME_END);\n        }, time);\n      }, delay + interval * this.map.statues.length);\n    });\n\n    // DEBUG: force statue final camera pan\n    // addTimeEvent(() => {\n    //   emit(GameEvent.END_SEQUECE_START);\n    // }, 5000);\n\n    this.gameData = new GameData();\n    this.map = new GameMap(160, 160, this.gameData);\n    this.cat = new Player(60, 85, this.map, this.gameData);\n    // this.cat = new Player(94, 133, this.map, this.gameData);\n    this.actions = new Actions(this.map, this.cat);\n    this.hud = new HUD(this.map, this.cat, this.actions, this.gameData);\n    this.story = new GameStory();\n    \n    this.map.set(this.cat.col, this.cat.row, this.cat);\n    drawEngine.setCamera(this.cat.x, this.cat.y, 20, true);\n    drawEngine.cameraLerpSpeed = 0.01;\n  }\n\n  onUpdate(timeElapsed: number) {\n    const zoom = 5 + this.zoomOffset + (MAX_LIVES - this.gameData.lives) / MAX_LIVES;\n    \n    if (this.cameraFollowsCat) {\n      drawEngine.setCamera(this.cat.x, this.cat.y, zoom);\n      this.cameraPos = { x: this.cat.x, y: this.cat.y };\n    } else {\n      drawEngine.cameraLerpSpeed = 0.01;\n      drawEngine.setCamera(this.cameraPos.x, this.cameraPos.y, 7);\n    }\n    drawEngine.updateCamera();\n\n    if (this.gameData.lives > 0) {\n      if (!this.gameData.cutscene) {\n        this.actions.update();\n      }\n      this.map.update(timeElapsed, this.gameData.cutscene);\n      this.hud.update(timeElapsed);\n      this.gameData.update(timeElapsed);\n    }\n    this.story.update(timeElapsed);\n    updateTimeEvents(timeElapsed);\n\n    if (this.gameData.lives > 0 && !this.gameData.win) {\n      this.map.draw(this.cameraPos.x, this.cameraPos.y);\n      this.hud.draw();\n    } else {\n      if (this.gameData.lives > 0) {\n        this.hud.draw();\n      }\n      this.cat.update(timeElapsed);\n      this.cat.draw();\n    }\n    drawEngine.resetCamera();\n  }\n}\n","import { State } from '@/core/state';\nimport { drawEngine } from '@/core/draw-engine';\nimport { controls } from '@/core/controls';\nimport { gameStateMachine } from '@/game-state-machine';\nimport { GameState } from './game.state';\nimport { colors } from '@/core/util/color';\nimport { GameAssets } from '@/game/game-assets';\nimport { SeededRandom } from '@/core/util/rng';\n\nconst toggleFullscreen = () => {\n  if (!document.fullscreenElement) {\n    document.documentElement.requestFullscreen();\n  } else {\n    document.exitFullscreen();\n  }\n};\n\nconst rng = new SeededRandom(0);\n\nconst drawBackground = () => {\n  const bgColors = [\n    colors.blue4,\n    colors.blue3,\n    colors.blue2,\n    colors.blue1,\n    colors.blue0,\n  ];\n  const sectionHeight = Math.ceil(c2.height / bgColors.length);\n  const sections = 32;\n  const sectionW = c2.width / sections;\n  const offsetFreq = 4;\n  const offsetAmplitude = 16;\n  for (let index = 0; index < sections; index++) {\n    const yOffset = Math.round(\n      offsetAmplitude * Math.sin(1 - offsetFreq * 2 * Math.PI * index / sections)\n      / 10\n    ) * 10;\n    bgColors.forEach((color, row) => {\n      drawEngine.ctx1.fillStyle = color;\n      drawEngine.ctx1.fillRect(\n        sectionW * index,\n        yOffset + sectionHeight * row - 20,\n        Math.ceil(c2.width / sections),\n        sectionHeight\n      );\n    });\n  }\n\n  const iconSize = 32;\n  const iconInterval = 22;\n  const cols = c2.width / iconInterval;\n  const rows = (c2.height / 2) / iconInterval; // fill half the screen\n  const oak: HTMLImageElement = GameAssets.oak;\n  const spruce: HTMLImageElement = GameAssets.spruce;\n\n  if (!oak) {\n    return;\n  }\n\n  for (let col = 0; col <= cols + iconSize; col++) {\n    const mountainHeight = rows * (1.2 - Math.cos((col / cols) * 2 * Math.PI));\n    for(let row = mountainHeight; row > 0; row--) {\n      const offsetX = 5 * Math.sin(12 * Math.PI * (row / rows));\n      drawEngine.drawBackgroundImage(\n        0.2 + rng.next() > (row / (rows)) ? oak : spruce,\n        col * iconInterval + offsetX - iconSize/2,\n        c2.height - (row * iconInterval + rng.next() * 0.7) / 2,\n        false,\n        iconSize,\n        iconSize,\n      );\n    }\n  }\n\n  rng.rngSeed = 0;\n};\n\nclass MenuState implements State {\n  animationTimer = 0;\n  previousFPressed = false;\n\n  onUpdate(timeElapsed: number) {\n    this.animationTimer += timeElapsed;\n\n    drawBackground();\n    const xCenter = drawEngine.ctx2.canvas.width / 2;\n    drawEngine.drawText(\n      'Meow Mountain',\n      xCenter,\n      100,\n      colors.blue0,\n      1, // center\n      0, // top\n      15\n    );\n    drawEngine.drawText(\n      'Press Enter to start',\n      xCenter,\n      230,\n      colors.white,\n      1, // center\n      0, // top\n      4\n    );\n    drawEngine.drawText(\n      'Press F to toggle fullscreen',\n      xCenter,\n      280,\n      colors.blue4,\n      1, // center\n      0, // top\n      4\n    );\n    this.updateControls();\n  }\n\n  updateControls() {\n    if (controls.isConfirm && !controls.previousState.isConfirm) {\n      gameStateMachine.setState(new GameState());\n    }\n\n    const fPressed = Boolean(controls.keyMap.get('KeyF'));\n    if (fPressed && !this.previousFPressed) {\n      toggleFullscreen();\n    }\n    this.previousFPressed = fPressed;\n  }\n};\n\nexport const menuState = new MenuState();\n","import { createGameStateMachine, gameStateMachine } from './game-state-machine';\nimport { controls } from '@/core/controls';\nimport { drawEngine } from './core/draw-engine';\nimport { updateTimeEvents } from './core/timer';\nimport { menuState } from './game-states/menu.state';\nimport { emit } from './core/event';\nimport { GameEvent } from './game/event-manifest';\n\n// @ts-ignore -- is not undefined for sure\ndocument.querySelector('link[type=\"image/x-icon\"]').href = 'data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 100 100\\'%3E%3Ctext y=\\'.9em\\' font-size=\\'85\\'%3E💜%3C/text%3E%3C/svg%3E';\n\nlet previousTime = 0;\n// let fpsBacklog: number[] = [];\nlet paused = false;\n\nwindow.addEventListener('blur', () => {\n  emit(GameEvent.PAUSE);\n  paused = true;\n});\nwindow.addEventListener('focus', () => {\n  emit(GameEvent.UNPAUSE);\n  paused = false;\n});\n\nfunction update(currentTime: number) {\n  if (paused) return;\n\n  currentTime = performance.now();\n  let delta = currentTime - previousTime;\n  previousTime = currentTime;\n  if (delta > 1000) {\n    return;\n  }\n    \n  // fpsBacklog.push(1000 / delta);\n  // if (fpsBacklog.length === 15) {\n  //   fps.innerHTML = `${Math.round(fpsBacklog.reduce((a, b) => a + b) / 15)} FPS`;\n  //   fpsBacklog = [];\n  // }\n\n  drawEngine.clear();\n\n  const state = gameStateMachine.getState();\n  controls.queryController();\n  state.onUpdate(delta);\n  updateTimeEvents(delta);\n};\n\n\ncreateGameStateMachine(menuState);\nsetInterval(update, 16);\n","import { State } from './state';\n\nexport class StateMachine {\n  private currentState: State;\n\n  constructor(initialState: State, ...enterArgs: any) {\n    this.currentState = initialState;\n    this.currentState.onEnter?.(...enterArgs);\n  }\n\n  setState(newState: State, ...enterArgs: any) {\n    this.currentState.onLeave?.();\n    this.currentState = newState;\n    this.currentState.onEnter?.(...enterArgs);\n  }\n\n  getState() {\n    return this.currentState;\n  }\n}\n"],"names":["addTimeEvent","callback","time","repeat","delay","timeEvents","push","timeLeft","updateTimeEvents","delta","i","length","timeEvent","splice","updatePositionSmoothly","state","timeElapsed","axis","targetPos","d","step","Math","sign","speed","abs","moving","round","gameStateMachine","controls","constructor","this","isUp","isDown","isLeft","isRight","isConfirm","isAction1","isMoving","keyMap","Map","previousState","document","addEventListener","event","toggleKey","inputDirection","DOMPoint","queryController","leftVal","get","rightVal","upVal","downVal","x","y","isPressed","set","code","getCtx","canvas","getContext","createCanvasWithCtx","w","h","c","createElement","width","height","createCanvas","quantizeToPalette","r","g","b","a","emojiToPixelArt","emoji","fontSize","spriteSize","floor","padding","_","tmpCtx","font","textBaseline","clearRect","translate","fillText","data","getImageData","outImg","createImageData","outData","outCanvas","outCtx","putImageData","img","Image","src","toDataURL","generateImageData","icon","iconPalette","transparent","palette","colorsPerByte","bytesPerColor","bitMask","size","sqrt","setAttribute","ctx","imgData","map","z","charCodeAt","bit","paletteIndex","hex","replace","parseInt","substring","NewTileset","spriteSheet","animations","tileSize","animationName","frames","Object","entries","frameData","colors","cat","villager","statue","obelisk","oak","spruce","grass","house","ground","split","e","GameAssets","initialize","cornerImage","cornerColor","fillStyle","fillRect","createCornerImage","goldPalette","statueGold","obeliskGold","tinyFont","characterCanvases","MAGIC","getCharacterData","letter","paddedBinary","leftmostCol","charWidth","toString","String","padStart","rightmostCol","col","row","min","max","makeCircle","centerX","centerY","radiusX","radiusY","skew","normalizedY","halfWidth","offset","rect","DrawEngine","canvasWidth","canvasHeight","cameraX","cameraY","zoom","targetCameraX","targetCameraY","targetZoom","cameraLerpSpeed","ctx1","c1","ctx2","c2","ctx3","c3","ctx4","c4","resizeCanvas","window","ctxs","imageSmoothingEnabled","drawCircumference","color","strokeWidth","save","beginPath","clip","fill","restore","drawText","text","textAlign","space","context","spacing","characters","toUpperCase","totalWidth","charPositions","forEach","character","char","letterHeight","offsetX","offsetY","charX","cacheKey","V","N","W","scaledWidth","match","bitIndex","adjustedCol","createCharacterCanvas","getCharacterCanvas","drawImage","mirrored","imgWidth","imgWeight","scale","drawBackgroundImage","imgHeight","setCamera","immediate","cx","cy","setTransform","updateCamera","resetCamera","clear","worldToScreen","worldX","worldY","drawEngine","CELL_WIDTH","CELL_HEIGHT","MAX_REPAIR","paths","clearings","statues","heart","name","moon","ear","eye","foot","tail","GameObject","tileset","type","animation","animationTime","animationFrame","aD","animationLoop","ceil","random","setPos","update","draw","listeners","on","listener","eventName","handler","detail","emit","dispatchEvent","CustomEvent","linePixels","x0","y0","x1","y1","pixels","e2","dx","sx","dy","sy","err","PentagramAnimation","animationDone","pentagramRotation","PI","radius","elapsed","trailLength","cycles","maxCycles","active","points","angle","cos","sin","pentagramVertices","allPixels","totalDuration","newOffset","effectiveTrailLength","idx","isActive","forEachSurroundingCell","centerCol","centerRow","includeCenter","deltaRow","deltaCol","audioCtx","playSound","f","AudioContext","m","createBuffer","getChannelData","s","createBufferSource","buffer","connect","destination","start","n","repair","pitch","exp","highRepair","phase","pow","Player","gameData","super","sleeping","sitting","attacking","scared","inVillage","pentagramAttack","stepSoundTimer","sittingTimer","playerLookingAt","updateAnimation","cellVillage","grid","village","coords","innerText","cutscene","isSurrounded","newRow","content","newCol","autoSelectTarget","attackAllEnemiesAround","attackEnemyInFront","cell","takeDamage","spiritCount","currentCell","getLookingAt","directions","facing","spiritTarget","statueTarget","spiritFacing","statueFacing","dir","contentType","GameStaticObject","Tree","treeType","neighbors","top","bottom","left","right","setNeighbors","SeededRandom","rngSeed","next","range","House","Villager","lastDirection","moveTimer","moveInterval","isScared","seesCat","takeNextStep","isValidMove","checkCol","checkRow","Farm","Village","center","houseCount","population","houses","farms","villagers","generatePosition","rng","existing","distance","some","item","generateHouses","pos","generateFarms","farmCount","generateVillagers","Icon","toKey","reconstructPath","parents","goal","path","current","unshift","defaultColors","drawHpBar","hp","maxHp","colorHP","hpWidth","barX","barY","spirits","reduce","acc","index","level","Spirit","opacity","searchRadius","dead","recoil","attackTimer","attackDuration","attackTarget","attackOffsetX","attackOffsetY","species","playerCoords","lookAroundForPlayer","moveTowardsPlayer","updateAttack","progress","dirX","dirY","windProgress","attackProgress","restProgress","searchCol","searchRow","maxSteps","steps","queue","visited","Set","shift","neighbour","has","add","findShortestPath","nextStep","globalAlpha","filter","damage","exorcise","MagicCircleAnimation","animationTimer","isDone","animationDuration","animationProgress","maxWidth","maxHeight","Statue","maxSpirits","spawnTimer","spawnInterval","spawnChance","spawnRadius","State","BROKEN","spiritsExorcised","lastClearTime","magicCircleAnimation","REPAIRED","ANIMATING","getLevel","spawnSpirit","replaceSpirit","spirit","drawFaries","postDraw","clearCircleWithJitter","t","theta","offsetDist","emptyCells","selectedPosition","spiritTypes","values","randomType","Obelisk","startAnimation","attemptRepair","GameMap","colCount","rowCount","villages","Array","from","_a","_b","tree","clearPathWithJitter","clearing","farm","fillCenterWithGrass","statueProps","farmCol","farmRow","clearPlants","converage","heartsPeak","villagePath","to","pathWidth","jitterAmount","jitterX","jitterY","ox","oy","clearX","clearY","fieldsOnly","border","probability","adjustedRadius","clearProbability","isCutscene","renderWidth","renderHeight","minCol","maxCol","minRow","maxRow","postDrawDrawables","drawHighlight","seenRadius","seen","drawable","easeInOutSine","pixelColors","field","unseen","default","MiniMap","lastUpdate","updateInterval","player","mapSize","my","mx","arc","DialogBox","dialog","boxHeight","margin","boxWidth","HUD","actions","renderSuperstition","renderLives","renderMagic","villageName","villageNameTimer","miniMap","dialogBox","drawLives","drawMagic","drawGoals","drawSuperstition","drawActions","drawInfoBox","enabled","startX","symbol","fullHearts","lives","emptyHearts","halfHearts","partialHearts","boxW","fullMagic","magic","emptyMagic","maxMagic","noMagic","MAX_MAGIC","goals","label","boxY","NOTIFICATION_DURATION","boxH","superstition","drawInfo","Actions","cellInFront","canTeleport","canRestore","canSleep","canAttack","doRestore","object","GameData","hasClearedIntro","win","scene","q","heal","Story","script","currentStateKey","currentDialogIndex","previousSpacePressed","currentState","fullText","visibleCharacters","textAnimationTimer","charactersPerSecond","textAnimationState","stateKey","enterState","showCurrentDialog","spacePressed","spaceJustPressed","targetCharacters","emitCurrentVisibleText","handleSpacePress","dialogs","exitCurrentState","visibleText","postIntro","GameStory","story","magicLevel","setTimeout","musicPlayer","startTime","isPlaying","audioContext","webkitAudioContext","resume","audioWorklet","addModule","musicProcessorNode","AudioWorkletNode","startMelody","port","postMessage","pause","unpause","stop","disconnect","GameState","playMusic","zoomOffset","cameraFollowsCat","cameraPos","onLeave","Tt","Dt","removeEventListener","clearEvents","onEnter","setState","menuState","interval","hud","onUpdate","previousFPressed","bgColors","sectionHeight","sectionW","yOffset","offsetFreq","cols","rows","iconSize","drawBackground","xCenter","updateControls","fPressed","fullscreenElement","exitFullscreen","documentElement","requestFullscreen","querySelector","href","previousTime","paused","initialState","enterArgs","newState","getState","createGameStateMachine","setInterval","currentTime","performance","now"],"mappings":"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"}