{"version":3,"file":"index-B8KgBOKs.js","sources":["../../src/core/timer.ts","../../src/utils/smooth-movement.ts","../../src/game-state-machine.ts","../../src/core/controls.ts","../../src/core/util/canvas.ts","../../src/core/emoji.ts","../../src/game/sprite-loader.ts","../../src/core/tileset.ts","../../src/core/util/color.ts","../../src/game/sprites.ts","../../src/game/game-assets.ts","../../src/core/util/image-generator.ts","../../src/core/font.ts","../../src/core/draw-engine.ts","../../src/game/constants.ts","../../src/core/game-object.ts","../../src/core/event.ts","../../src/game/entities/pentagram-attack.ts","../../src/game/grid-utils.ts","../../src/core/audio.ts","../../src/game/entities/player.ts","../../src/core/game-static-object.ts","../../src/game/entities/tree.ts","../../src/core/util/rng.ts","../../src/game/entities/house.ts","../../src/game/entities/villager.ts","../../src/game/entities/farm.ts","../../src/game/entities/village.ts","../../src/game/entities/icon.ts","../../src/game/path-findind.ts","../../src/game/entities/hp-bar.ts","../../src/game/entities/spirit.ts","../../src/game/entities/magic-animation.ts","../../src/game/entities/statue.ts","../../src/game/entities/obelisk.ts","../../src/game/game-map.ts","../../src/core/util/util.ts","../../src/game/mini-map.ts","../../src/game/dialog-box.ts","../../src/game/hud.ts","../../src/game/actions.ts","../../src/game/game-data.ts","../../src/core/story-engine.ts","../../src/game/game-story.ts","../../src/core/music-player.ts","../../src/game-states/game.state.ts","../../src/game-states/menu.state.ts","../../src/index.ts","../../src/core/state-machine.ts"],"sourcesContent":["type TimeEventHandler = {\n  callback: (() => void)\n  time: number\n  timeLeft: number\n  repeat: number\n}\n\nlet timeEvents: TimeEventHandler[] = [];\n\nexport function addTimeEvent (callback: () => void, time: number, repeat = 0, delay = 0) {\n  timeEvents.push({callback, time, timeLeft: time + delay, repeat});\n}\n\nexport function clearTimers() {\n  timeEvents = [];\n}\n\n/**\n * Updates the time events, checking if any should be executed.\n * @param delta The time in milliseconds since the last update.\n */\nexport function updateTimeEvents(delta: number) {\n  for (let i = timeEvents.length - 1; i >= 0; i--) {\n    const timeEvent = timeEvents[i];\n    if (!timeEvent) {\n      return;\n    }\n    timeEvent.timeLeft -= delta;\n    if (timeEvent.timeLeft <= 0) {\n      timeEvent.callback();\n\n      if (timeEvent.repeat-- <= 0) {\n        timeEvents.splice(i, 1); // Remove the executed event\n      } else {\n        timeEvent.timeLeft = timeEvent.time;\n      }\n    }\n  }\n}\n","import { CELL_WIDTH, CELL_HEIGHT } from '../game/constants';\n\nexport interface SmoothMovementState {\n  x: number;\n  y: number;\n  targetPos: { x: number; y: number };\n  moving: { x: number; y: number };\n  speed: number;\n}\n\n/**\n * Updates position smoothly towards target position using linear interpolation\n * @param state Object containing position, target, and movement state\n * @param timeElapsed Time elapsed since last update in milliseconds\n */\nexport function updatePositionSmoothly(state: SmoothMovementState, timeElapsed: number): void {\n  for (const axis of ['x', 'y'] as const) {\n    if (state[axis] !== state.targetPos[axis]) {\n      const d = state.targetPos[axis] - state[axis];\n      const step = Math.sign(d) * state.speed * timeElapsed / 1000;\n      if (Math.abs(step) >= Math.abs(d)) {\n        state[axis] = state.targetPos[axis];\n      } else {\n        state[axis] += step;\n      }\n    } else {\n      state.moving[axis] = 0;\n      state[axis] = Math.round(state[axis]);\n    }\n  }\n}\n\n/**\n * Sets target position in pixel coordinates based on grid cell coordinates\n * @param state Movement state object\n * @param col Grid column\n * @param row Grid row\n */\nexport function setTargetPosition(state: SmoothMovementState, col: number, row: number): void {\n  state.targetPos.x = col * CELL_WIDTH;\n  state.targetPos.y = row * CELL_HEIGHT;\n}\n\n/**\n * Moves towards a target grid position if the move is valid\n * @param state Movement state object\n * @param targetCol Target column\n * @param targetRow Target row\n * @param currentCol Current column (will be updated)\n * @param currentRow Current row (will be updated)\n * @param isValidMove Function to check if move is valid\n * @returns true if movement was initiated, false otherwise\n */\nexport function moveToGridPosition(\n  state: SmoothMovementState,\n  targetCol: number,\n  targetRow: number,\n  currentCol: { value: number },\n  currentRow: { value: number },\n  isValidMove: (col: number, row: number) => boolean\n): boolean {\n  if (!isValidMove(targetCol, targetRow)) {\n    return false;\n  }\n\n  // Calculate movement direction\n  const deltaCol = targetCol - currentCol.value;\n  const deltaRow = targetRow - currentRow.value;\n\n  // Update grid position\n  currentCol.value = targetCol;\n  currentRow.value = targetRow;\n\n  // Set movement direction\n  state.moving.x = Math.sign(deltaCol);\n  state.moving.y = Math.sign(deltaRow);\n\n  // Set target pixel position\n  setTargetPosition(state, targetCol, targetRow);\n\n  return true;\n}\n","import { StateMachine } from './core/state-machine';\nimport { State } from './core/state';\n\nexport let gameStateMachine: StateMachine;\n\nexport function createGameStateMachine(initialState: State, ...initialArguments: any[]) {\n  gameStateMachine = new StateMachine(initialState, ...initialArguments);\n}\n","const enum XboxControllerButton {\n  A,\n  B,\n  X,\n  Y,\n  LeftBumper,\n  RightBumper,\n  LeftTrigger,\n  RightTrigger,\n  Select,\n  Start,\n  L3,\n  R3,\n  DpadUp,\n  DpadDown,\n  DpadLeft,\n  DpadRight,\n}\n\nclass Controls {\n  isUp = false;\n  isDown = false;\n  isLeft = false;\n  isRight = false;\n  isConfirm = false;\n  isEscape = false;\n  isAction1 = false;\n  isMoving = false;\n  inputDirection: DOMPoint;\n\n  keyMap: Map<string, boolean> = new Map();\n  previousState = {\n    isUp: this.isUp,\n    isDown: this.isDown,\n    isConfirm: this.isConfirm,\n    isEscape: this.isEscape,\n    isAction1: this.isAction1,\n  };\n\n  constructor() {\n    document.addEventListener('keydown', event => this.toggleKey(event, true));\n    document.addEventListener('keyup', event => this.toggleKey(event, false));\n    this.inputDirection = new DOMPoint();\n  }\n\n  queryController() {\n    this.previousState.isUp = this.isUp;\n    this.previousState.isDown = this.isDown;\n    this.previousState.isConfirm = this.isConfirm;\n    this.previousState.isEscape = this.isEscape;\n    this.previousState.isAction1 = this.isAction1;\n    const gamepad = navigator.getGamepads()[0];\n    const isButtonPressed = (button: XboxControllerButton) => !!gamepad?.buttons[button].pressed;\n\n    const leftVal = (\n      this.keyMap.get('KeyA')\n      || this.keyMap.get('KeyQ')\n      || this.keyMap.get('ArrowLeft') // for AZERTY\n      || isButtonPressed(XboxControllerButton.DpadLeft)\n    ) ? -1 : 0;\n    const rightVal = (\n      this.keyMap.get('KeyD')\n      || this.keyMap.get('ArrowRight')\n      || isButtonPressed(XboxControllerButton.DpadRight)\n    ) ? 1 : 0;\n    const upVal = (\n      this.keyMap.get('KeyW')\n      || this.keyMap.get('KeyZ') // for AZERTY\n      || this.keyMap.get('ArrowUp')\n      || isButtonPressed(XboxControllerButton.DpadUp)\n    ) ? -1 : 0;\n    const downVal = (\n      this.keyMap.get('KeyS')\n      || this.keyMap.get('ArrowDown')\n      || isButtonPressed(XboxControllerButton.DpadDown)\n    ) ? 1 : 0;\n    this.inputDirection.x = (leftVal + rightVal) || 0;\n    this.inputDirection.y = (upVal + downVal) || 0;\n\n    const deadzone = 0.1;\n    if (Math.hypot(this.inputDirection.x, this.inputDirection.y) < deadzone) {\n      this.inputDirection.x = 0;\n      this.inputDirection.y = 0;\n    }\n\n    this.isUp = this.inputDirection.y < 0;\n    this.isDown = this.inputDirection.y > 0;\n    this.isLeft = this.inputDirection.x < 0;\n    this.isRight = this.inputDirection.x > 0;\n    this.isMoving = this.inputDirection.x !== 0 || this.inputDirection.y !== 0;\n    this.isConfirm = Boolean(this.keyMap.get('Enter')) || isButtonPressed(XboxControllerButton.Start);\n    this.isEscape = Boolean(this.keyMap.get('Escape')) || isButtonPressed(XboxControllerButton.Select);\n    this.isAction1 = Boolean(this.keyMap.get('Space')) || isButtonPressed(XboxControllerButton.A);\n  }\n\n  private toggleKey(event: KeyboardEvent, isPressed: boolean) {\n    this.keyMap.set(event.code, isPressed);\n  }\n}\n\nexport const controls = new Controls();\n","/* eslint-disable id-denylist */\n// Canvas creation and context helpers for bundle size optimization\n\nexport const createCanvas = (w?: number, h?: number) => {\n  const c = document.createElement('canvas');\n  if (w) c.width = w;\n  if (h) c.height = h;\n  return c;\n};\n\nexport const getCtx = (canvas: HTMLCanvasElement) => canvas.getContext('2d')!;\n\nexport const createCanvasWithCtx = (w?: number, h?: number) => {\n  const canvas = createCanvas(w, h);\n  return [canvas, getCtx(canvas)] as const;\n};\n\nexport const setCanvasSize = (canvas: HTMLCanvasElement, w: number, h: number) => {\n  canvas.width = w;\n  canvas.height = h;\n};\n","import { createCanvasWithCtx } from './util/canvas';\n\n/**\n * Quantizes rgba color values to 8bit.\n */\nconst quantizeToPalette = (r: number, g: number, b: number, a: number) => {\n  // 1-bit transparency\n  if (a < 128) {\n    return [0, 0, 0, 0]; // transparent\n  }\n  const qr = Math.round(r / 51) * 51;\n  const qg = Math.round(g / 51) * 51;\n  const qb = Math.round(b / 51) * 51;\n\n  return [qr, qg, qb, 255];\n};\n\n/**\n * Converts an emoji to a pixelated image by quantizing the colors\n * to 8 bit and the transparency to 1 bit.\n */\nexport const emojiToPixelArt = (\n  emoji: string,\n  fontSize = 10,\n) => {\n  // Some emoji are a bit bigger than the font\n  const spriteScale = 0.25;\n  const spriteSize = Math.floor(fontSize * (1 + spriteScale));\n  const padding = Math.floor(fontSize * spriteScale / 2);\n\n  // Create temporary canvas\n  const [_, tmpCtx] = createCanvasWithCtx(spriteSize, spriteSize);\n\n  // Draw emoji in chosen font size\n  tmpCtx.font = `${fontSize}px sans-serif`;\n  tmpCtx.textBaseline = 'top';\n  tmpCtx.clearRect(0, 0, spriteSize, spriteSize);\n  tmpCtx.translate(-1, 0);\n  tmpCtx.fillText(emoji, padding, padding);\n\n  // Read pixels\n  const imgData = tmpCtx.getImageData(0, 0, spriteSize, spriteSize);\n  const data = imgData.data;\n\n  // Create new image data with quantized colors\n  const outImg = tmpCtx.createImageData(spriteSize, spriteSize);\n  const outData = outImg.data;\n  for (let i = 0; i < data.length; i += 4) {\n    const [r, g, b, a] = quantizeToPalette(\n      data[i],      // red\n      data[i + 1],  // green\n      data[i + 2],  // blue\n      data[i + 3],  // alpha\n    );\n    outData[i] = r;\n    outData[i + 1] = g;\n    outData[i + 2] = b;\n    outData[i + 3] = a;\n  }\n\n  // Create a new canvas to draw the quantized image\n  const [outCanvas, outCtx] = createCanvasWithCtx(spriteSize, spriteSize);\n  outCtx.putImageData(outImg, 0, 0);\n\n  // Create an image element from the canvas\n  const img = new Image();\n  img.src = outCanvas.toDataURL();\n  return img;\n};\n\n\n// const ctx = c.getContext(\"2d\");\n// ctx.imageSmoothingEnabled = false;\n\n\n// const font = 8;\n// const spriteSize = Math.floor(font * 1.25); // must match function logic\n\n// const emojis = ['🔥','🍀','🌼','🐓','🌷','🌹','👻','🥚','🍎'];\n\n// emojis.forEach((emoji, i) => {\n//   const col = i % (100 / spriteSize);       // column in grid\n//   const row = Math.floor(i / (100 / spriteSize)); // row in grid\n//   const x = col * spriteSize;\n//   const y = row * spriteSize;\n\n//   emojiToPixelArt(emoji, ctx, font, x, y);\n// });\n","export const generateImageData = (icon: string, iconPalette: string[]): HTMLImageElement => {\n  const transparent = '#FF00FF';\n  const palette = [transparent, ...iconPalette];\n  \n  const colorsPerByte = palette.length > 4 ? 2 : palette.length > 2 ? 3 : 6;\n  const bytesPerColor = 6 / colorsPerByte;\n  const bitMask = (1 << bytesPerColor) - 1;\n  const canvas = document.createElement('canvas');\n  const size = Math.sqrt(icon.length * colorsPerByte);\n  canvas.setAttribute('width', size.toString());\n  canvas.setAttribute('height', size.toString());\n  const ctx = canvas.getContext('2d')!;\n  const imgData = ctx.createImageData(size, size);\n  const data = imgData.data;\n  \n  let i = 0;\n  [...icon].map(c => {\n    const z = c.charCodeAt(0);\n\n    for (let bit = 0; bit < colorsPerByte; bit++) {\n      const paletteIndex = (z >> bit * bytesPerColor) & bitMask;\n      const hexColor = palette[paletteIndex] || transparent;\n      \n      // Convert hex to RGB\n      const hex = hexColor.replace('#', '');\n      const r = parseInt(hex.substring(0, 2), 16);\n      const g = parseInt(hex.substring(2, 4), 16);\n      const b = parseInt(hex.substring(4, 6), 16);\n      const a = paletteIndex ? 255 : 0;\n      \n      data[i] = r;\n      data[i + 1] = g;\n      data[i + 2] = b;\n      data[i + 3] = a;\n      i += 4;\n    }\n  });\n\n  \n  ctx.putImageData(imgData, 0, 0);\n  const img = new Image();\n  img.src = canvas.toDataURL();\n  return img;\n};\n","import { generateImageData } from '@/game/sprite-loader';\n\nexport class NewTileset<T extends string | number> {\n  public animations: Record<T, HTMLImageElement[]> = {} as Record<T, HTMLImageElement[]>;\n  public tileSize = 16;\n\n  constructor(\n    public spriteSheet: { size: number, palette: string[]; data: Record<T, string[]> },\n  ) {\n    // Process each animation (sit, idle, walk, run, etc.)\n    for (const [animationName, frames] of Object.entries(spriteSheet.data) as [T, string[]][]) {\n      this.animations[animationName] = frames.map((frameData: string) => \n        generateImageData(frameData, spriteSheet.palette)\n      );\n    }\n    this.tileSize = spriteSheet.size;\n  }\n}\n","export const hexToRgb = (hex: string) : number[] => {\n  // @ts-ignore\n  return hex.replace(\n    /^#?([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n    (_, r, g, b, a) => '#' + r + r + g + g + b + b + a + a)\n    .substring(1)\n    .match(/.{2}/g)\n    .map(x => parseInt(x, 16)\n  );\n};\n\n\nexport type Color =\n'green0' | \n'green1' | \n'green2' | \n'green3' | \n'green4' | \n'green5' | \n'green6' | \n'blue0' | \n'blue1' | \n'blue2' | \n'blue3' | \n'blue4' | \n'blue5' | \n'blue6' | \n'purple0' | \n'purple1' | \n'purple2' | \n'purple3' | \n'purple4' | \n'purple5' | \n'yellow0' | \n'yellow1' | \n'yellow2' | \n'black' | \n'white';\n\n// export const colors: Record<Color, string> = new Proxy({}, {\n//   get: (_, prop: string) => {\n//     if (typeof window === 'undefined' || typeof document === 'undefined') return '';\n//     const value = getComputedStyle(document.documentElement).getPropertyValue(`--${prop}`);\n//     return value.trim() || '';\n//   }\n// });\n\n// function getColorsFromCSS() {\n//   const root = document.documentElement;\n//   const computedStyle = getComputedStyle(root);\n  \n//   const colorKeys = [\n//     'green0', 'green1', 'green2', 'green3',\n//     'blue0', 'blue1', 'blue2', 'blue3', 'blue4', 'blue5', 'blue6',\n//     'purple0', 'purple1', 'purple2', 'purple3', 'purple4', 'purple5',\n//     'yellow0', 'yellow1', 'yellow2',\n//     'black', 'white'\n//   ];\n  \n//   const colors = {};\n//   colorKeys.forEach((key: string) => {\n//     // @ts-expect-error\n//     colors[key] = computedStyle.getPropertyValue(`--${key}`).trim();\n//   });\n  \n//   return colors;\n// }\n\nexport const colors: Record<Color, string> = {\n  green0: '#b3d7ad',\n  green1: '#9dc4a0',\n  green2: '#89b290',\n  green3: '#75a080',\n  green4: '#618e70',\n  green5: '#4d7c60',\n  green6: '#396a50',\n  blue0: '#b4ecf3',\n  blue1: '#4e9ca6',\n  blue2: '#3e8791',\n  blue3: '#2f6269',\n  blue4: '#255056',\n  blue5: '#1f4347',\n  blue6: '#13282b',\n  purple0: '#e0b8d3',\n  purple1: '#d49bc2',\n  purple2: '#b34d92',\n  purple3: '#551641',\n  purple4: '#714162',\n  purple5: '#996a8a',\n  yellow0: '#fffef9',\n  yellow1: '#f2daab',\n  yellow2: '#e6a386',\n  black: '#13282b',\n  white: '#fffef9'\n};\n","// Auto-generated icon data\n// Generated on 2025-09-04T14:10:07.197Z\n\nimport { colors } from '@/core/util/color';\nimport { CatStates, VillagerStates } from './game-assets';\n\nexport const cat = {\n  size: 10,\n  frames: 4,\n  palette: [\n    colors.black,\n    colors.black,\n  ],\n  data: {\n    [CatStates.idle]: [\n      '@@@@@@@P@@@HHBH`J`@j@hVA`jB@AD@@@@',\n      '@@@@@@@P@@`@HBH`J`@j@hVA`jB@AD@@@@',\n      '@@@@@@@@@b@@hbB`Z``U@hj@`jB@AD@@@@',\n      '@@@@@@@@@@@@Hf@`JH@j@jVA`jB@AD@@@@'\n    ],\n    [CatStates.walk]: [\n      '@@@@@@@P@@`@HBH`J`@j@hVA`jB@DD@@@@',\n      '@@@@@@@D@@@BHB``J@Bj@`VA@dJ@@P@@@@',\n      '@@@@@@@@@@P@HBH`J@Bj@`VA@jJ@DD@@@@',\n      '@@@@@@@A@@`@HBH`J`@j@hVA`jA@A@@@@@'\n    ],\n    [CatStates.run]: [\n      '@@@@@@@@@@@@@@@`HJ@jAjVAhj@@D@@@@@',\n      '@@@@@@@@@@@@HB@`ZJ`U@jj@hj@@Q@@@@@',\n      '@@@@@@@@@@@@@@@`HJ@jAjVAhj@DD@@@@@',\n      '@@@@@@@@@@@@HB@`J@@Uijj@hj@@P@@@@@'\n    ],\n    [CatStates.die]: [\n      '@@@@@@@@A@@BHB``J@Bj@`VA@jJ@H`@@@@',\n      '@@@@@@@@@@@@HRJ`J@jU@`J@@@@@@@@@@@',\n      '@@@@@@@@@@@@@@@@@@@i`jfb@ZZ@@@@@@@',\n      '@@@@@@@@@@@@@@@@@@@@@@dBhZBjjiI@@@'\n    ],\n    [CatStates.scratch]: [\n      '@@@@@@@P@@`@HBH`J`@j@hVA`jB@AD@@@@',\n      '@@@@@@@@@@D@@H@b@BhB`ZEAjjBP@@@@@@',\n      '@@@@@@P@@@H@b@BhBH`J@jU@hj@P@D@@@@',\n      '@@@@@@@D@@`@HBH`J`@j@hVA`jB@AD@@@@'\n    ],\n    [CatStates.scared]: [\n      '@@@P@@@B@@h@@`jHBjjJhjU@Jh@D`@@@@@',\n      '@@@P@@@B@@H@@`BHBjjJhjU@jh@DP@@@@@',\n      '@@@P@@@B@@h@@`jHBjjJhjU@Jh@DP@@@@@',\n      '@@@P@@@B@@H@@`BHBjjJhjU@jh@DP@@@@@'\n    ],\n    [CatStates.sleep]: [\n      '@@@@@@@@@@@@@@@@@@@bhjjJhZEA@@@@@@',\n      '@@@@@@@@@@@@@@@`H@@jhjVIhjR@@@@@@@',\n      '@@@@@@@@@@@@@@@`H@@jajVahjB@@@@@@@',\n      '@@@@@@@@@@@@@@@@@@@b`jjfhZE@@@@@@@'\n    ],\n    [CatStates.attack]: [\n      '@@@@@HB@`J@@j@@VX@hHhjBB`B@@B@@@@@',\n      '@@@@@HB@`J@@jP@V@Bhh`jB@`B@@B@@@@@',\n      '@@@@@HB@`J@Aj@BVHHhH@jBB`B@@B@@@@@',\n      '@@@@@b@@hB@`J@@U@Ijh@jB@`B@@B@@@@@'\n    ],\n    [CatStates.sit]: [\n      '@@@@@@@@@@@@HB@`JD@jH@V@Jj@@jB@@@@',\n      '@@@@@@@@@@@@HR@`JB@j`BV@`jB@jB@@@@',\n      '@@@@@@@@@@@@HB@`J@@ji@V@Hj@@jB@@@@',\n      '@@@@@@@@@@@@HB@`ZB@j`@V@Hj@@jB@@@@'\n    ]\n  }\n};\n\nexport const villager = {\n  size: 8,\n  frames: 4,\n  palette: [\n    colors.purple0,\n    colors.blue6,\n  ],\n  data: {\n    [VillagerStates.walk]: [\n      'PUAUUQVVTUEUUajj`@B@`@',\n      '@@@TUPUUdeEUUQUUhjJH`@',\n      'PUAUUQVVTUEUUajj`@BH@@',\n      '@@@TUPUUdeEUUQUUhjJH`@'\n    ],\n    [VillagerStates.scared]: [\n      '@@@TUPUUTfEiiQUUhjJH`@',\n      '@@@UETUEeYQZZTUEjjBBH@',\n    ],\n  }\n};\n\nexport const statue = {\n  size: 16,\n  palette: [\n    colors.blue2,\n    colors.blue3,\n    colors.blue4,\n  ],\n  data: '@@@@@@@DD@@@`e@@@@jB@@@hJ@@@@O@@@@}A@@@xK@@@`o@@@p~N@@T{{E@TmoWAPUUUE@WUUu@|C@C@'\n};\n\nexport const obelisk = {\n  size: 16,\n  palette: [\n    colors.blue2,\n    colors.blue3,\n    colors.blue4,\n  ],\n  data: '@PUE@@`UUB@@VUI@@xo@@poC@@kjN@@l{@@p~C@@kjN@@|o@@p{~C@@{O@@|k@@pC@@|C@@@@@@@'\n};\n\nexport const oak = {\n  size: 16,\n  palette: [\n    colors.green6,\n    colors.green3,\n    colors.green0,\n    colors.green5,\n  ],\n  data: '@@@@@@@@@@HIIA@@@@Q[[J@@@HZ[[SA@@QR[[RJ@@QRRRRJ@@aRRRRL@@QTRRbJ@@abbTTL@@aTTbbL@@IddddI@@HaddLA@@@HIIA@@@@HIIA@@@@@II@@@@@@@@@@@',\n};\n\nexport const spruce = {\n  size: 16,\n  palette: [\n    colors.blue3,\n    colors.blue0,\n    colors.blue1,\n    colors.blue2,\n  ],\n  data: '@@@HA@@@@@@QJ@@@@@HRRA@@@@YSZK@@@H[[[[A@@H[[[[A@@a\\\\[[cL@@acc\\\\\\\\L@@a\\\\\\\\ccL@@adc\\\\dL@@IddddI@@HaddLA@@@HIIA@@@@HIIA@@@@@II@@@@@@@@@@@',\n};\n\nexport const grass = {\n  size: 16,\n  palette: [\n    colors.green4,\n    colors.green5,\n    colors.green6,\n  ],\n  data: 'PPDDAP^feYTvVVYfweYZi]YfeiMgVvYv|Vvey`YZYvCfeiiCYZVfE\\\\wYZ[qWvefFle]fvPVfuY@g[dCpsCpC@'\n};\n\nexport const house = {\n  size: 16,\n  palette: [\n    colors.blue4,\n    colors.blue2,\n    colors.blue3\n  ],\n  data: 'PU@@@PjVUU@YyGdjWU]PkAm^UUGt_PWUUuA}GTUUUUpjjjjC[_ZUNlk}ypvgVgCkjZ_N|}}@'\n};\n\nexport const ground = {\n  size: 12,\n  palette: [\n    colors.green4,\n    colors.green5,\n  ],\n  data: '@@@@@@D@@A@D@DA@DY@@PjEDA@@@@@A@@@@@@@@QQ@AdF@Pi',\n};\n","import { emojiToPixelArt } from '@/core/emoji';\nimport { NewTileset as NewTileset } from '@/core/tileset';\nimport { createCornerImage } from '@/core/util/image-generator';\nimport { generateImageData } from './sprite-loader';\nimport { cat, grass, ground, house, oak, obelisk, spruce, statue, villager } from './sprites';\nimport { colors } from '@/core/util/color';\n\nexport const enum CatStates {\n  idle,\n  walk, \n  run,\n  die,\n  scratch,\n  scared,\n  sleep,\n  attack,\n  sit,\n}\nexport const enum VillagerStates {\n  walk,\n  scared,\n} ;\n\nconst emoji = '🔥,🍀,🌼,🐓,🌷,🌹,👻,🥚,🍎'.split(',');\nexport const icons = emoji.map(e => emojiToPixelArt(e));\n\nexport class GameAssets {\n  static cat: NewTileset<CatStates>;\n  static villager: NewTileset<VillagerStates>;\n  static cornerImage: HTMLImageElement;\n  static oak: HTMLImageElement;\n  static spruce: HTMLImageElement;\n  static house: HTMLImageElement;\n  static grass: HTMLImageElement;\n  static ground: HTMLImageElement;\n  static statue: HTMLImageElement;\n  static statueGold: HTMLImageElement;\n  static obelisk: HTMLImageElement;\n  static obeliskGold: HTMLImageElement;\n  static superCat: NewTileset<CatStates>;\n\n  public static initialize() {\n    GameAssets.cat = new NewTileset<CatStates>(cat);\n    GameAssets.superCat = new NewTileset<CatStates>({...cat, palette: [colors.purple3, colors.purple2]});\n\n    GameAssets.villager = new NewTileset<VillagerStates>(villager);\n    GameAssets.cornerImage = createCornerImage();\n    GameAssets.oak = generateImageData(oak.data, oak.palette);\n    GameAssets.spruce = generateImageData(spruce.data, spruce.palette);\n    GameAssets.house = generateImageData(house.data, house.palette);\n    GameAssets.grass = generateImageData(grass.data, grass.palette);\n    GameAssets.ground = generateImageData(ground.data, ground.palette);\n    \n    const goldPalette = [colors.yellow0, colors.yellow1, colors.yellow2];\n    GameAssets.statue = generateImageData(statue.data, statue.palette);\n    GameAssets.statueGold = generateImageData(statue.data, goldPalette);\n    GameAssets.obelisk = generateImageData(obelisk.data, obelisk.palette);\n    GameAssets.obeliskGold = generateImageData(obelisk.data, goldPalette);\n  }\n}\n","import { colors } from './color';\nimport { createCanvasWithCtx } from './canvas';\n\n/**\n * Creates a 16x16 image with transparent background and colored corners\n * @param cornerColor The color to use for the 3x3 corner pixels\n * @returns HTMLImageElement ready to be used with drawImage\n */\nexport function createCornerImage(cornerColor: string = colors.purple4): HTMLImageElement {\n  // Create temporary canvas\n  const [canvas, ctx] = createCanvasWithCtx(16, 16);\n\n  // Clear to transparent\n  ctx.clearRect(0, 0, 16, 16);\n\n  // Set corner color\n  ctx.fillStyle = cornerColor;\n\n  // Draw 2x2 arrow corners (3 pixels each, 1 transparent)\n  \n  // Top-left corner arrow (pointing inward)\n  ctx.fillRect(0, 0, 1, 1); // top-left pixel\n  ctx.fillRect(1, 0, 1, 1); // top-right pixel  \n  ctx.fillRect(0, 1, 1, 1); // bottom-left pixel\n  // (1,1) is transparent\n  \n  // Top-right corner arrow (pointing inward)\n  ctx.fillRect(14, 0, 1, 1); // top-left pixel\n  ctx.fillRect(15, 0, 1, 1); // top-right pixel\n  ctx.fillRect(15, 1, 1, 1); // bottom-right pixel\n  // (14,1) is transparent\n  \n  // Bottom-left corner arrow (pointing inward)\n  ctx.fillRect(0, 14, 1, 1); // top-left pixel\n  ctx.fillRect(0, 15, 1, 1); // bottom-left pixel\n  ctx.fillRect(1, 15, 1, 1); // bottom-right pixel\n  // (1,14) is transparent\n  \n  // Bottom-right corner arrow (pointing inward)\n  ctx.fillRect(15, 14, 1, 1); // top-right pixel\n  ctx.fillRect(14, 15, 1, 1); // bottom-left pixel\n  ctx.fillRect(15, 15, 1, 1); // bottom-right pixel\n  // (14,14) is transparent\n\n  // Convert canvas to image\n  const img = new Image();\n  img.src = canvas.toDataURL();\n  \n  return img;\n}\n","import { hexToRgb, colors } from '@/core/util/color';\nimport { createCanvasWithCtx } from '@/core/util/canvas';\n\nexport const tinyFont = /* font-start */'6v7ic,6trd0,6to3o,6nvic,55eyo,2np50,2jcjo,3ugt8,34ao,7k,glc,1,opzc,3xdeu,3sapz,8rhfz,8ri26,1bzky,9j1ny,3ws2u,9dv9k,3xb1i,3xbmu,2t8g,2t8s,26ndv,ajmo,fl5ug,3x7nm,n75t,54br,59u0e,53if,rlev,4jrb,1yjk4,4eav,55q95,18zsz,mi3r,574tl,1aedd,ljn9,a1bd,4f1i,a1fs,549t,53ig,5832,1dwsh,6iw6,6ix0,cbsa,6gix,6fk4,aky7,7mbws,cvtyq,deehh,2sfi3'/* font-end */.split(',');\n\n// Character cache: charCode-color-size -> Canvas\nconst characterCanvases: { [key: string]: HTMLCanvasElement } = {};\n\nexport const FULL_HEART = '#';\nexport const TWO_THIRDS_HEART = '$';\nexport const ONE_THIRD_HEART = '%';\nexport const EMPTY_HEART = '&';\nexport const COLCHEIA = '*';\nexport const HOUSE = '^';\n\nexport const TELEPORT = '[';\nexport const SCRATCH = '\\\\';\nexport const MAGIC = ']';\n\nexport type DrawTextProps = {\n  text: string\n  x: number\n  y: number\n  color?: string\n  textAlign?: CanvasTextAlign\n  textBaseline?: CanvasTextBaseline\n  size?: number\n  space?: number\n}\n\nconst getCharacterData = (letter: string) => {\n  if (letter === '0') return { paddedBinary: '0'.repeat(25), leftmostCol: 0, charWidth: 5 };\n  \n  const paddedBinary = String(parseInt(letter, 36).toString(2)).padStart(25, '0');\n  let leftmostCol = 5;\n  let rightmostCol = -1;\n  \n  // Find leftmost and rightmost columns with set bits\n  for (let col = 0; col < 5; col++) {\n    for (let row = 0; row < 5; row++) {\n      const bitIndex = row * 5 + col;\n      if (paddedBinary[bitIndex] === '1') {\n        leftmostCol = Math.min(leftmostCol, col);\n        rightmostCol = Math.max(rightmostCol, col);\n      }\n    }\n  }\n  \n  const charWidth = rightmostCol >= leftmostCol ? rightmostCol - leftmostCol + 1 : 1;\n  return { paddedBinary, leftmostCol, charWidth };\n};\n\nconst getCharacterWidth = (letter: string): number => {\n  return getCharacterData(letter).charWidth;\n};\n\nconst createCharacterCanvas = (character: string, size: number, color: string): HTMLCanvasElement => {\n  const letter = character === ' ' ? '0' : tinyFont[character.charCodeAt(0) - 35];\n  const { paddedBinary, leftmostCol, charWidth } = getCharacterData(letter);\n  \n  const scaledWidth = charWidth * size;\n  const letterHeight = 5 * size;\n  \n  const [canvas, ctx] = createCanvasWithCtx(scaledWidth, letterHeight);\n  \n  const [r, g, b, a] = hexToRgb(color);\n  const fillStyle = `rgba(${r}, ${g}, ${b}, ${(a || 255) / 255})`;\n  \n  // Draw character bitmap\n  paddedBinary.split('').forEach((bit, bitIndex) => {\n    if (bit !== '0') {\n      const col = bitIndex % 5;\n      const row = Math.floor(bitIndex / 5);\n      \n      // Skip empty left columns\n      if (col < leftmostCol) return;\n      \n      const adjustedCol = col - leftmostCol;\n      \n      ctx.fillStyle = fillStyle;\n      ctx.fillRect(adjustedCol * size, row * size, size, size);\n    }\n  });\n\n  return canvas;\n};\n\nconst getCharacterCanvas = (character: string, size: number, color: string): HTMLCanvasElement => {\n  const cacheKey = `${character.charCodeAt(0)}-${color}-${size}`;\n  \n  if (!characterCanvases[cacheKey]) {\n    characterCanvases[cacheKey] = createCharacterCanvas(character, size, color);\n  }\n  \n  return characterCanvases[cacheKey];\n};\n\nexport const drawText = (\n  c: CanvasRenderingContext2D,\n  text: string,\n  x: number,\n  y: number,\n  color = colors.white,\n  textAlign = 0, // 0=left, 1=center, 2=right\n  textBaseline = 0, // 0=top, 1=middle, 2=bottom  \n  size = 2,\n  space = 1\n) => {\n  x = Math.round(x);\n  y = Math.round(y);\n  if (!text) text = ' ';\n  \n  // Calculate variable width for text\n  const spacing = space * size;\n  const characters = text.replace('!', '@').toUpperCase().split('');\n  \n  // Calculate positions and total width\n  let totalWidth = 0;\n  const charPositions: { char: string; x: number; charWidth: number }[] = [];\n  \n  characters.forEach((character, i) => {\n    const letter = character === ' ' ? '0' : tinyFont[character.charCodeAt(0) - 35];\n    const charWidth = getCharacterWidth(letter) * size;\n    \n    charPositions.push({ char: character, x: totalWidth, charWidth });\n    totalWidth += charWidth + (i < characters.length - 1 ? spacing : 0);\n  });\n  \n  const letterHeight = 5 * size;\n  const offsetX = textAlign === 0 ? 0 : textAlign === 1 ? Math.round(totalWidth / 2) : totalWidth;\n  const offsetY = textBaseline === 0 ? 0 : textBaseline === 1 ? Math.round(letterHeight / 2) : letterHeight;\n  \n  // Draw each character synchronously\n  charPositions.forEach(({ char, x: charX, charWidth }) => {\n    if (char === ' ') return; // Skip spaces\n    \n    const canvas = getCharacterCanvas(char, size, color);\n    c.drawImage(canvas, 0, 0, charWidth, letterHeight, x - offsetX + charX, y - offsetY, charWidth, letterHeight);\n  });\n};\n\n\n","import { GameAssets } from '@/game/game-assets';\nimport { drawText } from './font';\nimport { colors } from './util/color';\nimport { getCtx } from './util/canvas';\n\nconst makeCircle = (\n  ctx: CanvasRenderingContext2D,\n  centerX: number,\n  centerY: number,\n  radiusX: number,\n  radiusY: number,\n  skew = 0,\n) => {\n  // Draw ellipse using scaled circle algorithm\n  for (let y = -radiusY; y <= radiusY; y++) {\n    // Calculate the half-width at this y position using ellipse equation\n    const normalizedY = y / radiusY;\n    const halfWidth = Math.round(radiusX * Math.sqrt(1 - normalizedY * normalizedY));\n    \n    if (halfWidth > 0) {\n      const offset = Math.round(skew * Math.abs(y));\n      const currentY = centerY + y;\n      \n      if (y >= 0) {\n        ctx.rect(centerX - halfWidth - offset, currentY, halfWidth * 2, 1);\n      } else {\n        ctx.rect(centerX - halfWidth + offset, currentY, halfWidth * 2, 1);\n      }\n    }\n  }\n};\n\nclass DrawEngine {\n  ctx1: CanvasRenderingContext2D;\n  ctx2: CanvasRenderingContext2D;\n  ctx3: CanvasRenderingContext2D;\n  ctx4: CanvasRenderingContext2D;\n\n  // Canvas dimensions (cached for performance)\n  canvasWidth = 0;\n  canvasHeight = 0;\n\n  // Camera properties\n  cameraX = 0;\n  cameraY = 0;\n  zoom = 1;\n  targetCameraX = 0;\n  targetCameraY = 0;\n  targetZoom = 1;\n  cameraLerpSpeed = 0.08; // Adjust for faster/slower camera\n  moveCameraLinearly = false;\n\n  constructor() {\n    this.ctx1 = getCtx(c1);\n    this.ctx2 = getCtx(c2);\n    this.ctx3 = getCtx(c3);\n    this.ctx4 = getCtx(c4);\n    GameAssets.initialize();\n    this.resizeCanvas();\n    window.addEventListener('resize', () => this.resizeCanvas());\n    window.addEventListener('orientationchange', () => this.resizeCanvas());\n  }\n\n  resizeCanvas() {\n    const aspectRatio = 4 / 3;\n    const gameWidth = 1200;\n    const gameHeight = Math.round(gameWidth / aspectRatio);\n    this.canvasWidth = gameWidth;\n    this.canvasHeight = gameHeight;\n    const ctxs: CanvasRenderingContext2D[] = [this.ctx1, this.ctx2, this.ctx3, this.ctx4];\n    for (const ctx of ctxs) {\n      // eslint-disable-next-line id-denylist\n      ctx.canvas.width = gameWidth;\n      // eslint-disable-next-line id-denylist\n      ctx.canvas.height = gameHeight;\n      ctx.imageSmoothingEnabled = false;\n    }\n  }\n\n  \n  // eslint-disable-next-line class-methods-use-this\n  drawCircumference(\n    ctx: CanvasRenderingContext2D,\n    centerX: number,\n    centerY: number,\n    radiusX: number,\n    radiusY: number,\n    color: string,\n    strokeWidth: number,\n  ) {\n    ctx.save();\n    ctx.beginPath();\n    makeCircle(ctx, centerX, centerY, radiusX, radiusY);\n    makeCircle(ctx, centerX, centerY, radiusX - strokeWidth, radiusY - strokeWidth);\n    ctx.clip('evenodd');\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.fillRect(centerX - radiusX, centerY - radiusY, radiusX*2, radiusY*2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  drawText(\n    text: string,\n    x: number,\n    y: number,\n    color?: string,\n    textAlign = 0,\n    textBaseline = 0,\n    size = 2,\n    space = 1,\n    context?: CanvasRenderingContext2D\n  ) {\n    drawText(context || this.ctx1, text, x, y, color, textAlign, textBaseline, size, space);\n  }\n\n  static drawImage(\n    ctx: CanvasRenderingContext2D,\n    img: HTMLImageElement,\n    x: number,\n    y: number,\n    mirrored?: boolean,\n    imgWidth?: number,\n    imgWeight?: number,\n  ) {\n    if (mirrored) {\n      ctx.save();\n      ctx.scale(-1, 1);\n      x = -x - (imgWidth ?? img.width);\n    }\n    ctx.drawImage(\n      img,\n      x,\n      y,\n      imgWidth ?? img.width,\n      imgWeight ?? img.height,\n    );\n    if (mirrored) {\n      ctx.restore();\n    }\n  }\n\n  drawBackgroundImage(\n    img: HTMLImageElement,\n    x: number,\n    y: number,\n    mirrored?: boolean,\n    imgWidth?: number,\n    imgHeight?: number,\n  ) {\n    DrawEngine.drawImage(this.ctx1, img, x, y, mirrored, imgWidth, imgHeight);\n  }\n\n  /**\n   * Sets the camera position and zoom level.\n   * @param x The x-coordinate of the object where the camera should focus\n   * @param y The y-coordinate of the object where the camera should focus\n   * @param zoom The zoom level of the camera\n   */\n  setCamera(x: number, y: number, zoom: number = 1, immediate = false) {\n    this.targetCameraX = x;\n    this.targetCameraY = y;\n    this.targetZoom = zoom;\n    const cx = this.canvasWidth / 2 - 32;\n    const cy = this.canvasHeight / 2 - 64;\n    if (immediate) {\n      this.cameraX = x;\n      this.cameraY = y;\n      this.zoom = zoom;\n    }\n    this.ctx1.setTransform(\n      this.zoom, 0, 0, this.zoom,\n      cx - this.cameraX * this.zoom,\n      cy - this.cameraY * this.zoom,\n    );\n  }\n\n  updateCamera() {\n    if (this.moveCameraLinearly) {\n      // Linear movement\n      const deltaX = this.targetCameraX - this.cameraX;\n      const deltaY = this.targetCameraY - this.cameraY;\n      const deltaZoom = this.targetZoom - this.zoom;\n      const step = this.cameraLerpSpeed * 10; // Scale up for linear speed\n      \n      if (Math.abs(deltaX) < 0.01) {\n        this.cameraX = this.targetCameraX;\n      } else {\n        this.cameraX += Math.sign(deltaX) * Math.min(Math.abs(deltaX), step);\n      }\n      \n      if (Math.abs(deltaY) < 0.01) {\n        this.cameraY = this.targetCameraY;\n      } else {\n        this.cameraY += Math.sign(deltaY) * Math.min(Math.abs(deltaY), step);\n      }\n      \n      if (Math.abs(deltaZoom) < 0.02) {\n        this.zoom = this.targetZoom;\n      } else {\n        this.zoom += Math.sign(deltaZoom) * Math.min(Math.abs(deltaZoom), step * 0.1);\n      }\n    } else {\n      // Eased movement\n      this.cameraX += (this.targetCameraX - this.cameraX) * this.cameraLerpSpeed;\n      if (Math.abs(this.targetCameraX - this.cameraX) < 0.01) {\n        this.cameraX = this.targetCameraX;\n      }\n      this.cameraY += (this.targetCameraY - this.cameraY) * this.cameraLerpSpeed;\n      if (Math.abs(this.targetCameraY - this.cameraY) < 0.01) {\n        this.cameraY = this.targetCameraY;\n      }\n      this.zoom += (this.targetZoom - this.zoom) * this.cameraLerpSpeed;\n      if (Math.abs(this.targetZoom - this.zoom) < 0.02) {\n        this.zoom = this.targetZoom;\n      }\n    }\n  }\n\n  resetCamera() {\n    this.ctx1.setTransform(1, 0, 0, 1, 0, 0);\n  }\n\n  clear() {\n    this.resetCamera();\n    this.ctx1.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n    this.ctx1.fillStyle = colors.green3;\n    this.ctx1.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n    this.ctx2.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n    this.ctx3.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n  }\n\n  /**\n   * Converts world coordinates to screen coordinates, accounting for camera transforms\n   * @param worldX World X coordinate\n   * @param worldY World Y coordinate\n   * @param zoom Current zoom level (defaults to 7, matching game state)\n   * @returns Screen coordinates { x, y }\n   */\n  worldToScreen(worldX: number, worldY: number, zoom: number = 7): { x: number; y: number } {\n    const cx = this.canvasWidth / 2 - 32;\n    const cy = this.canvasHeight / 2 - 64;\n\n    return {\n      x: cx + (worldX - this.cameraX) * zoom,\n      y: cy + (worldY - this.cameraY) * zoom\n    };\n  }\n}\n\nexport const drawEngine = new DrawEngine();\n","import { Circle, Path } from './types';\n\nexport const CELL_WIDTH = 12;\nexport const CELL_HEIGHT = 12;\n\nexport const MAX_LIVES = 9;\nexport const MAX_MAGIC = 6;\nexport const MAX_REPAIR = 20;\n\nexport const NOTIFICATION_DURATION = 5000;\n\nexport const paths: Path[] = [\n  // Main path\n  [\n    [69, 100, 3],\n    [76, 113, 4],\n    [89, 114, 5],\n    [104, 86, 3],\n    [99, 59, 3],\n    [85, 46, 2],\n    [86, 28, 2],\n    [74, 38, 2],\n    [60, 39, 2],\n    [48, 30, 2],\n    [46, 43, 2],\n    [38, 61, 3],\n    [50, 73, 4],\n    [38, 84, 3],\n    [46, 123, 3],\n    [36, 133, 2],\n    [48, 141, 3],\n    [94, 133, 4],\n    [113, 109, 5],\n    [122, 74, 6],\n    [113, 56, 0.9],\n  ],\n\n  // Smaller paths\n  [[45, 49, 0.9], [71, 51, 0.9]],\n\n  // Northwest village path\n  [[119, 54, 1], [129, 29, 1]],\n];\n\nexport const clearings: Circle[] = [\n  // Peak\n  { x: 64, y: 88, r: 6 },\n  { x: 75, y: 88, r: 6 },\n  { x: 69, y: 95, r: 6 },\n\n  // Northeast village\n  { x: 129, y: 28, r: 10 },\n\n  // Eye\n  { x: 71, y: 51, r: 3 },\n];\n\nexport const statues = {\n  heart: { x: 76, y: 84, name: 'heart' },\n  moon: { x: 129, y: 19, name: 'moon' },\n  ear: { x: 49, y: 29, name: 'ear' },\n  eye: { x: 71, y: 50, name: 'eye' },\n  foot: { x: 35, y: 131, name: 'foot' },\n  tail: { x: 114, y: 56, name: 'tail' },\n} as const;\n","import { CELL_WIDTH, CELL_HEIGHT } from '@/game/constants';\nimport { drawEngine } from './draw-engine';\nimport { updatePositionSmoothly, SmoothMovementState } from '../utils/smooth-movement';\n\ninterface Tileset<T extends (string | number)> {\n  animations: Record<T, HTMLImageElement[]>;\n  tileSize: number;\n}\n\nexport class GameObject<T extends (string | number)> implements SmoothMovementState {\n  animationTime = 0;\n  animationFrame = 0;\n  aD = 150; // Duration for each animation frame in milliseconds\n  animationLoop = true;\n  col: number;\n  row: number;\n  moving = { x: 0, y: 0 };\n  targetPos: { x: number; y: number };\n\n  constructor(\n    private readonly tileset: Tileset<T>,\n    public x: number,\n    public y: number,\n    public type: string,\n    public animation: T,\n    public speed: number = 0,\n    public mirrored: boolean = false,\n  ) {\n    this.col = Math.ceil(x / CELL_WIDTH);\n    this.row = Math.ceil(y / CELL_HEIGHT);\n    this.animationTime = Math.random() * this.aD;\n    this.targetPos = { x: this.x, y: this.y };\n  }\n\n  setPos(col: number, row: number) {\n    this.col = col;\n    this.row = row;\n    this.x = col * CELL_WIDTH;\n    this.y = row * CELL_HEIGHT;\n    this.targetPos = { x: this.x, y: this.y };\n  }\n\n  update(timeElapsed: number) {\n    if (!this.animationLoop && this.animationFrame === (this.tileset.animations[this.animation].length - 1)) {\n      return;\n    }\n    this.animationTime += timeElapsed;\n    this.animationFrame = Math.floor(this.animationTime / this.aD) % this.tileset.animations[this.animation].length;\n  }\n\n  updatePositionSmoothly(timeElapsed: number) {\n    updatePositionSmoothly(this, timeElapsed);\n    if (this.moving.x !== 0) {\n      this.mirrored = this.moving.x < 0;\n    }\n  }\n\n  draw() {\n    const animation = this.tileset.animations[this.animation];\n    if (animation[this.animationFrame]) {\n      drawEngine.drawBackgroundImage(\n        animation[this.animationFrame],\n        this.x - (this.tileset.tileSize - CELL_WIDTH) / 2,\n        this.y - (this.tileset.tileSize - CELL_HEIGHT) / 2,\n        this.mirrored,\n      );\n    }\n  }\n\n}\n","const listeners: Array<{ eventName: string; handler: EventListener }> = [];\n\nexport const on = (event: number, listener: (detail: any) => void) => {\n  const eventName = String(event);\n  const handler = (e: Event) => {\n    listener((e as CustomEvent).detail);\n  };\n  document.addEventListener(eventName, handler);\n  listeners.push({ eventName, handler });\n};\n\nexport const emit = (event: number, data?: any) => {\n  const eventName = String(event);\n  document.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n};\n\nexport const clearEvents = () => {\n  for (const { eventName, handler } of listeners) {\n    document.removeEventListener(eventName, handler);\n  }\n  listeners.length = 0;\n};\n","import { colors } from '@/core/util/color';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\n\nconst linePixels = (x0: number, y0: number, x1: number, y1: number): [number, number][] => {\n  const pixels: [number, number][] = [];\n  let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n  let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n  let err = dx + dy, e2: number;\n\n  for (;;) {\n    pixels.push([x0, y0]);\n    if (x0 === x1 && y0 === y1) break;\n    e2 = 2 * err;\n    if (e2 >= dy) { err += dy; x0 += sx; }\n    if (e2 <= dx) { err += dx; y0 += sy; }\n  }\n  return pixels;\n};\n\nconst pentagramVertices = (cx: number, cy: number, pentagramRotation: number, radius: number): [number, number][] => {\n  const points: [number, number][] = [];\n  for (let i = 0; i < 5; i++) {\n    const angle = (2 * Math.PI * (i * 2 % 5)) / 5 - Math.PI / 2 + pentagramRotation;\n    const x = Math.round(cx + radius * Math.cos(angle));\n    const y = Math.round(cy + radius * Math.sin(angle));\n    points.push([x, y]);\n  }\n  return points;\n};\n\nconst _rotations = [Math.PI / 2, Math.PI, 3 * Math.PI / 2] as const;\n\nexport class PentagramAnimation {\n  cx: number;\n  cy: number;\n  allPixels: [number, number][];\n  totalDuration: number;\n\n  constructor(\n    public ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    public animationDone: () => void,\n    private pentagramRotation: typeof _rotations[number] = Math.PI / 2,\n    private radius: number = 12,\n    private offset = 0,\n    private elapsed = 0,\n    private speed = 300,\n    private trailLength = 16,\n    private cycles = 0,\n    private maxCycles = 1,\n    private active = true,\n  ) {\n    this.cx = x + CELL_WIDTH / 2;\n    this.cy = y + CELL_HEIGHT / 2;\n\n    const points = pentagramVertices(this.cx, this.cy, pentagramRotation, radius);\n\n    this.allPixels = [];\n    for (let i = 0; i < 5; i++) {\n      const [x0, y0] = points[i];\n      const [x1, y1] = points[(i + 1) % 5];\n      this.allPixels.push(...linePixels(x0, y0, x1, y1));\n    }\n    this.totalDuration = this.allPixels.length * this.maxCycles * 1000 / this.speed;\n  }\n\n  update(timeElapsed: number): void {\n    if (!this.active) return;\n\n    const totalPixelsAdvanced = (this.elapsed / 1000) * this.speed;\n    const newOffset = Math.floor(totalPixelsAdvanced) % this.allPixels.length;\n    \n    // Check for cycle completion\n    if (newOffset < this.offset) {\n      this.cycles++;\n      if (this.cycles >= this.maxCycles) {\n        this.active = false;\n        this.animationDone();\n        return;\n      }\n    };\n    \n    this.offset = newOffset;\n    this.elapsed += timeElapsed;\n  }\n\n  draw(): void {\n    if (!this.active) return;\n\n    this.ctx.fillStyle = colors.white;\n    const effectiveTrailLength = Math.min(this.trailLength, this.offset);\n    \n    for (let i = 0; i < effectiveTrailLength; i++) {\n      const idx = (this.offset - i + this.allPixels.length) % this.allPixels.length;\n      const [x, y] = this.allPixels[idx];\n      this.ctx.fillRect(x, y, 1, 1);\n    }\n  }\n\n  isActive(): boolean {\n    return this.active;\n  }\n}\n","export const forEachSurroundingCell = (\n  centerCol: number,\n  centerRow: number,\n  callback: (col: number, row: number) => void,\n  includeCenter: boolean = false\n) => {\n  for (let deltaRow = -1; deltaRow <= 1; deltaRow++) {\n    for (let deltaCol = -1; deltaCol <= 1; deltaCol++) {\n      if (!includeCenter && deltaRow === 0 && deltaCol === 0) continue;\n      callback(centerCol + deltaCol, centerRow + deltaRow);\n    }\n  }\n};\n","\nconst t = (i: number, n: number)=>(n-i)/n;\n\n// Reuse a single AudioContext to avoid memory leaks\nlet audioCtx: AudioContext | null = null;\n\n// Sound player\nexport const playSound = (f: (i: number) => number) => {\n  if (!audioCtx) audioCtx = new AudioContext();\n  const m = audioCtx.createBuffer(1,96e3,48e3);\n  const b = m.getChannelData(0);\n  for(let i = 96e3; i--;) b[i] = f(i);\n  const s = audioCtx.createBufferSource();\n  s.buffer=m;\n  s.connect(audioCtx.destination);\n  s.start();\n};\n\n// Sound\n// export const ooof = (pitch: number) => playSound((i: number) => {\n//   var n=2e4;\n//   if (i > n) return 0;\n//   var q = t(i,n);\n//   return 0.2 * Math.tan(Math.cbrt(Math.sin(i/(145 - 5 * pitch))))*q*q;\n// });\n\n// export const doorSound = () => playSound((i: number) => {\n//   return 0.1 * Math.sin(i/50 + Math.random()*50) * (8000 - i%8000) / 5000 * Math.exp(-i/8000);\n// });\n\nexport const step = (length = 1) => playSound((i: number) => {\n  const n = 2e3 * length;\n  return i > n ? 0 : 0.15 * (Math.random() * 2 - 1) * Math.sin((Math.PI * i) / n);\n});\n\nexport const attack5 = () => playSound((i: number) => {\n  const n = 29e3;\n  if (i > n) return 0;\n  const decay = i > n * 0.6 ? Math.pow(0.9999, i - n * 0.6) : 1;\n  const phase = 5 * Math.sin(5 * Math.round(5 * i / n));\n  return decay * 0.2 * Math.sin(i/(30 - phase) + Math.random()) * (8000 - i%6000) / 5000;\n});\n\nexport const attack = () => playSound((i: number) => {\n  const n = 10e3;\n  if (i > n) return 0;\n  const phase = 5 * Math.sin(5 * Math.round(5 * i / n));\n  return Math.pow(0.998, i / 10) * 0.2 * Math.sin(i/(40 - phase) + Math.random()) * (8000 - i%6000) / 5000;\n});\n\nexport const repair = (pitch: number) => playSound((i: number) => {\n  return Math.sin(i/(21 - pitch) + Math.sin(i/2000)*5) * Math.exp(-i/4000) * (i/96000) * 9;\n});\n\nexport const highRepair = (pitch: number) => playSound((i: number) => {\n  // Musical scale: each pitch step multiplies frequency by 12th root of 2\n  // Lower pitch number = higher frequency (smaller period)\n  const freq = 80 * Math.pow(2, -pitch / 12); // Base frequency decreases with pitch\n  const phase = i * 2 * Math.PI / freq + Math.sin(i/1800) * 4;\n  // Church organ sound with harmonics (fundamental + octave + perfect fifth)\n  const fundamental = Math.sin(phase);\n  const octave = Math.sin(phase * 2) * 0.5;      // One octave up (2x frequency)\n  const fifth = Math.sin(phase * 3) * 0.3;       // Perfect fifth (3x frequency) \n  const octave2 = Math.sin(phase * 4) * 0.2;     // Two octaves up (4x frequency)\n  return (fundamental + octave + fifth + octave2) * Math.exp(-i/6000) * (i/96000) * 6;\n});\n\nexport const hissAndSpit = () => playSound((i: number) => {\n  const n = 10e3;\n  if (i > n) return 0;\n  const q = (n - i) / n;\n  return ((Math.random() * 2 - 1) * Math.sin(i * 0.003) * 0.6 + Math.sin(i / (15 + Math.sin(i / 500) * 8)) * Math.exp(-i / 2000) * 0.4) * q * q * 0.3;\n});\n\nexport const heal = () => playSound((i: number) => {\n  const n = 6e3;\n  if (i > n) return 0;\n  var q = (n - i) / n;\n  return 0.5 * Math.sin(i*0.01*Math.sin(0.007*i+Math.sin(i/1200))+Math.sin(i/800))*q*q;\n});\n\nexport const exorcise = () => {\n  const x = ~(Math.random() * 1000);\n  return playSound((i: number) => {\n    return Math.sin(i/(10 + i/8000 - i/12000) & x + Math.sin(i/2000)*5) * Math.exp(-i/4000) * (i/96000) * 9;\n  });\n};\n","import { CatStates, GameAssets } from '@/game/game-assets';\nimport { GameObject } from '../../core/game-object';\nimport { controls } from '../../core/controls';\nimport { GameMap } from '../game-map';\nimport { CELL_HEIGHT, CELL_WIDTH, statues } from '../constants';\nimport { emit, on } from '@/core/event';\nimport { addTimeEvent } from '@/core/timer';\nimport { Spirit } from './spirit';\nimport { GameData } from '../game-data';\nimport { PentagramAnimation } from './pentagram-attack';\nimport { forEachSurroundingCell } from '../grid-utils';\nimport { drawEngine } from '@/core/draw-engine';\nimport { GameEvent } from '../event-manifest';\nimport { attack, attack5, step } from '@/core/audio';\n\nconst ANIMATION_SLOW = 600;\nconst ANIMATION_NORMAL = 150;\nconst ANIMATION_FAST = 75;\n\nconst STEP_SOUND_TIME = 200;\n\nexport class Player extends GameObject<CatStates> {\n  type = 'cat';\n  sleeping = true;\n  sitting = false;\n  attacking = false;\n  scared = false;\n  inVillage = false;\n  pentagramAttack: PentagramAnimation | null = null;\n  stepSoundTimer = 0;\n  sittingTimer = 0;\n\n  constructor(col: number, row: number, public map: GameMap, public gameData: GameData) {\n    super(\n      GameAssets.cat,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'cat',\n      CatStates.sleep,\n      80,\n    );\n\n    // Initialize looking direction to the right\n    this.map.playerLookingAt = { col: col + 1, row };\n\n    on(GameEvent.TELEPORT, () => {\n      this.setPos(statues.heart.x, statues.heart.y + 1);\n    });\n\n    on(GameEvent.WAKE_UP, () => {\n      this.sleeping = false;\n      this.sitting = true;\n    });\n\n    on(GameEvent.ENABLE_SCRATCH, () => {\n      this.sitting = false;\n    });\n\n    on(GameEvent.ATTACK_PLAYER, () => {\n      this.scared = true;\n      addTimeEvent(() => {\n        this.scared = false;\n      }, 600);\n    });\n\n    on(GameEvent.GAME_OVER, () => {\n      this.animation = CatStates.die;\n      this.animationTime = 0;\n      this.animationFrame = 0;\n      this.animationLoop = false;\n      this.aD = ANIMATION_SLOW;\n    });\n  }\n\n  updateAnimation(timeElapsed: number) {\n    super.update(timeElapsed);\n\n    switch(this.animation) {\n      case CatStates.sleep:\n      case CatStates.sit:\n        this.aD = ANIMATION_SLOW;\n        break;\n      case CatStates.scared:\n        this.aD = ANIMATION_FAST;\n        break;\n      default:\n        this.aD = ANIMATION_NORMAL;\n        break;\n    }\n  }\n\n  update(timeElapsed: number) {\n    if (this.animation === CatStates.die) return;\n\n    if (this.animation === CatStates.run) {\n      this.stepSoundTimer -= timeElapsed;\n      if (this.stepSoundTimer <= 0) {\n        step();\n        this.stepSoundTimer = STEP_SOUND_TIME;\n      }\n    } else {\n      this.stepSoundTimer = 0;\n    }\n\n    const cellVillage = this.map.grid[this.row][this.col].village;\n    if (!this.inVillage && cellVillage) {\n      this.inVillage = true;\n      emit(GameEvent.ENTER_VILLAGE, cellVillage);\n    } else if (this.inVillage && !cellVillage) {\n      this.inVillage = false;\n    }\n\n    // DEBUG\n    coords.innerText = `${this.col},${this.row}`;\n\n    if (this.gameData.cutscene) {\n      return;\n    }\n    \n    if(this.scared && !this.isSurrounded()) {\n      this.animation = CatStates.scared;\n    } else if (this.sleeping) {\n      this.animation = CatStates.sleep;\n    } else if (this.sitting) {\n      this.animation = CatStates.sit;\n    } else if (this.attacking) {\n      this.animation = this.pentagramAttack ? CatStates.attack : CatStates.scratch;\n    } else {\n      super.updatePositionSmoothly(timeElapsed);\n\n\n      if (!this.moving.y && controls.inputDirection.y) {\n        const newRow = this.row + controls.inputDirection.y;\n        \n        if (!this.map.grid[newRow][this.col].content) {\n          this.animation = CatStates.run;\n          this.moving.y = controls.inputDirection.y;\n          this.targetPos.y += controls.inputDirection.y * CELL_HEIGHT;\n          this.row = newRow;\n          // Update looking direction after movement to point ahead\n          this.map.playerLookingAt = { col: this.col, row: this.row + controls.inputDirection.y };\n        } else {\n          // Blocked movement - still update looking direction to attempted target\n          this.map.playerLookingAt = { col: this.col, row: this.row + controls.inputDirection.y };\n        }\n      }\n\n      if (!this.moving.x && controls.inputDirection.x) {\n        this.mirrored = controls.isLeft;\n        const newCol = this.col + controls.inputDirection.x;\n        \n        if (!this.map.grid[this.row][newCol].content) {\n          this.animation = CatStates.run;\n          this.moving.x = controls.inputDirection.x;\n          this.targetPos.x += controls.inputDirection.x * CELL_WIDTH;\n          this.col = newCol;\n          // Update looking direction after movement to point ahead  \n          this.map.playerLookingAt = { col: this.col + controls.inputDirection.x, row: this.row };\n        } else {\n          // Blocked movement - still update looking direction to attempted target\n          this.map.playerLookingAt = { col: this.col + controls.inputDirection.x, row: this.row };\n        }\n      }\n\n      if (!this.moving.x && !this.moving.y) {\n        this.animation = CatStates.idle;\n        this.sittingTimer += timeElapsed;\n        if (this.sittingTimer > 2000) {\n          this.animation = CatStates.sit;\n        }\n      } else {\n        this.sittingTimer = 0;\n      }\n\n      // When not attacking, check if playerLookingAt is empty;\n      // If playerLookingAt is empty, look into 4 directions;\n      // If one of the directions is type spirit, set that direction as playerLookingAt;\n      // Else if one of the directions is a statue or obelisk, set that direction as playerLookingAt.\n      if (!this.attacking) {\n        this.autoSelectTarget();\n      }\n\n      if (!this.attacking && controls.isAction1 && !controls.previousState.isAction1) {\n        this.attacking = true;\n        this.animationTime = 0;\n        this.sittingTimer = 0;\n\n        if (!this.pentagramAttack && this.isSurrounded()) {\n          this.pentagramAttack = new PentagramAnimation(\n            drawEngine.ctx1,\n            this.x,\n            this.y,\n            () => {\n              this.pentagramAttack = null;\n              this.attackAllEnemiesAround();\n              this.attacking = false;\n              attack5();\n            },\n          );\n        } else {\n          // Check if there is an enemy right in front\n          addTimeEvent(() => this.attackEnemyInFront(), 500);\n          addTimeEvent(() => {\n            this.attacking = false;\n          }, this.aD * 5);\n        }\n      }\n    }\n    this.pentagramAttack?.update(timeElapsed);\n  }\n\n  // Deals 5 damage to all spirits\n  // in the 9 cells around the cat.\n  attackAllEnemiesAround() {\n    forEachSurroundingCell(this.col, this.row, (col, row) => {\n      const cell = this.map.grid[row][col];\n      if (cell.content?.type === 'spirit') {\n        const spirit = cell.content as Spirit;\n        spirit.takeDamage(5);\n      }\n    });\n  }\n\n  // Returns true if there are 3 or more spirits\n  // in the 9 cells around the cat.\n  isSurrounded() {\n    let spiritCount = 0;\n    forEachSurroundingCell(this.col, this.row, (col, row) => {\n      const cell = this.map.grid[row][col];\n      if (cell.content?.type === 'spirit') {\n        spiritCount++;\n      }\n    });\n    return spiritCount >= 3;\n  }\n\n  draw() {\n    // Draw shadow glow under cat\n    // drawEngine.drawCircumference(\n    //   drawEngine.ctx1,\n    //   this.x + CELL_WIDTH / 2 + (this.mirrored ? -1 : 1),\n    //   this.y + CELL_HEIGHT * 3 / 4,\n    //   CELL_WIDTH / 2,\n    //   CELL_HEIGHT / 4,\n    //   colors.purple0 + 55,\n    //   CELL_WIDTH,\n    // );\n  \n    super.draw();\n    this.pentagramAttack?.draw();\n  }\n\n  private autoSelectTarget() {\n    // Check if current looking position is empty\n    const currentCell = this.map.getLookingAt();\n    if (currentCell?.content) {\n      return; // Already looking at something\n    }\n\n    // Check 4 directions around player\n    const directions = [\n      { col: this.col + 1, row: this.row, facing: 'right' },\n      { col: this.col - 1, row: this.row, facing: 'left' },\n      { col: this.col, row: this.row + 1, facing: 'down' },\n      { col: this.col, row: this.row - 1, facing: 'up' },\n    ];\n\n    let spiritTarget = null;\n    let statueTarget = null;\n    let spiritFacing = null;\n    let statueFacing = null;\n\n    for (const dir of directions) {\n      const cell = this.map.grid[dir.row][dir.col];\n      if (!cell.content) continue;\n\n      const contentType = cell.content.type;\n\n      // Prioritize spirits first\n      if (contentType === 'spirit') {\n        spiritTarget = { col: dir.col, row: dir.row };\n        spiritFacing = dir.facing;\n        break; // Spirit has highest priority, stop searching\n      }\n\n      // Store statue/obelisk as backup\n      if ((contentType === 'statue' || contentType === 'obelisk') && !statueTarget) {\n        statueTarget = { col: dir.col, row: dir.row };\n        statueFacing = dir.facing;\n      }\n    }\n\n    // Set target and facing based on priority: spirit > statue/obelisk\n    if (spiritTarget) {\n      this.map.playerLookingAt = spiritTarget;\n      if (spiritFacing === 'left') this.mirrored = true;\n      else if (spiritFacing === 'right') this.mirrored = false;\n      // Optionally handle up/down facing if needed\n    } else if (statueTarget) {\n      this.map.playerLookingAt = statueTarget;\n      if (statueFacing === 'left') this.mirrored = true;\n      else if (statueFacing === 'right') this.mirrored = false;\n      // Optionally handle up/down facing if needed\n    }\n  }\n\n  private attackEnemyInFront() {\n    // Check if there's a spirit at the target position\n    const cell = this.map.getLookingAt();\n    if (cell.content && cell.content.type === 'spirit') {\n      const spirit = cell.content as Spirit;\n      spirit.takeDamage(1);\n      attack();\n    } else if (cell.content && cell.content.type === 'field') {\n      cell.content = null;\n      step(3);\n    }\n  }\n}\n","import { CELL_HEIGHT, CELL_WIDTH } from '@/game/constants';\nimport { Drawable } from '@/game/Drawable';\nimport { drawEngine } from './draw-engine';\n\nexport class GameStaticObject implements Drawable {\n  public col: number;\n  public row: number;\n  public offsetX: number;\n  public offsetY: number;\n\n  constructor(\n    public img: HTMLImageElement,\n    public x: number,\n    public y: number,\n    public type: string,\n  ) {\n    this.col = Math.ceil(x / CELL_WIDTH);\n    this.row = Math.ceil(y / CELL_HEIGHT);\n    this.offsetX = x - Math.round((img.width - CELL_WIDTH) / 2);\n    this.offsetY = y - Math.round((img.height - CELL_HEIGHT) / 2);\n  }\n\n  draw() {\n    drawEngine.drawBackgroundImage(this.img, this.offsetX, this.offsetY);\n  }\n}\n","import { GameAssets } from '@/game/game-assets';\nimport { drawEngine } from '@/core/draw-engine';\nimport { CELL_WIDTH, CELL_HEIGHT } from '@/game/constants';\nimport { GameStaticObject } from '@/core/game-static-object';\n\nexport class Tree extends GameStaticObject {\n  private neighbors: { top: boolean; bottom: boolean; left: boolean; right: boolean } = {\n    top: false,\n    bottom: false,\n    left: false,\n    right: false,\n  };\n\n  constructor(\n    public x: number,\n    public y: number,\n    treeType: 'oak' | 'spruce',\n  ) {\n    super(\n      GameAssets[treeType],\n      x,\n      y,\n      treeType,\n    );\n  }\n\n  setNeighbors(neighbors: { top: boolean; bottom: boolean; left: boolean; right: boolean }) {\n    this.neighbors = neighbors;\n  }\n\n  draw() {\n    if (this.neighbors.right) {\n      drawEngine.drawBackgroundImage(this.img, Math.round(this.offsetX + CELL_WIDTH / 2), this.offsetY - CELL_HEIGHT / 2);\n    }\n    super.draw();\n  }\n}\n","// Seeded \"random\" number generator for deterministic randomness\nexport class SeededRandom {\n  constructor(public rngSeed: number = 47) {}\n  \n  next(): number {\n    this.rngSeed = (this.rngSeed * 9301 + 49297) % 233280;\n    return this.rngSeed / 233280;\n  }\n  \n  range(min: number, max: number): number {\n    return min + this.next() * (max - min);\n  }\n}\n","import { GameAssets } from '../game-assets';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { GameStaticObject } from '@/core/game-static-object';\n\nexport class House extends GameStaticObject {\n  name;\n\n  constructor(col: number, row: number, name = '') {\n    super(\n      GameAssets.house,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'house',\n    );\n    this.name = name;\n  }\n}\n","import { GameObject } from '@/core/game-object';\nimport { GameAssets, VillagerStates } from '../game-assets';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { GameMap } from '../game-map';\nimport { emit } from '@/core/event';\nimport { GameEvent } from '../event-manifest';\n\nexport class Villager extends GameObject<VillagerStates> {\n  lastDirection: { x: number; y: number } | null = null;\n  moveTimer: number = 0;\n  moveInterval: number = 1000;\n  isScared = false;\n\n  constructor(col: number, row: number, private map: GameMap) {\n    super(\n      GameAssets.villager,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'villager',\n      VillagerStates.walk,\n      10,\n    );\n  }\n\n  update(timeElapsed: number): void {\n    super.update(timeElapsed);\n\n    this.moveTimer += timeElapsed;\n    if (this.seesCat()) {\n      if (!this.isScared && this.moveTimer >= this.moveInterval) {\n        this.moveTimer = 0;\n        this.isScared = true;\n      }\n      if (this.moveTimer % (this.moveInterval / 5) < timeElapsed) {\n        emit(GameEvent.SCARED);\n      }\n      this.animation = VillagerStates.scared;\n      this.aD = 50;\n    } else {\n      this.isScared = false;\n      this.aD = 150;\n      if (this.moveTimer >= this.moveInterval) {\n        this.takeNextStep();\n        this.moveTimer = 0;\n      }\n      this.updatePositionSmoothly(timeElapsed);\n    }\n  }\n\n  // Looks around for an empty cell to move to.\n  // Has 50% chance of moving forward in the same direction as before.\n  // Otherwise moves in a random direction, if that direction is free. \n  takeNextStep(): void {\n    const directions = [\n      { x: 0, y: -1 },\n      { x: 0, y: 1 }, \n      { x: 1, y: 0 },\n      { x: -1, y: 0 }\n    ];\n\n    // 80% chance to continue in same direction\n    if (this.lastDirection && Math.random() < 0.8) {\n      const newCol = this.col + this.lastDirection.x;\n      const newRow = this.row + this.lastDirection.y;\n      if (this.isValidMove(newCol, newRow)) {\n        this.col = newCol;\n        this.row = newRow;\n        this.targetPos = { x: newCol * CELL_WIDTH, y: newRow * CELL_HEIGHT };\n        this.lastDirection = this.lastDirection;\n        this.animation = VillagerStates.walk;\n        return;\n      }\n    }\n\n    // Try random directions without shuffling\n    for (let i = 0; i < 10; i++) {\n      const dir = directions[Math.floor(Math.random() * 4)];\n      const newCol = this.col + dir.x;\n      const newRow = this.row + dir.y;\n      if (this.isValidMove(newCol, newRow)) {\n        this.col = newCol;\n        this.row = newRow;\n        this.targetPos = { x: newCol * CELL_WIDTH, y: newRow * CELL_HEIGHT };\n        this.lastDirection = dir;\n        this.animation = VillagerStates.walk;\n        return;\n      }\n    }\n  }\n\n  private isValidMove(col: number, row: number): boolean {\n    // Check if cell is empty\n    const cell = this.map.grid[row][col];\n    return cell.content === null;\n  }\n\n  /**\n   * Checks 2 cells in front in the movement direction for a cat.\n   */\n  seesCat(): boolean {\n    if (!this.lastDirection) return false;\n\n    for (let i = 1; i <= 2; i++) {\n      const checkCol = this.col + this.lastDirection.x * i;\n      const checkRow = this.row + this.lastDirection.y * i;\n      \n      const cell = this.map.grid[checkRow]?.[checkCol];\n      if (cell?.content?.type === 'cat') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n","import { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { GameStaticObject } from '@/core/game-static-object';\nimport { GameAssets } from '../game-assets';\n\nexport class Farm extends GameStaticObject {\n  constructor(col: number, row: number) {\n    super(\n      GameAssets.grass,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'field',\n    );\n  }\n}\n","import { SeededRandom } from '@/core/util/rng';\nimport { House } from './house';\nimport { GameMap } from '../game-map';\nimport { Villager } from './villager';\nimport { Farm } from './farm';\n\nexport class Village {\n  houses: House[] = [];\n  farms: Farm[] = [];\n  villagers: Villager[] = [];\n\n  constructor(\n    public name: string,\n    public center: { x: number; y: number },\n    public radius: number,\n    public houseCount: number,\n    public population: number,\n  ) {\n    this.center = center;\n    this.radius = radius;\n  }\n\n  private generatePosition(rng: SeededRandom, existing: { x: number; y: number }[], map: GameMap): { x: number; y: number } {\n    let col: number;\n    let row: number;\n    do {\n      const angle = rng.range(0, Math.PI * 2);\n      const distance = rng.range(1, this.radius - 1);\n      col = Math.round(this.center.x + Math.cos(angle) * distance);\n      row = Math.round(this.center.y + Math.sin(angle) * distance);\n    } while (\n      col < 0 ||\n      row < 0 ||\n      map.get(col, row)?.content !== null ||\n      existing.some(item => item.x === col && item.y === row)\n    );\n    return { x: col, y: row };\n  }\n\n  generateHouses(rng: SeededRandom, map: GameMap): House[] {\n    for (let i = 0; i < this.houseCount; i++) {\n      const pos = this.generatePosition(rng, this.houses, map);\n      const houseCol = pos.x + pos.x % 2;\n      const houseRow = pos.y + pos.y % 2;\n      this.houses.push(new House(houseCol, houseRow));\n    }\n    return this.houses;\n  }\n\n  generateFarms(rng: SeededRandom, map: GameMap): Farm[] {\n    const farmCount = this.houseCount;\n    for (let i = 0; i < farmCount; i++) {\n      const pos = this.generatePosition(rng, this.farms, map);\n      \n      // Create a 2x2 farm block\n      for (let dx = 0; dx < 2; dx++) {\n        for (let dy = 0; dy < 2; dy++) {\n          this.farms.push(new Farm(pos.x + dx, pos.y + dy));\n        }\n      }\n    }\n    return this.farms;\n  }\n\n  generateVillagers(rng: SeededRandom, map: GameMap): Villager[] {\n    for (let i = 0; i < this.population; i++) {\n      const pos = this.generatePosition(rng, this.farms, map);\n      this.villagers.push(new Villager(pos.x, pos.y, map));\n    }\n    return this.villagers;\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\n\nexport class Icon {\n  x: number;\n  y: number;\n\n  constructor(\n    public readonly icon: HTMLImageElement,\n    public col: number,\n    public row: number,\n    public type: string,\n  ) {\n    this.x = Math.round(this.col * CELL_WIDTH + (CELL_WIDTH - this.icon.width) / 2);\n    this.y = Math.round(this.row * CELL_HEIGHT + (CELL_HEIGHT - this.icon.height) / 2);\n  }\n\n  draw() {\n    drawEngine.drawBackgroundImage(this.icon, this.x, this.y);\n  }\n}\n","import { Cell } from './types';\n\nexport interface Coords {\n  col: number;\n  row: number;\n}\n\nexport interface Position {\n  x: number;\n  y: number;\n}\n\nexport interface PathNode {\n  pos: Position;\n  distance: number;\n  previous?: PathNode;\n}\n\n// Directions: north, south, east, west\nconst directions: ReadonlyArray<Readonly<{ x: number; y: number }>> = [\n  { x: 0, y: -1 }, // north\n  { x: 0, y: 1 },  // south\n  { x: 1, y: 0 },  // east\n  { x: -1, y: 0 }  // west\n] as const;\n\n/**\n * Breadth-first search to find the nearest cell that matches a condition\n * @param grid - 2D array representing the game map\n * @param start - Starting position {x, y}\n * @param matchCondition - Function that returns true if the cell satisfies the condition\n * @param maxSteps - Maximum number of steps to search\n * @returns The position of the matching cell, or null if not found\n */\nexport function findNearestMatch<T>(\n  grid: T[][],\n  start: Position,\n  matchCondition: (cell: T, x: number, y: number) => boolean,\n  maxSteps: number\n): Position | null {\n  const rowCount = grid.length;\n  const colCount = grid[0]?.length || 0;\n\n  if (colCount === 0 || rowCount === 0) return null;\n\n  // Check if starting position matches\n  if (matchCondition(grid[start.y][start.x], start.x, start.y)) {\n    return start;\n  }\n\n  const visited = new Set<string>();\n  const queue: PathNode[] = [{ pos: start, distance: 0 }];\n  visited.add(`${start.x},${start.y}`);\n\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n\n    // Check all 4 directions\n    for (const dir of directions) {\n      const newX = current.pos.x + dir.x;\n      const newY = current.pos.y + dir.y;\n      const newDistance = current.distance + 1;\n\n      // Check max steps only\n      if (newDistance > maxSteps) {\n        continue;\n      }\n\n      const key = `${newX},${newY}`;\n      if (visited.has(key)) {\n        continue;\n      }\n\n      visited.add(key);\n\n      // Check if this cell matches our condition\n      if (matchCondition(grid[newY][newX], newX, newY)) {\n        return { x: newX, y: newY };\n      }\n\n      // Add to queue for further exploration\n      queue.push({\n        pos: { x: newX, y: newY },\n        distance: newDistance,\n        previous: current\n      });\n    }\n  }\n\n  return null; // No matching cell found within maxSteps\n}\n\nconst toKey = (col: number, row: number) => {\n  return `${col},${row}`;\n};\n\n// const fromKey = (key): Coords => {\n//   const [col ,row] = key.split(',').map(Number);\n//   return { col, row };\n// };\n\nconst reconstructPath = (parents: Record<string, Coords>, start: Coords, goal: Coords) => {\n  const path: Coords[] = [];\n  let current = goal;\n  while (current != start) {\n    path.unshift(current);\n    current = parents[toKey(current.col, current.row)];\n  }\n  path.unshift(start);\n  return path;\n};\n\n/**\n * Uses breadth-first-search to find the shortest path from\n * start to goal, and returns the path as an array of coords.\n * The path will take at most maxSteps steps.\n * This algo assumes that the map is fully enclosed by a boundary\n * so it is not checking whether the coordinates are valid.\n */\nexport const findShortestPath = (\n  grid: Cell[][],\n  start: Coords,\n  goal: Coords,\n  maxSteps = 100,\n) => {\n  let steps = maxSteps;\n\n  // Start from person A’s position.\n  // Keep a queue of cells to explore.\n  const queue: Coords[] = [start];\n\n  // Keep a record of which cells you’ve already visited, so you don’t loop back.\n  const visited = new Set();\n\n  // Keep a map of coords->cells that keeps track of the paths taken\n  const parents: Record<string, Coords> = {};\n\n  while (queue.length !== 0 && steps--) {\n    // Get the oldest cell from the queue\n    const current = queue.shift() as Coords;\n    if (current.col === goal.col && current.row === goal.row) {\n      return reconstructPath(parents, start, goal);\n    }\n\n    // Check the 4 immediate neighbours\n    const neighbours = directions.map(({x, y}) => grid[current.row + y][current.col + x]);\n    neighbours.forEach((neighbour) => {\n      if (!visited.has(neighbour)) {\n        visited.add(neighbour);\n        if (neighbour.content === null || (neighbour.x == goal.col && neighbour.y == goal.row)) {\n          parents[toKey(neighbour.x, neighbour.y)] = current;\n          queue.push({ col: neighbour.x, row: neighbour.y });\n        }\n      }\n    });\n  }\n};\n\n","import { drawEngine } from '@/core/draw-engine';\nimport { colors } from '@/core/util/color';\nimport { CELL_WIDTH } from '../constants';\n\nconst defaultColors: [string, string, string, string] = [colors.blue1, colors.blue2, colors.purple5, colors.purple4];\n\nexport const drawHpBar = (\n  hp: number,\n  maxHp: number,\n  x: number,\n  y: number,\n  colorHP = defaultColors,\n) => {\n  const hpRatio = Math.max(0, Math.min(1, hp / maxHp));\n  const barWidth = CELL_WIDTH;\n  const barHeight = 1;\n  const hpWidth = Math.ceil(barWidth * hpRatio);\n  const barX = x;\n  const barY = y - 5;\n\n  drawEngine.ctx1.fillStyle = colorHP[0];\n  drawEngine.ctx1.fillRect(barX, barY, hpWidth, barHeight);\n  drawEngine.ctx1.fillStyle = colorHP[1];\n  drawEngine.ctx1.fillRect(barX, barY + 1, hpWidth, barHeight);\n\n  drawEngine.ctx1.fillStyle = colorHP[2];\n  drawEngine.ctx1.fillRect(\n    barX + hpWidth,\n    barY,\n    barWidth - hpWidth,\n    barHeight,\n  );\n  drawEngine.ctx1.fillStyle = colorHP[3];\n  drawEngine.ctx1.fillRect(\n    barX + hpWidth,\n    barY +\n    1,\n    barWidth - hpWidth, barHeight,\n  );\n};\n","import { emojiToPixelArt } from '@/core/emoji';\nimport { Icon } from './icon';\nimport { drawEngine } from '@/core/draw-engine';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { GameMap } from '../game-map';\nimport { updatePositionSmoothly, SmoothMovementState, setTargetPosition } from '@/utils/smooth-movement';\nimport { Coords, findShortestPath } from '../path-findind';\nimport { addTimeEvent } from '@/core/timer';\nimport { emit, on } from '@/core/event';\nimport { drawHpBar } from './hp-bar';\nimport { GameEvent } from '../event-manifest';\nimport { exorcise } from '@/core/audio';\n\nexport type SpiritType = '☁️' | '👻' | '👹' | '🧿' | '🦀' | '🌵' | '🥨' | '🧚🏻‍♀️' | '💀';\n\ninterface SpiritSpecies {\n  type: SpiritType,\n  icon: HTMLImageElement,\n  level: number,\n}\n\nexport const spirits = ([\n  '☁️', '🥨', '🌵', '🧚🏻‍♀️', '🦀', '👻', '👹', '🧿', '💀'\n] as const).reduce<Record<SpiritType, SpiritSpecies>>((acc, type, index) => {\n  acc[type] = { icon: emojiToPixelArt(type), type, level: Math.ceil((index) / 2) };\n  return acc;\n}, {} as Record<SpiritType, SpiritSpecies>);\n\nconst enum SpiritState {\n  DYING,\n  IDLE,\n  MOVING,\n  WINDING,\n  ATTACKING,\n  RESTING\n}\n\nexport class Spirit extends Icon implements SmoothMovementState {\n\n  aD = 2000;\n  animationTime = 0;\n  opacity = 0;\n  species: SpiritSpecies;\n  map: GameMap;\n  searchRadius = 9;\n  moveTimer = 0;\n  moveInterval = 600;\n  targetPos: { x: number; y: number };\n  moving = { x: 0, y: 0 };\n  speed = 20;\n  maxHp: number;\n  hp: number;\n  dead = false;\n  recoil = false;\n  \n  // Simplified state system\n  state: number = SpiritState.IDLE;\n  attackTimer = 0;\n  attackDuration = 1000;\n  attackTarget: Coords | null = null;\n  attackOffsetX = 0;\n  attackOffsetY = 0;\n\n  constructor(\n    col: number,\n    row: number,\n    type: SpiritType,\n    map: GameMap,\n  ) {\n    super(spirits[type].icon, col, row, 'spirit');\n    this.species = spirits[type];\n    this.map = map;\n    this.targetPos = { x: this.x, y: this.y };\n    this.maxHp = Math.round(Math.pow(1.5, this.species.level + 1));\n    this.hp = this.maxHp;\n\n    on(GameEvent.END_SEQUECE_START, () => {\n      this.state = SpiritState.DYING;\n    });\n  }\n\n  updateAnimation(timeElapsed: number) {\n    if (this.hp <= 0) {\n      this.opacity -= timeElapsed / this.aD;\n    };\n\n    this.animationTime += timeElapsed * Math.pow(this.species.level + 0.5, 2);\n    if (this.opacity < 1) {\n      this.opacity += timeElapsed / this.aD;\n    }\n    if (this.animationTime >= this.aD) {\n      this.animationTime -= this.aD;\n    }\n  }\n\n  update(timeElapsed: number) {\n    switch (this.state) {\n      case SpiritState.DYING:\n        break;\n      case SpiritState.IDLE:\n      case SpiritState.MOVING:\n        updatePositionSmoothly(this, timeElapsed);\n        const playerCoords = this.lookAroundForPlayer();\n        if (playerCoords) {\n          this.moveTimer += timeElapsed;\n          if (this.moveTimer >= this.moveInterval) {\n            this.moveTowardsPlayer(playerCoords);\n            this.moveTimer = 0;\n          }\n        }\n        break;\n\n      case SpiritState.WINDING:\n      case SpiritState.ATTACKING:\n      case SpiritState.RESTING:\n        this.updateAttack(timeElapsed);\n        break;\n    }\n  }\n\n  private updateAttack(timeElapsed: number) {\n    if (this.hp <= 0) return;\n\n    this.attackTimer += timeElapsed;\n    const progress = this.attackTimer / this.attackDuration;\n    \n    if (!this.attackTarget) {\n      this.state = SpiritState.IDLE;\n      return;\n    }\n\n    const dirX = this.attackTarget.col - this.col;\n    const dirY = this.attackTarget.row - this.row;\n\n    if (progress < 0.7) {\n      // Winding up\n      if (this.state !== SpiritState.WINDING) this.state = SpiritState.WINDING;\n      const windProgress = progress / 0.7;\n      this.attackOffsetX = -dirX * windProgress * 3;\n      this.attackOffsetY = -dirY * windProgress * 3;\n    } else if (progress < 0.73) {\n      // Attacking\n      if (this.state !== SpiritState.ATTACKING) this.state = SpiritState.ATTACKING;\n      const attackProgress = (progress - 0.7) / 0.03;\n      this.attackOffsetX = dirX * (-3 + CELL_WIDTH * attackProgress);\n      this.attackOffsetY = dirY * (-3 + CELL_WIDTH * attackProgress);\n    } else if (progress < 1.0) {\n      // Resting (returning)\n      if (this.state !== SpiritState.RESTING) {\n        this.state = SpiritState.RESTING;\n        \n        // Only emit if player is still in the target cell\n        const cell = this.map.grid[this.attackTarget.row][this.attackTarget.col];\n        if (cell.content?.type === 'cat') {\n          emit(GameEvent.ATTACK_PLAYER, this.species.level);\n        }\n      }\n      const restProgress = (progress - 0.73) / 0.27;\n      this.attackOffsetX = dirX * 3 * (1 - restProgress);\n      this.attackOffsetY = dirY * 3 * (1 - restProgress);\n    } else {\n      // Attack complete\n      this.state = SpiritState.IDLE;\n      this.attackTimer = 0;\n      this.attackTarget = null;\n      this.attackOffsetX = 0;\n      this.attackOffsetY = 0;\n    }\n  }\n\n  private lookAroundForPlayer(): Coords | null {\n    // Search in a box around the spirit using the search radius\n    for (let dx = -this.searchRadius; dx <= this.searchRadius; dx++) {\n      for (let dy = -this.searchRadius; dy <= this.searchRadius; dy++) {\n        const searchCol = this.col + dx;\n        const searchRow = this.row + dy;\n\n        const cell = this.map.grid[searchRow][searchCol];\n        if (cell.content?.type === 'cat') {\n          return { col: searchCol, row: searchRow };\n        }\n      }\n    }\n    \n    return null;\n  }\n\n  private moveTowardsPlayer(playerCoords: Coords) {\n    const path = findShortestPath(\n      this.map.grid,\n      { col: this.col, row: this.row },\n      playerCoords,\n    );\n    if (path && path.length > 2) {\n      this.state = SpiritState.MOVING;\n      const nextStep = path[1];\n      setTargetPosition(this, nextStep.col, nextStep.row);\n      this.col = nextStep.col;\n      this.row = nextStep.row;\n      this.targetPos.x = nextStep.col * CELL_WIDTH;\n      this.targetPos.y = nextStep.row * CELL_HEIGHT;\n    } else if (path?.length === 2) {\n      // Start attack\n      this.state = SpiritState.WINDING;\n      this.attackTarget = path[1];\n      this.attackTimer = 0;\n    }\n  }\n\n  draw() {\n    const phase = Math.sin((this.animationTime / this.aD) * 2 * Math.PI);\n\n    if (this.hp < this.maxHp) {\n      drawHpBar(this.hp, this.maxHp, this.x, this.y);\n    }\n\n    drawEngine.ctx1.save();\n    drawEngine.ctx1.globalAlpha = this.opacity;\n\n    // Shadow\n    const shadow = Math.round(2 + 1 * phase) / 10;\n    drawEngine.ctx1.fillStyle = `rgba(0,0,0,${shadow})`;\n    drawEngine.ctx1.fillRect(\n      this.x + 3 + this.attackOffsetX,\n      this.y + CELL_HEIGHT * 3 / 4 + this.attackOffsetY,\n      this.icon.width - 6,\n      CELL_HEIGHT / 4 + 1,\n    );\n\n    // Icon\n    drawEngine.ctx1.save();\n    if (this.recoil) {\n      drawEngine.ctx1.filter = 'sepia(1) saturate(2) hue-rotate(260deg) brightness(0.7)';\n    }\n    drawEngine.ctx1.translate(\n      this.attackOffsetX,\n      this.attackOffsetY + Math.round(\n        (phase - 1) * 2\n      )\n    );\n    super.draw();\n    drawEngine.ctx1.restore();\n    drawEngine.ctx1.restore();\n  }\n\n  takeDamage(damage: number = 1): boolean {\n    if (this.hp < 0) true;\n\n    this.hp -= damage;\n    this.recoil = true;\n    addTimeEvent(() => {\n      this.recoil = false;\n    }, 150);\n    if (this.hp <= 0) {\n      exorcise();\n      addTimeEvent(() => {\n        this.opacity -= 0.33;\n      }, 500, 3);\n      addTimeEvent(() => {\n        this.dead = true;\n      }, 1500);\n    }\n    return this.hp <= 0;\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { CELL_HEIGHT, CELL_WIDTH } from '../constants';\nimport { colors } from '@/core/util/color';\n\nexport class MagicCircleAnimation {\n  animationTimer = 0;\n  static animationDuration = 1500;\n  progress = 0;\n  cx: number;\n  cy: number;\n  isDone = false;\n\n  constructor(\n    private x: number,\n    private y: number,\n  ) {\n    this.cx = this.x + CELL_WIDTH / 2;\n    this.cy = this.y + CELL_HEIGHT / 2;\n  }\n\n  update(timeElapsed: number) {\n    this.animationTimer += timeElapsed;\n    this.progress = this.animationTimer / MagicCircleAnimation.animationDuration;\n\n    if (this.progress >= 1) {\n      this.isDone = true;\n    }\n  }\n\n  draw() {\n    if (this.isDone) return;\n\n    const animationProgress = (3 * this.progress) % 1;\n    \n    const maxWidth = c2.width / drawEngine.zoom;\n    const maxHeight = c2.height / drawEngine.zoom;\n    const rx = maxWidth * animationProgress;\n    const ry = maxHeight * animationProgress;\n    drawEngine.drawCircumference(\n      drawEngine.ctx1,\n      this.cx,\n      this.cy,\n      rx,\n      ry,\n      colors.white,\n      8,\n    );\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { GameAssets } from '../game-assets';\nimport { CELL_HEIGHT, CELL_WIDTH, MAX_REPAIR } from '../constants';\nimport { Spirit, spirits } from './spirit';\nimport { GameMap } from '../game-map';\nimport { GameData } from '../game-data';\nimport { drawHpBar } from './hp-bar';\nimport { colors } from '@/core/util/color';\nimport { drawEngine } from '@/core/draw-engine';\nimport { GameStaticObject } from '@/core/game-static-object';\nimport { MagicCircleAnimation } from './magic-animation';\nimport { addTimeEvent } from '@/core/timer';\n\nexport class Statue extends GameStaticObject {\n  static readonly State = {\n    BROKEN: 0,\n    ANIMATING: 1,\n    REPAIRED: 2\n  } as const;\n\n  spirits: Spirit[] = [];\n  maxSpirits = 4;\n  spawnTimer = 0;\n  spawnInterval = 1000;\n  spawnChance = 0.10;\n  spawnRadius = 10;\n  repair = 0;\n  state: number = Statue.State.BROKEN;\n  animationTime = 0;\n  spiritsExorcised = false;\n  lastClearTime = 0;\n\n  magicCircleAnimation: MagicCircleAnimation | null = null;\n\n  /**\n   * Animation duration\n   */\n  aD = 800;\n\n  constructor(\n    col: number,\n    row: number,\n    public map: GameMap,\n    public gameData: GameData,\n    public name: string,\n  ) {\n    super(\n      GameAssets.statue,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'statue',\n    );\n  }\n\n  updateAnimation(timeElapsed: number) {\n    this.animationTime += timeElapsed;\n  }\n\n  update(timeElapsed: number) {\n    this.spawnTimer += timeElapsed;\n\n    if (this.state === Statue.State.BROKEN && this.repair >= MAX_REPAIR) {\n      this.state = Statue.State.ANIMATING;\n      this.spiritsExorcised = false; // Reset flag when starting animation\n      this.lastClearTime = 0; // Reset clear timer\n      this.magicCircleAnimation = new MagicCircleAnimation(this.x, this.y);\n    } else if (this.magicCircleAnimation) {\n      this.magicCircleAnimation.update(timeElapsed);\n      if (this.magicCircleAnimation.isDone) {\n        this.state = Statue.State.REPAIRED;\n        this.magicCircleAnimation = null;\n      }\n    }\n    \n    if (this.spawnTimer >= this.spawnInterval) {\n      this.spawnTimer = 0;\n\n      if (Math.random() < this.spawnChance) {\n        if (this.spirits.length < (this.maxSpirits + this.gameData.getLevel())) {\n          // Spawn new spirit\n          this.spawnSpirit();\n        } else if (this.spirits.length > 0) {\n          // Replace spirits with full HP\n          const replaceSpirit = this.spirits\n            .filter((spirit) => spirit.hp === spirit.maxHp)\n            [Math.round(Math.random() * this.spirits.length - 1)];\n          if (replaceSpirit) {\n            replaceSpirit.dead = true;\n            this.spawnSpirit();\n          }\n        }\n      }\n    }\n\n    this.spirits = this.spirits.filter(spirit => !spirit.dead);\n  }\n\n  draw() {\n    super.draw();\n    if (this.repair > 0 && this.repair < MAX_REPAIR) {\n      drawHpBar(this.repair, MAX_REPAIR, this.x, this.y, [colors.yellow1, colors.yellow2, colors.blue5, colors.blue6]);\n    }\n    if (this.state === Statue.State.REPAIRED) {\n      this.drawFaries();\n    }\n  }\n\n  postDraw() {\n    if (this.magicCircleAnimation) {\n      this.magicCircleAnimation.draw();\n    \n      if (this.magicCircleAnimation.animationTimer - this.lastClearTime >= 20) {\n        const progress = this.magicCircleAnimation.progress;\n        this.map.clearCircleWithJitter(this.col, this.row, 20 * progress, true, 2, 0.3);\n        this.lastClearTime = this.magicCircleAnimation.animationTimer;\n      }\n      \n      // Only exorcise spirits once at the beginning of the animation\n      if (!this.spiritsExorcised) {\n        this.spirits.forEach((spirit, i) => {\n          addTimeEvent(() => {\n            spirit.takeDamage(spirit.hp);\n          }, i * 100);\n        });\n        this.spiritsExorcised = true;\n      }\n    }\n  }\n\n  drawFaries() {\n    const radius = 3;\n    drawEngine.ctx1.fillStyle = colors.purple0;\n    \n    for (let i = 0; i < 5; i++) {\n      const t = (this.animationTime + this.aD * 0.5 * i) / this.aD;\n      const theta = (i * 2 * Math.PI) / 3; // 0, 120°, 240°\n      // Offset distance from statue center\n      const offsetDist = 3; // adjust as needed\n      const offsetX = Math.cos(theta) * offsetDist;\n      const offsetY = Math.sin(theta) * offsetDist;\n\n      // Infinity path at t, rotated by theta\n      const x0 = radius * 2 * Math.sin(t);\n      const y0 = radius * Math.sin(2 * t);\n      const x = x0 * Math.cos(theta) - y0 * Math.sin(theta);\n      const y = x0 * Math.sin(theta) + y0 * Math.cos(theta);\n\n      // Final position: statue center + offset + rotated path\n      const px = Math.round(this.x + CELL_WIDTH / 2 + offsetX + x);\n      const py = Math.round(this.y + CELL_HEIGHT / 3 + offsetY + y);\n\n      drawEngine.ctx1.fillRect(px, py, 1, 1);\n    }\n  }\n\n  private spawnSpirit() {\n    // Find a random empty cell within a 20x20 area around the statue\n    const emptyCells: { x: number; y: number }[] = [];\n    const spawnRadius = Math.round(this.gameData.getLevel() + this.spawnRadius);\n    \n    // Collect all empty cells within the search radius\n    for (let dx = -spawnRadius; dx <= spawnRadius; dx++) {\n      for (let dy = -spawnRadius; dy <= spawnRadius; dy++) {\n        const x = this.col + dx;\n        const y = this.row + dy;\n        \n        // Check if cell is empty\n        if (this.map.grid[y][x].content === null) {\n          emptyCells.push({ x, y });\n        }\n      }\n    }\n\n    // Select a random empty cell\n    if (emptyCells.length > 0) {\n      const randomIndex = Math.floor(Math.random() * emptyCells.length);\n      const selectedPosition = emptyCells[randomIndex];\n      \n      // TODO: only spawn spirits of the appropriate level for the current game\n      const spiritTypes = Object.values(spirits)\n        .filter((spirit) => spirit.level < this.gameData.getLevel());\n      if (spiritTypes.length === 0) return;\n\n      const randomType = spiritTypes[Math.floor(Math.random() * spiritTypes.length)];\n      \n      const spirit = new Spirit(selectedPosition.x, selectedPosition.y, randomType.type, this.map);\n      this.spirits.push(spirit);\n      \n      // Place the spirit directly in the map\n      this.map.set(selectedPosition.x, selectedPosition.y, spirit);\n    }\n  }\n}\n","import { GameAssets } from '../game-assets';\nimport { CELL_HEIGHT, CELL_WIDTH, MAX_MAGIC, MAX_REPAIR } from '../constants';\nimport { GameMap } from '../game-map';\nimport { drawHpBar } from './hp-bar';\nimport { colors } from '@/core/util/color';\nimport { emit } from '@/core/event';\nimport { GameEvent } from '../event-manifest';\nimport { GameStaticObject } from '@/core/game-static-object';\nimport { repair } from '@/core/audio';\nimport { MagicCircleAnimation } from './magic-animation';\n\nexport class Obelisk extends GameStaticObject {\n  map: GameMap;\n  name = 'barrier obelisk';\n  repair = 0;\n  magicCircleAnimation: MagicCircleAnimation | null = null;\n  \n  constructor(map: GameMap) {\n    const col = 69;\n    const row = 88; \n    super(\n      GameAssets.obelisk,\n      col * CELL_WIDTH,\n      row * CELL_HEIGHT,\n      'obelisk',\n    );\n    this.map = map;\n    this.map.set(this.col, this.row, this);\n  }\n\n  update(timeElapsed: number) {\n    this.magicCircleAnimation?.update(timeElapsed);\n  }\n\n  startAnimation () {\n    this.magicCircleAnimation = new MagicCircleAnimation(this.x, this.y);\n  }\n\n  draw() {\n    super.draw();\n    if (this.repair > 0) {\n      drawHpBar(this.repair, MAX_REPAIR, this.x, this.y, [colors.yellow1, colors.yellow2, colors.blue5, colors.blue6]);\n    }\n  }\n\n  postDraw() {\n    this.magicCircleAnimation?.draw();\n  }\n\n  attemptRepair() {\n    const maxProgress = this.map.gameData.magic / MAX_MAGIC;\n    const maxRepair = MAX_REPAIR * maxProgress;\n    if (this.repair < maxRepair) {\n      this.repair ++;\n      repair(2 * this.repair - 10);\n    } else {\n      repair(-10);\n      emit(GameEvent.NOT_ENOUGH_MAGIC);\n    }\n\n    if (this.repair === MAX_REPAIR) {\n      emit(GameEvent.END_SEQUECE_START);\n    }\n  }\n}\n","import { Tree } from './entities/tree';\nimport { SeededRandom } from '@/core/util/rng';\nimport { Village } from './entities/village';\nimport { CELL_HEIGHT, CELL_WIDTH, clearings, paths, statues } from './constants';\nimport { Statue } from './entities/statue';\nimport { Cell, Path } from './types';\nimport { Drawable } from './Drawable';\nimport { on } from '@/core/event';\nimport { Spirit } from './entities/spirit';\nimport { Coords } from './path-findind';\nimport { drawEngine } from '@/core/draw-engine';\nimport { GameAssets } from './game-assets';\nimport { GameData } from './game-data';\nimport { GameEvent } from './event-manifest';\nimport { Farm } from './entities/farm';\nimport { forEachSurroundingCell } from './grid-utils';\nimport { House } from './entities/house';\nimport { Obelisk } from './entities/obelisk';\n\nexport class GameMap {\n  grid: Cell[][];\n  villages: Village[] = [];\n  private rng: SeededRandom;\n  playerLookingAt: Coords = { col: 0, row: 0 };\n  statues: Statue[] = [];\n  obelisk: Obelisk;\n\n  constructor(\n    public readonly colCount: number,\n    public readonly rowCount: number,\n    public gameData: GameData,\n  ) {\n    this.rng = new SeededRandom();\n\n    this.grid = Array.from({ length: rowCount }, (_a, y) =>\n      Array.from({ length: colCount }, (_b, x) => {\n        // Determine tree species based on distance from Heart Peak (70, 90)\n        const dx = x - 70;\n        const dy = y - 90;\n        const distanceFromHeartPeak = Math.sqrt(dx * dx + dy * dy);\n        \n        let treeType: 'oak' | 'spruce';\n        if (distanceFromHeartPeak <= 40) {\n          // Within 20 cell radius of Heart Peak: 90% spruce, 10% oak\n          treeType = this.rng.next() < 0.9 ? 'spruce' : 'oak';\n        } else {\n          // Rest of map: 20% spruce, 80% oak\n          treeType = this.rng.next() < 0.2 ? 'spruce' : 'oak';\n        }\n        \n        const tree = new Tree(\n          x * CELL_WIDTH - (16 - CELL_WIDTH) / 2, // Adjust x to center the image\n          y * CELL_HEIGHT - (16 - CELL_HEIGHT) / 2, // Adjust y to center the image\n          treeType\n        );\n        return { x, y, content: tree };\n      })\n    );\n\n    this.villages = [\n      new Village('Heart Peak', { x: 70, y: 90 }, 12, 0, 0),\n      new Village('Pine Rest', { x: 99, y: 100 }, 6, 2, 3),\n      new Village('Oak Branch', { x: 42, y: 51 }, 4, 3, 4),\n      new Village('Cat Foot', { x: 48, y: 140 }, 5, 4, 5),\n      new Village('Black Tail', { x: 113, y: 107 }, 4, 5, 8),\n      new Village('Moon Town', { x: 129, y: 29 }, 8, 12, 25),\n    ];\n\n\n    // Clear paths with jitter\n    for (const path of paths) {\n      for (let i = 0; i < path.length - 1; i++) {\n        const from = { x: path[i][0], y: path[i][1] };\n        const to = { x: path[i + 1][0], y: path[i + 1][1] };\n        const pathWidth = path[i][2];\n        this.clearPathWithJitter(from, to, pathWidth);\n      }\n    }\n\n    // Clear circular areas with jitter\n    for (const clearing of clearings) {\n      this.clearCircleWithJitter(clearing.x, clearing.y, clearing.r);\n    }\n\n    // Calculate neighbor information for each tree\n    for (let y = 0; y < rowCount; y++) {\n      for (let x = 0; x < colCount; x++) {\n        const cell = this.grid[y][x];\n        if (cell.content instanceof Tree) {\n          const neighbors = {\n            top: this.grid[y - 1]?.[x]?.content instanceof Tree,\n            bottom: this.grid[y + 1]?.[x]?.content instanceof Tree,\n            left: this.grid[y]?.[x - 1]?.content instanceof Tree,\n            right: this.grid[y]?.[x + 1]?.content instanceof Tree,\n          };\n          cell.content.setNeighbors(neighbors);\n        }\n      }\n    }\n\n    for (const village of this.villages) {\n      village.generateFarms(this.rng, this)\n        .forEach(farm => {\n          this.grid[farm.row][farm.col].content = farm;\n        });\n      village.generateHouses(this.rng, this)\n        .forEach(house => {\n          this.grid[house.row][house.col].content = house;\n        });\n      village.generateVillagers(this.rng, this)\n        .forEach(villager => {\n          this.grid[villager.row][villager.col].content = villager;\n        });\n\n      // Set cell.village for each cell in the village radius\n      const { x: centerX, y: centerY } = village.center;\n      const radius = village.radius;\n      for (let y = centerY - radius; y <= centerY + radius; y++) {\n      for (let x = centerX - radius; x <= centerX + radius; x++) {\n          const dx = x - centerX;\n          const dy = y - centerY;\n          if (dx * dx + dy * dy <= radius * radius) {\n            this.grid[y][x].village = village;\n          }\n        }\n      }\n\n      // Generate starting home\n      this.set(61, 84, new House(61, 84, 'home'));\n    }\n\n    this.fillCenterWithGrass(1.0);\n\n    this.obelisk = new Obelisk(this);\n\n    for (const statueProps of Object.values(statues)) {\n      const { x, y, name } = statueProps;\n      const fullName = `cat ${name} altar`;\n      const statue = new Statue(x, y, this, this.gameData, fullName);\n      // Place farms in the 8 squares around the statue\n      forEachSurroundingCell(x, y, (farmCol, farmRow) => {\n        const cell = this.grid[farmRow][farmCol];\n        cell.content = new Farm(farmCol, farmRow);\n      });\n      this.grid[y][x].content = statue;\n      this.statues.push(statue);\n    }\n\n    on(GameEvent.SPAWN_FIRST_SPIRIT, () => {\n      // Spawn a single cloud spirit\n      this.set(64, 89, new Spirit(64, 89, '☁️', this));\n    });\n  }\n\n  getLookingAt() {\n    return this.grid[this.playerLookingAt.row][this.playerLookingAt.col];\n  }\n\n  get(col: number, row: number) {\n    if (row < 0 || row >= this.rowCount || col < 0 || col >= this.colCount) {\n      return null;\n    }\n    return this.grid[row][col];\n  }\n\n  clearPlants(col: number, row: number) {\n    if(\n      this.grid[row][col].content instanceof Tree\n      || this.grid[row][col].content instanceof Farm\n    ) {\n      this.grid[row][col].content = null;\n    }\n  }\n\n  // Fill the center area with fields to limit player movements\n  // until they finish the onboarding.\n  // Then clear out a path from where the player starts, to the obelisk,\n  // and to the heart statue.\n  fillCenterWithGrass(converage: number) {\n    const heartsPeak = this.villages[0];\n    const radius = 12;\n    const { x: centerX, y: centerY } = heartsPeak.center;\n    for (let y = centerY - radius; y <= centerY + radius; y++) {\n      for (let x = centerX - radius; x <= centerX + radius; x++) {\n        const cell = this.grid[y][x];\n        if (!cell.content && this.rng.next() <= converage) {\n          cell.content = new Farm(cell.x, cell.y);\n        } else if (cell.content instanceof Farm && this.rng.next() > converage) {\n          cell.content = null;\n        }\n      }\n    }\n    \n    const villagePath: Path = [\n      [61, 86, 2],\n      [69, 88, 0.9],\n      [75, 89, 0.9],\n      [76, 84, 0.9],\n    ];\n    for (let i = 0; i < villagePath.length - 1; i++) {\n      const from = { x: villagePath[i][0], y: villagePath[i][1] };\n      const to = { x: villagePath[i + 1][0], y: villagePath[i + 1][1] };\n      const pathWidth = villagePath[i][2];\n      this.clearPathWithJitter(from, to, pathWidth);\n    }\n  }\n\n  clearPathWithJitter(\n    from: { x: number, y: number },\n    to: { x: number, y: number },\n    pathWidth: number,\n  ) {\n    // Bresenham's line algorithm for any angle\n    const dx = Math.abs(to.x - from.x);\n    const dy = Math.abs(to.y - from.y);\n    const sx = from.x < to.x ? 1 : -1;\n    const sy = from.y < to.y ? 1 : -1;\n    let err = dx - dy;\n\n    let x = from.x;\n    let y = from.y;\n\n    const halfWidth = pathWidth / 2;\n\n    while (true) {\n      // Add jitter to the clearing area\n      const jitterAmount = pathWidth < 1 ? 0 : 1.2; // Adjust for more/less randomness\n      const jitterX = Math.ceil(this.rng.range(-jitterAmount, jitterAmount));\n      const jitterY = Math.ceil(this.rng.range(-jitterAmount, jitterAmount));\n\n      // Clear area around the current position with jitter\n      for (let ox = -halfWidth; ox <= halfWidth; ox++) {\n        for (let oy = -halfWidth; oy <= halfWidth; oy++) {\n          const clearX = Math.ceil(x + ox + jitterX);\n          const clearY = Math.ceil(y + oy + jitterY);\n          this.clearPlants(clearX, clearY);\n          if (pathWidth < 1) {\n            if (this.rng.next() > 0.5) {\n              this.clearPlants(clearX + 1, clearY);\n            } else {\n              this.grid[clearY][clearX].content = new Farm(clearX, clearY);\n              this.grid[clearY][clearX + 1].content = new Farm(clearX, clearY);\n            }\n          } else if (this.rng.next() > 0.1) {\n            if (this.rng.next() > 0.05) {\n              // Add probability for partial clearing to create natural edges\n              this.clearPlants(clearX, clearY);\n            } else {\n              this.grid[clearY][clearX].content = new Farm(clearX, clearY);\n            }\n          }\n        }\n      }\n\n      // Check if we've reached the destination\n      if (x === to.x && y === to.y) break;\n\n      const e2 = 2 * err;\n      if (e2 > -dy) {\n        err -= dy;\n        x += sx;\n      }\n      if (e2 < dx) {\n        err += dx;\n        y += sy;\n      }\n    }\n  }\n\n  clearCircleWithJitter(\n    centerX: number,\n    centerY: number,\n    radius: number,\n    fieldsOnly = false,\n    border = 99,\n    probability = 1,\n  ) {\n    for (let y = 0; y < this.rowCount; y++) {\n      for (let x = 0; x < this.colCount; x++) {\n        const dx = x - centerX;\n        const dy = y - centerY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Add jitter to radius for natural edge\n        const jitterRadius = this.rng.range(-radius, radius) / 6;\n        const adjustedRadius = radius + jitterRadius;\n\n        // Calculate inner radius based on borderRatio\n        const innerRadius = adjustedRadius - border;\n        \n        if (distance >= innerRadius && distance <= adjustedRadius) {\n          // Add probability for partial clearing near edges\n          const edgeDistance = adjustedRadius - distance;\n          const clearProbability = Math.min(1, edgeDistance / 2 + 0.7) * probability;\n\n          if (this.rng.next() < clearProbability) {\n            const isFarm = this.grid[y][x].content instanceof Farm;\n            if (!fieldsOnly || fieldsOnly && isFarm) {\n              this.grid[y][x].content = null;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  set(col: number, row: number, content: Drawable | null) {\n    if (this.grid[row] && this.grid[row][col]) {\n      this.grid[row][col].content = content;\n    }\n  }\n\n  update(timeElapsed: number, isCutscene: boolean) {\n    for (const row of this.grid) {\n      for (const cell of row) {\n        if (cell.content) {\n          cell.content.updateAnimation?.(timeElapsed);\n          if (!isCutscene) {\n            cell.content.update?.(timeElapsed);\n            if (cell.x != cell.content.col || cell.y != cell.content.row) {\n              this.grid[cell.content.row][cell.content.col].content = cell.content;\n              cell.content = null;\n            }\n            if (cell.content && (cell?.content as Spirit)?.dead) {\n              this.set(cell.content.col, cell.content.row, null);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  draw(cameraX: number, cameraY: number) {\n    const zoom = drawEngine.zoom;\n    const renderWidth = (drawEngine.canvasWidth / zoom) / 2 + 50;\n    const renderHeight = (drawEngine.canvasHeight / zoom) / 2 + 50;\n    const seenRadius = 75;\n    const seenRadiusSquared = seenRadius * seenRadius;\n\n    // Compute visible cell bounds\n    const minCol = Math.max(0, Math.floor((cameraX - renderWidth) / CELL_WIDTH));\n    const maxCol = Math.min(this.colCount - 1, Math.ceil((cameraX + renderWidth) / CELL_WIDTH));\n    const minRow = Math.max(0, Math.floor((cameraY - renderHeight) / CELL_HEIGHT));\n    const maxRow = Math.min(this.rowCount - 1, Math.ceil((cameraY + renderHeight) / CELL_HEIGHT));\n\n    // First pass: draw ground\n    for (let row = minRow; row <= maxRow; row++) {\n      for (let col = minCol; col <= maxCol; col++) {\n        const cell = this.grid[row][col];\n        const x = cell.x * CELL_WIDTH;\n        const y = cell.y * CELL_HEIGHT;\n        drawEngine.drawBackgroundImage(GameAssets.ground, x, y);\n      }\n    }\n\n    // Second pass: draw content, collect postDraw\n    const postDrawDrawables: Drawable[] = [];\n    let drawHighlight = false;\n    for (let row = minRow; row <= maxRow; row++) {\n      for (let col = minCol; col <= maxCol; col++) {\n        const cell = this.grid[row][col];\n        const x = cell.x * CELL_WIDTH;\n        const y = cell.y * CELL_HEIGHT;\n        const dx = x - cameraX;\n        const dy = y - cameraY;\n\n        // Seen radius for minimap\n        const distanceSquared = dx * dx + dy * dy;\n        if (distanceSquared <= seenRadiusSquared) {\n          cell.seen = true;\n        }\n\n        if (\n          cell.y === this.playerLookingAt.row &&\n          cell.x === this.playerLookingAt.col &&\n          cell.content &&\n          cell.content.type !== 'oak' && cell.content.type !== 'spruce'\n        ) {\n          drawHighlight = true;\n        }\n\n        cell?.content?.draw();\n        if (cell?.content?.postDraw) {\n          postDrawDrawables.push(cell?.content);\n        }\n      }\n    }\n\n    // Third pass: postDraw\n    // @ts-expect-error -- postDraw is definitely defined\n    postDrawDrawables.forEach(drawable => drawable.postDraw());\n\n    if (drawHighlight) {\n      drawEngine.drawBackgroundImage(\n        GameAssets.cornerImage,\n        this.playerLookingAt.col * CELL_WIDTH - (16 - CELL_WIDTH) / 2,\n        this.playerLookingAt.row * CELL_HEIGHT - (16 - CELL_HEIGHT) / 2\n      );\n    }\n  }\n}\n","\nexport const easeInOutSine = (x: number, min: number, max: number): number => {\n  const ease = -(Math.cos(Math.PI * x) - 1) / 2;\n  return min + ease * max;\n};\n\n/**\n * Converts a value from 0 to 1 to an exponential ease.\n * @param x value from 0 to 1\n * @returns value from 0 to 1\n */\nexport const easeInExpo = (x: number, ease = 5): number => {\n  return x === 1 ? 1 : 1 - Math.pow(2, -ease * x);\n};\n","import { colors } from '@/core/util/color';\nimport { GameMap } from './game-map';\nimport { Player } from './entities/player';\nimport { drawEngine } from '@/core/draw-engine';\n\n/* eslint-disable quote-props */\nconst pixelColors: Record<string, string> = {\n  'oak': colors.green3,\n  'spruce': colors.blue2,\n  'house': colors.blue4,\n  'field': colors.yellow1,\n  'statue': colors.blue6,\n  'unseen': colors.blue5,\n  'default': colors.yellow2,\n};\n/* eslint-enable quote-props */\n\n\nexport class MiniMap {\n  private lastUpdate = 0;\n  private updateInterval = 100; // Update once per second\n\n  constructor(private map: GameMap) { }\n\n  update(timeElapsed: number) {\n    this.lastUpdate += timeElapsed;\n  }\n\n  public draw(player: Player) {\n    if (this.lastUpdate < this.updateInterval) {\n      return;\n    }\n\n    this.lastUpdate = 0;\n    const ctx = drawEngine.ctx4;\n    const mapSize = 160;\n    const margin = 10;\n    const x = ctx.canvas.width - mapSize - margin; // Bottom right with margin\n    const y = ctx.canvas.height - mapSize - margin;\n\n    // Clear previous minimap\n    ctx.clearRect(x, y, mapSize, mapSize);\n\n    // Draw map pixels\n    for (let my = 0; my < mapSize; my++) {\n      for (let mx = 0; mx < mapSize; mx++) {\n        const cell = this.map.grid[my][mx];\n\n        if (!cell.seen) {\n          ctx.fillStyle = pixelColors.unseen;\n        } else {\n          ctx.fillStyle = pixelColors[cell.content?.type || 'default'] ?? pixelColors.default;\n        }\n\n        ctx.fillRect(x + mx, y + my, 1, 1);\n      }\n    }\n\n    if (player.col >= 0 && player.col < mapSize && player.row >= 0 && player.row < mapSize) {\n      ctx.fillStyle = colors.purple4;\n      ctx.beginPath();\n      ctx.arc(x + player.col, y + player.row, 2, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { on } from '@/core/event';\nimport { StoryEngineEvent } from '@/core/story-engine';\nimport { colors } from '@/core/util/color';\n\nexport class DialogBox {\n  dialog: string | null = null;\n\n  constructor() {\n    on(StoryEngineEvent.STORY_DIALOG, (dialog) => {\n      this.dialog = dialog;\n    });\n\n    on(StoryEngineEvent.STORY_STATE_EXIT, () => {\n      this.dialog = null;\n    });\n  }\n\n  draw () {\n    if (this.dialog) {\n      const boxHeight = 160; // same as minimap\n      const margin = 20; // same as minimap\n      const boxWidth = c3.width - boxHeight - margin*3;\n      const x = margin;\n      const y = c3.height - boxHeight - margin;\n      drawEngine.ctx3.fillStyle = colors.purple4;\n      drawEngine.ctx3.fillRect(x+5, y+5, boxWidth, boxHeight);\n      drawEngine.ctx3.fillStyle = colors.purple0;\n      drawEngine.ctx3.fillRect(x, y, boxWidth-5, boxHeight-5);\n\n      this.dialog.split('\\n').forEach((dialog, i) => {\n        drawEngine.drawText(\n          dialog,\n          x + margin * 2,\n          y + margin * 2 + i * 40,\n          dialog[0] === '>' ? colors.purple4 : colors.black,\n          0, // left\n          0, // top\n          5,\n          1,\n          drawEngine.ctx3\n        );\n      });\n\n      drawEngine.drawText(\n          'press (space) to continue',\n          x + boxWidth - margin,\n          y + boxHeight - margin,\n          colors.purple4,\n          2, // right\n          2, // bottom\n          3,\n          1,\n          drawEngine.ctx3\n        );\n    }\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { colors } from '@/core/util/color';\nimport { easeInOutSine } from '@/core/util/util';\nimport { MiniMap } from './mini-map';\nimport { GameMap } from './game-map';\nimport { Player } from './entities/player';\nimport { Actions } from './actions';\nimport { GameData } from './game-data';\nimport { MAX_LIVES, MAX_MAGIC, NOTIFICATION_DURATION } from './constants';\nimport { DialogBox } from './dialog-box';\nimport { MAGIC, EMPTY_HEART, FULL_HEART, ONE_THIRD_HEART, TWO_THIRDS_HEART } from '@/core/font';\nimport { on } from '@/core/event';\nimport { GameEvent } from './event-manifest';\nimport { Village } from './entities/village';\n\nexport class HUD {\n  miniMap: MiniMap;\n  dialogBox: DialogBox;\n  renderSuperstition = false;\n  renderLives = false;\n  renderMagic = false;\n  villageName = '';\n  villageNameTimer = 0;\n\n  constructor(\n    public map: GameMap,\n    public player: Player,\n    public actions: Actions,\n    public gameData: GameData,\n  ) {\n    this.miniMap = new MiniMap(map);\n    this.dialogBox = new DialogBox();\n\n    on(GameEvent.ENABLE_SCRATCH, () => {\n      this.renderLives = true;\n    });\n\n    on(GameEvent.NOT_ENOUGH_MAGIC, () => {\n      this.renderMagic = true;\n    });\n\n    on(GameEvent.ENTER_VILLAGE, (village: Village) => {\n      this.villageName = village.name;\n      this.villageNameTimer = 3000;\n    });\n\n    on(GameEvent.SCARED, () => {\n      this.renderSuperstition = true;\n    });\n  }\n\n  update(timeElapsed: number) {\n    this.miniMap.update(timeElapsed);\n    this.villageNameTimer -= timeElapsed;\n  }\n\n  draw() {\n    this.renderLives && this.drawLives();\n    this.renderMagic && this.drawMagic();\n    this.drawGoals();\n    this.renderSuperstition && this.drawSuperstition();\n    this.drawActions();\n    this.drawInfoBox();\n    this.renderLives && this.miniMap.draw(this.player);\n    this.dialogBox.draw();\n  }\n\n  drawActions() {\n    const actions = this.actions.actions;\n    if (!actions || !actions[0].enabled) {\n      return;\n    }\n\n    const boxWidth = 120;\n    const boxHeight = 120;\n    const spacing = 10;\n    const totalWidth = actions.length * boxWidth + (actions.length - 1) * spacing;\n    const startX = Math.round((drawEngine.ctx3.canvas.width - totalWidth) / 2);\n    const y = drawEngine.ctx3.canvas.height - boxHeight - 10;\n\n    actions.forEach(({ type, color, symbol }, index) => {\n      const x = startX + index * (boxWidth + spacing);\n\n      // Draw background box\n      drawEngine.ctx3.fillStyle = colors.purple0;\n      drawEngine.ctx3.fillRect(x, y, boxWidth, boxHeight);\n\n      // Draw symbol (large font)\n      drawEngine.drawText(\n        symbol,\n        x + boxWidth / 2,\n        y + 30,\n        color,\n        1, // center\n        1, // middle\n        7,\n        1,\n        drawEngine.ctx3\n      );\n\n      // Draw action name\n      drawEngine.drawText(\n        type,\n        x + boxWidth / 2,\n        y + 95,\n        colors.black,\n        1, // center\n        1, // middle\n        3,\n        1,\n        drawEngine.ctx3\n      );\n    });\n  }\n\n  drawLives() {\n    const x = 16;\n    const y = 16;\n    const fullHearts = Math.floor(this.gameData.lives);\n    const emptyHearts = Math.floor(MAX_LIVES - this.gameData.lives);\n    const halfHearts = MAX_LIVES - fullHearts - emptyHearts;\n    const partialHearts = this.gameData.lives - fullHearts;\n    const text = FULL_HEART.repeat(fullHearts)\n      + (partialHearts > 0.3 ? TWO_THIRDS_HEART : ONE_THIRD_HEART).repeat(halfHearts)\n      + EMPTY_HEART.repeat(emptyHearts);\n    const size = 5;\n\n    const boxW = (text.length * 6 + 1) * size;\n    const boxH = 7 * size;\n    drawEngine.ctx3.fillStyle = colors.purple0;\n    drawEngine.ctx3.fillRect(x, y, boxW, boxH);\n    drawEngine.drawText(text, x + size, y + size, colors.purple4, 0, 0, size, 1, drawEngine.ctx3);\n  }\n\n  drawMagic() {\n    let x = c3.width - 16;\n    const y = 16;\n    const fullMagic = this.gameData.magic;\n    const emptyMagic = this.gameData.maxMagic - this.gameData.magic;\n    const noMagic = MAX_MAGIC - this.gameData.maxMagic;\n\n    const size = 5;\n    const charWidth = (5 + 1) * size;\n\n    const boxW = MAX_MAGIC * charWidth + size;\n    const boxH = 7 * size;\n    drawEngine.ctx3.fillStyle = colors.yellow1;\n    drawEngine.ctx3.fillRect(x - boxW + size, y, boxW, boxH);\n\n    let text = MAGIC.repeat(fullMagic);\n    x -= text.length * charWidth;\n    drawEngine.drawText(text, x + size, y + size, colors.blue2, 0, 0, size, 1, drawEngine.ctx3);\n\n    text = MAGIC.repeat(emptyMagic);\n    x -= text.length * charWidth;\n    drawEngine.drawText(text, x + size, y + size, colors.blue3, 0, 0, size, 1, drawEngine.ctx3);\n\n    text = MAGIC.repeat(noMagic);\n    x -= text.length * charWidth;\n    drawEngine.drawText(text, x + size, y + size, colors.yellow2, 0, 0, size, 1, drawEngine.ctx3);\n  }\n\n  drawGoals() {\n    const goals = this.gameData.goals;\n\n    const baseX = 16;\n    const y = 16 + 7 * 5 + 10; // lives y  + lives box height + margin\n    const boxW = 510;\n    const boxH = 5 * 7 + 30;\n    const size = 3;\n    const padding = 5;\n    const aD = 200; // 100ms slide animation\n    \n    goals.filter(goal => goal.time > 0)\n    .forEach((goal, i) => {\n      const {label, time} = goal;\n      const boxY = y + (boxH + padding) * i;\n      \n      // Calculate animation offset based on remaining time\n      let offsetX = 0;\n      const distanceX = boxW + baseX;\n      if (time > NOTIFICATION_DURATION - aD) {\n        // Sliding in from left (appearing)\n        const progress = (NOTIFICATION_DURATION - time) / aD;\n        const easedProgress = easeInOutSine(progress, 0, 1);\n        offsetX = -distanceX * (1 - easedProgress);\n      } else if (time < aD) {\n        // Sliding out to left (disappearing)\n        const progress = time / aD;\n        const easedProgress = easeInOutSine(progress, 0, 1);\n        offsetX = -distanceX * (1 - easedProgress);\n      }\n      \n      const x = baseX + offsetX;\n      \n      drawEngine.ctx3.fillStyle = colors.purple4;\n      drawEngine.ctx3.fillRect(x, boxY, boxW, boxH);\n      drawEngine.drawText(\n        'GOAL',\n        x + size + padding,\n        boxY + padding,\n        colors.white,\n        0, // left\n        0, // top\n        size + 1,\n        1,\n        drawEngine.ctx3\n      );\n      drawEngine.drawText(\n        label,\n        x + size + padding + 20,\n        35 + boxY + padding,\n        colors.purple0,\n        0, // left\n        0, // top\n        size,\n        1,\n        drawEngine.ctx3\n      );\n    });\n  }\n\n  drawSuperstition() {\n    const text = 'superstition';\n    const size = 3;\n    const charWidth = 5;\n    const padding = 5;\n    const boxW = (text.length * size + padding * 2) * charWidth;\n    const boxH = 35;\n    const x = Math.round(c3.width / 2 - boxW / 2);\n    const y = 16;\n\n    // Background\n    drawEngine.ctx3.fillStyle = colors.purple0;\n    drawEngine.ctx3.fillRect(x, y, boxW, 62);\n\n    drawEngine.ctx3.fillStyle = colors.blue5;\n    drawEngine.ctx3.fillRect(x + padding, y + padding, boxW - 2 * padding, boxH - 2 * padding);\n\n    drawEngine.ctx3.fillStyle = this.gameData.superstition > 0.9 ? colors.purple4 : colors.blue2;\n    const barSize = Math.round(this.gameData.superstition * (boxW - 2 * padding) / 3) * 3;\n    drawEngine.ctx3.fillRect(x + padding, y + padding, barSize, boxH - 2 * padding);\n\n    drawEngine.drawText(text, c3.width / 2, y + boxH + size, colors.blue5, 1, 0, size, 1, drawEngine.ctx3);\n  }\n\n  drawInfoBox() {\n    if(this.villageNameTimer > 0) {\n      const t = this.villageNameTimer;\n      const tNorm = Math.max(0, Math.min(1, Math.min(t / 150, (3000 - t) / 150)));\n      const opacity = easeInOutSine(tNorm, 0, 1);\n      drawEngine.ctx3.globalAlpha = opacity;\n      this.drawInfo(`^^ ${this.villageName}`, 170);\n      drawEngine.ctx3.globalAlpha = 1;\n    }\n\n    if (this.map.playerLookingAt) {\n      const cell = this.map.getLookingAt();\n      if (cell?.content?.name) {\n        this.drawInfo(cell.content.name, c3.height - 170);\n      }\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  drawInfo(text: string, yPos: number) {\n    const boxWidth = 350;\n    const boxHeight = 35;\n\n    const x = c3.width / 2 - boxWidth / 2;\n    const y = yPos - 6 * 3;\n    \n    drawEngine.ctx3.fillStyle = colors.purple4;\n    drawEngine.ctx3.fillRect(\n      x,\n      y+3,\n      boxWidth,\n      boxHeight,\n    );\n    drawEngine.ctx3.fillRect(\n      x - 15,\n      y + 15,\n      boxHeight,\n      boxHeight,\n    );\n    drawEngine.ctx3.fillRect(\n      x + boxWidth - 15,\n      y + 15,\n      boxHeight,\n      boxHeight,\n    );\n    drawEngine.ctx3.fillStyle = colors.yellow2;\n    drawEngine.ctx3.fillRect(\n      x,\n      y,\n      boxWidth,\n      boxHeight,\n    );\n\n    drawEngine.drawText(\n      text,\n      c3.width / 2,\n      yPos,\n      colors.purple4,\n      1, // center\n      1, // middle\n      3,\n      1,\n      drawEngine.ctx3\n    );\n  }\n}\n","import { GameMap } from './game-map';\nimport { Player } from './entities/player';\nimport { MAX_REPAIR, statues } from './constants';\nimport { colors } from '@/core/util/color';\nimport { emit, on } from '@/core/event';\nimport { MAGIC, SCRATCH, TELEPORT } from '@/core/font';\nimport { controls } from '@/core/controls';\nimport { Statue } from './entities/statue';\nimport { Obelisk } from './entities/obelisk';\nimport { addTimeEvent } from '@/core/timer';\nimport { GameEvent } from './event-manifest';\nimport { repair } from '@/core/audio';\nimport { Cell } from './types';\nimport { Spirit } from './entities/spirit';\nimport { Farm } from './entities/farm';\nimport { House } from './entities/house';\n\ntype ActionType = 'teleport' | 'scratch' | 'repair' | 'sleep';\ntype Action = {\n  type: ActionType,\n  color: string,\n  enabled: boolean,\n  symbol: string,\n}\n\nconst actions: Action[] = [\n  {\n    type: 'scratch',\n    color: colors.purple4,\n    enabled: false,\n    symbol: SCRATCH,\n  },\n  {\n    type: 'teleport',\n    color: colors.blue2,\n    enabled: true,\n    symbol: TELEPORT,\n  },\n  {\n    type: 'repair',\n    color: colors.green3,\n    enabled: true,\n    symbol: MAGIC,\n  },\n  {\n    type: 'sleep',\n    color: colors.yellow2,\n    enabled: true,\n    symbol: 'z',\n  },\n];\n\nexport class Actions {\n  map: GameMap;\n  player: Player;\n  actions: Action[] = [];\n\n  constructor(map: GameMap, player: Player) {\n    this.map = map;\n    this.player = player;\n\n    on(GameEvent.ENABLE_SCRATCH, () => {\n      this.actions[0].enabled = true;\n    });\n  }\n\n  // Update available actions based on player's current position\n  update(): void {\n    const cellInFront = this.map.getLookingAt();\n\n    const canTeleport  = this.canTeleport(cellInFront);\n    const canRestore = this.canRestore(cellInFront);\n    const canSleep = this.canSleep(cellInFront);\n    const canAttack = this.canAttack(cellInFront);\n\n    this.actions = [\n      canAttack ? actions[0]\n      : canTeleport ? actions[1]\n      : canRestore ? actions[2]\n      : canSleep ? actions[3]\n      : actions[0]\n    ];\n\n    if (controls.isAction1 && !controls.previousState.isAction1) {\n      switch (true) {\n        case canAttack:\n          // Attack happens somewhere else\n          break;\n        \n        case canTeleport:\n          emit(GameEvent.TELEPORT);\n          break;\n        \n        case canRestore:\n          this.doRestore(cellInFront);\n          break;\n\n        case canSleep:\n          emit(GameEvent.SLEEP);\n\n      \n        default:\n          break;\n      }\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  doRestore(cellInFront: Cell) {\n    emit(GameEvent.RESTORE);\n    const object = cellInFront.content as Statue | Obelisk;\n    if (object.repair < MAX_REPAIR) {\n      if (object instanceof Statue) {\n        object.repair++;\n        repair(object.repair);\n        if (object.repair >= MAX_REPAIR) {\n          addTimeEvent(() => {\n            emit(GameEvent.STATUE_RESTORED, this.map.gameData.maxMagic);\n          }, 4000);\n        }\n      } else if (object instanceof Obelisk) {\n        object.attemptRepair();\n      }\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  private canRestore(cellInFront: Cell): boolean {\n    const object = cellInFront.content as Statue | Obelisk;\n    const type = object?.type;\n    return (\n      (type === 'statue' || type === 'obelisk')\n    ) && object.repair < MAX_REPAIR;\n  }\n\n  private canTeleport(cellInFront: Cell) {\n    return cellInFront.content instanceof Statue\n      && this.player.col != statues.heart.x\n      && cellInFront.content.state === Statue.State.REPAIRED;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  private canSleep(cellInFront: Cell) {\n    return cellInFront.content instanceof House\n      && cellInFront.content.name === 'home';\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  private canAttack(cellInFront: Cell) {\n    return cellInFront.content instanceof Spirit\n      || cellInFront.content instanceof Farm;\n  }\n}\n","import { emit, on } from '@/core/event';\nimport { MAX_LIVES, NOTIFICATION_DURATION } from './constants';\nimport { SceneProps } from './game-story';\nimport { GameEvent } from './event-manifest';\nimport { addTimeEvent } from '@/core/timer';\nimport { heal, hissAndSpit } from '@/core/audio';\n\ninterface Goal {\n  label: string,\n  time: number,\n}\n\nexport class GameData {\n  cutscene = false;\n  lives = MAX_LIVES;\n  maxMagic = 0;\n  magic = 0;\n  superstition = 0;\n  goals: Goal[] = [];\n  hasClearedIntro = false;\n  win = false;\n\n  constructor() {\n    on(GameEvent.SCARED, () => {\n      this.superstition = Math.min(1, this.superstition + 0.01);\n    });\n\n    on(GameEvent.CUTSCENE_START, () => {\n      this.cutscene = true;\n    });\n\n    on(GameEvent.CUTSCENE_END, (scene: SceneProps) => {\n      this.cutscene = false;\n      if (scene.goals) {\n        scene.goals.forEach(goal => {\n          this.goals.push({\n            label: goal,\n            time: NOTIFICATION_DURATION,\n          });\n        });\n      }\n    });\n\n    on(GameEvent.ATTACK_PLAYER, (level: number) => {\n      this.lives -= (level + 1) / 3;\n      this.lives = Math.round(this.lives * 3) / 3;\n      this.lives = Math.round(this.lives * 10) / 10;\n      hissAndSpit();\n      if (this.lives <= 0) {\n        this.lives = 0;\n        emit(GameEvent.GAME_OVER);\n      }\n    });\n\n    on(GameEvent.STATUE_RESTORED, () => {\n      this.maxMagic++;\n      this.magic = this.maxMagic;\n      this.heal();\n\n      emit(GameEvent.NEXT_STATUE_DIALOG, this.maxMagic);\n    });\n\n    on(GameEvent.SLEEP, () => {\n      this.heal();\n    });\n  }\n\n  heal() {\n    let i = 0;\n    for (let lives = Math.floor(this.lives) + 1; lives <= MAX_LIVES; lives++) {\n      addTimeEvent(() => {\n        this.lives = lives;\n        heal();\n      }, 500 + 800 * (i++));\n    }\n  }\n\n  update(timeElapsed: number) {\n    this.goals.forEach(goal => goal.time -= timeElapsed);\n  }\n\n  getLevel() {\n    return this.superstition * 4 + this.maxMagic;\n  }\n}\n","import { controls } from './controls';\nimport { emit, on } from '@/core/event';\n\nexport interface DialogState {\n  dialogs: string[];\n  isDone?: boolean;\n}\n\nexport interface Script {\n  [stateKey: string]: DialogState;\n}\n\nexport const enum StoryEngineEvent {\n  // Story events\n  STORY_STATE_ENTER = 1,\n  STORY_STATE_EXIT = 2,\n  STORY_DIALOG = 3,\n};\n\nexport class Story<T extends Script> {\n  private currentStateKey: keyof T | null = null;\n  private currentDialogIndex = 0;\n  public isActive = false;\n  private previousSpacePressed = false;\n  public currentState: keyof T | null = null;\n  \n  fullText = '';\n  visibleCharacters = 0;\n  textAnimationTimer = 0;\n  charactersPerSecond = 20;\n  textAnimationState = 2; // 0=typing, 1=complete, 2=waiting\n\n  constructor(private readonly script: T) {\n    on(StoryEngineEvent.STORY_STATE_ENTER, (stateKey: keyof T) => {\n      this.enterState(stateKey);\n    });\n  }\n\n  public enterState(stateKey: keyof T) {\n    if (!this.script[stateKey]) {\n      return;\n    }\n\n    this.currentStateKey = stateKey;\n    this.currentState = stateKey;\n    this.currentDialogIndex = 0;\n    this.isActive = true;\n    this.previousSpacePressed = false;\n\n    this.showCurrentDialog();\n  }\n\n  update(timeElapsed: number) {\n    if (!this.isActive || !this.currentStateKey) {\n      return;\n    }\n\n    const spacePressed = controls.keyMap.get('Space');\n    const spaceJustPressed = spacePressed && !this.previousSpacePressed;\n    this.previousSpacePressed = spacePressed || false;\n\n    // Update typewriter animation\n    if (this.textAnimationState === 0) { // typing\n      this.textAnimationTimer += timeElapsed;\n      const targetCharacters = Math.floor((this.textAnimationTimer / 1000) * this.charactersPerSecond);\n      \n      if (targetCharacters >= this.fullText.length) {\n        // Animation complete\n        this.visibleCharacters = this.fullText.length;\n        this.textAnimationState = 1; // complete\n        this.emitCurrentVisibleText();\n      } else if (targetCharacters > this.visibleCharacters) {\n        // Show more characters\n        this.visibleCharacters = targetCharacters;\n        this.emitCurrentVisibleText();\n      }\n    }\n\n    if (spaceJustPressed) {\n      this.handleSpacePress();\n    }\n  }\n\n  private handleSpacePress() {\n    if (!this.currentStateKey) {\n      return;\n    }\n\n    if (this.textAnimationState === 0) { // typing\n      // Skip typing animation - show full text immediately\n      this.visibleCharacters = this.fullText.length;\n      this.textAnimationState = 1; // complete\n      this.emitCurrentVisibleText();\n      return;\n    }\n\n    if (this.textAnimationState === 1) { // complete\n      // Move to next dialog or exit\n      const currentState = this.script[this.currentStateKey];\n      \n      if (this.currentDialogIndex < currentState.dialogs.length - 1) {\n        // Move to next dialog\n        this.currentDialogIndex++;\n        this.showCurrentDialog();\n      } else {\n        // All dialogs complete, exit state\n        this.exitCurrentState();\n      }\n    }\n  }\n\n  private emitCurrentVisibleText() {\n    const visibleText = this.fullText.substring(0, this.visibleCharacters);\n    emit(StoryEngineEvent.STORY_DIALOG, visibleText);\n  }\n\n  private showCurrentDialog() {\n    if (!this.currentStateKey) {\n      return;\n    }\n\n    const currentState = this.script[this.currentStateKey];\n    currentState.isDone = true;\n    this.fullText = currentState.dialogs[this.currentDialogIndex];\n    \n    // Reset typewriter animation\n    this.visibleCharacters = 0;\n    this.textAnimationTimer = 0;\n    this.textAnimationState = 0; // typing\n    \n    // Start with empty text\n    this.emitCurrentVisibleText();\n  }\n\n  private exitCurrentState() {\n    if (!this.currentStateKey) {\n      return;\n    }\n\n    const stateKey = this.currentStateKey;\n    this.isActive = false;\n    this.currentStateKey = null;\n    this.currentState = null;\n    this.currentDialogIndex = 0;\n    \n    emit(StoryEngineEvent.STORY_STATE_EXIT, stateKey);\n  }\n}\n","import { drawEngine } from '@/core/draw-engine';\nimport { emit, on } from '@/core/event';\nimport { DialogState, Story, StoryEngineEvent } from '@/core/story-engine';\nimport { addTimeEvent } from '@/core/timer';\nimport { GameEvent } from './event-manifest';\nimport { MAX_MAGIC } from './constants';\n\nexport interface SceneProps extends DialogState {\n  goals?: string[],\n};\n\nconst enum Scene {\n  intro = 1,\n  spirit,\n  barrier,\n  altar,\n  altar2,\n  noMagic,\n  magicRestored,\n  villagers,\n  end,\n}\n\nconst script = {} as Record<Scene, SceneProps>;\n\n// Use programmatic assignment to avoid preserving enum string names\nscript[Scene.intro] = {\n  dialogs: [\n    'Zzzzz...',\n    'Yawwwn...',\n    'How long was I sleeping?...',\n  ],\n};\n\nscript[Scene.spirit] = {\n  dialogs: [\n    'Evil spirits?',\n    'Has the magic barrier failed\\nwhile I slept??',\n    'This one seems weak.',\n    \"I'll exorcise it and then\\ngo check the barrier\",\n    '> Use (space) to attack',\n  ],\n  goals: ['find magic barrier obelisk'],\n};\n\nscript[Scene.barrier] = {\n  dialogs: [\n    'I have no magic power left!',\n    'My magic comes from villagers\\nworshiping me...',\n    'Something must be wrong with\\nthe cat altar.',\n  ],\n  goals: ['repair the cat altar'],\n};\n\nscript[Scene.noMagic] = {\n  dialogs: [\n    \"I don't have enough magic!\",\n    'Something must be wrong with\\nthe cat altars in the valley',\n  ],\n};\n\nscript[Scene.altar] = {\n  dialogs: [\n    'My magic has increased a little.',\n    'But the other altars...\\nthey must be damaged too.',\n  ],\n  goals: [\n    'repair all 5 altars',\n    'restore the forest magic barrier',\n  ],\n};\n\nscript[Scene.altar2] = {\n  dialogs: [\n    'I feel myself getting stronger.',\n    'But I must continue until\\nall altars are repaired.',\n  ],\n  goals: [\n    'repair all 5 altars',\n    'restore the forest magic barrier',\n  ],\n};\n\nscript[Scene.villagers] = {\n  dialogs: [\n    'Villagers are very superstitious.',\n    'I should not let them see me,\\nthat will empower the evil spirits.',\n  ],\n};\n\nscript[Scene.magicRestored] = {\n  dialogs: [\n    'I have restored my full magic power',\n    'Now I am able to restore the\\nmagic barrier again.',\n  ],\n  goals: [\n    'restore the forest magic barrier',\n  ]\n};\n\nscript[Scene.end] = {\n  dialogs: [\n    'The barrier is restored.',\n    'The altars are back online.',\n    'The spirits are resting in peace.',\n    'Time for a well deserved nap...',\n  ],\n};\n\nconst postIntro = () => {\n  emit(GameEvent.WAKE_UP);\n  emit(GameEvent.SPAWN_FIRST_SPIRIT);\n  drawEngine.cameraLerpSpeed = 0.08;\n};\n\nexport class GameStory {\n  story: Story<typeof script>;\n\n  constructor() {\n    this.story = new Story({...script});\n\n    on(StoryEngineEvent.STORY_STATE_EXIT, (label: Scene) => {\n      emit(GameEvent.CUTSCENE_END, script[label]);\n      if (label === Scene.intro) {\n        postIntro();\n        addTimeEvent(() => {\n          emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.spirit);\n        }, 3000);\n      }\n      if(label === Scene.spirit) {\n        emit(GameEvent.ENABLE_SCRATCH);\n      }\n      if (label === Scene.end) {\n        addTimeEvent(() => emit(GameEvent.FADE_OUT), 3000);\n      }\n    });\n\n    on(StoryEngineEvent.STORY_STATE_ENTER, () => {\n      emit(GameEvent.CUTSCENE_START);\n    });\n\n    on(GameEvent.NOT_ENOUGH_MAGIC, () => {\n      if (script[Scene.barrier].isDone) {\n        emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.noMagic);\n      } else {\n        emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.barrier);\n      }\n    });\n\n    on(GameEvent.NEXT_STATUE_DIALOG, (magicLevel: number) => {\n      if (magicLevel < MAX_MAGIC) {\n        if (!script[Scene.altar].isDone) {\n          emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.altar);\n        } else {\n          emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.altar2);\n        }\n      } else {\n        emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.magicRestored);\n      }\n    });\n\n    on(GameEvent.SCARED, () => {\n      if (!script[Scene.villagers].isDone) {\n        emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.villagers);\n      }\n    });\n\n    on(GameEvent.GAME_END, () => {\n      emit(StoryEngineEvent.STORY_STATE_ENTER, Scene.end);\n    });\n    \n\n    addTimeEvent(() => this.story.enterState(Scene.intro), 1000);\n    // setTimeout(() => {\n    //   postIntro();\n    //   emit(GameEvent.ENABLE_SCRATCH);\n    // }, 10);\n  }\n\n  update (timeElapsed: number) {\n    this.story.update(timeElapsed);\n  }\n}\n","class MusicPlayer {\n  audioContext: AudioContext | undefined;\n  startTime = 0;\n  isPlaying = false;\n  buffer: AudioBuffer | undefined;\n  musicProcessorNode: AudioWorkletNode | undefined;\n\n  async start() {\n    if (this.isPlaying) return;\n\n    this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    await this.audioContext.resume();\n    await this.audioContext.audioWorklet.addModule('music-worklet.js');\n\n    this.musicProcessorNode = new AudioWorkletNode(this.audioContext, 'mp');\n    \n    this.musicProcessorNode.connect(this.audioContext.destination);\n    this.isPlaying = true;\n  }\n\n  startMelody() {\n    this.musicProcessorNode?.port.postMessage(0);\n  }\n\n  pause() {\n    this.musicProcessorNode?.port.postMessage(1);\n  }\n\n  unpause() {\n    this.musicProcessorNode?.port.postMessage(2);\n  }\n\n  stop() {\n    if (this.isPlaying) {\n      this.musicProcessorNode?.disconnect();\n      this.isPlaying = false;\n    }\n  }\n}\n\nexport default new MusicPlayer();\n","import { State } from '@/core/state';\nimport { drawEngine } from '@/core/draw-engine';\nimport { Player } from '@/game/entities/player';\nimport { GameMap } from '@/game/game-map';\nimport { HUD } from '@/game/hud';\nimport { Actions } from '@/game/actions';\nimport { GameData } from '@/game/game-data';\nimport { GameStory } from '@/game/game-story';\nimport { addTimeEvent, updateTimeEvents } from '@/core/timer';\nimport musicPlayer from '@/core/music-player';\nimport { clearEvents, emit, on } from '@/core/event';\nimport { GameEvent } from '@/game/event-manifest';\nimport { gameStateMachine } from '@/game-state-machine';\nimport { menuState } from './menu.state';\nimport { MAX_LIVES } from '@/game/constants';\nimport { GameAssets } from '@/game/game-assets';\nimport { highRepair } from '@/core/audio';\nimport { MagicCircleAnimation } from '@/game/entities/magic-animation';\nimport { colors } from '@/core/util/color';\nimport { controls } from '@/core/controls';\n\nexport class GameState implements State {\n  map!: GameMap;\n  cat!: Player;\n  hud!: HUD;\n  actions!: Actions;\n  gameData!: GameData;\n  story!: GameStory;\n  playMusic = true;\n  zoomOffset = 0;\n  cameraFollowsCat = true;\n  cameraPos: {x: number, y:number} = {x:0, y:0};\n  fadeTimer = 0;\n  isFading = false;\n  showGameOver = false;\n\n  onLeave() {\n    musicPlayer.stop();\n    drawEngine.ctx4.clearRect(0, 0, c4.width, c4.height);\n    clearEvents();\n  }\n\n  onEnter() {\n    if (this.playMusic) {\n      musicPlayer.start();\n    }\n    \n    on(GameEvent.ENABLE_SCRATCH, () => {\n      musicPlayer.startMelody();\n    });\n    on(GameEvent.PAUSE, () => {\n      musicPlayer.pause();\n    });\n    on(GameEvent.UNPAUSE, () => {\n      musicPlayer.unpause();\n    });\n\n    on(GameEvent.GAME_OVER, () => {\n      musicPlayer.stop();\n      drawEngine.ctx4.clearRect(0, 0, drawEngine.canvasWidth, drawEngine.canvasHeight);\n      addTimeEvent(() => this.showGameOver = true, 1000);\n    });\n\n    on(GameEvent.FADE_OUT, () => {\n      this.cameraFollowsCat = false;\n      this.cameraPos = { x: this.cameraPos.x, y: this.cameraPos.y - 200 };\n      drawEngine.moveCameraLinearly = true;\n      this.cat.sleeping = true;\n      this.fadeTimer = 0;\n      this.isFading = true;\n      addTimeEvent(() => gameStateMachine.setState(menuState), 10000);\n    });\n\n    on(GameEvent.END_SEQUECE_START, () => {\n      // Final statue camera pan\n      const interval = 2000;\n      const delay = 2000;\n      musicPlayer.pause();\n\n      // Turn each statue golden and exorcise all spirits\n      this.map.statues.forEach((statue, i) => {\n        addTimeEvent(() => {\n          this.cameraFollowsCat = false;\n          this.cameraPos = { x: statue.x, y: statue.y};\n          drawEngine.setCamera(this.cameraPos.x, this.cameraPos.y, 5, true);\n          addTimeEvent(() => {\n            statue.img = GameAssets.statueGold;\n            statue.maxSpirits = -99;\n            statue.spirits.forEach(spirit => spirit.takeDamage(spirit.hp));\n            highRepair(i);\n          }, interval * 0.5);\n        }, delay + interval * i);\n      });\n\n      // Turn the obelisk golden\n      addTimeEvent(() => {\n        this.cameraFollowsCat = false;\n        const obelisk = this.map.obelisk;\n        this.cameraPos = { x: obelisk.x, y: obelisk.y};\n        drawEngine.setCamera(this.cameraPos.x, this.cameraPos.y, 5, true);\n\n        let time = interval * 1.5;\n        addTimeEvent(() => {\n          obelisk.img = GameAssets.obeliskGold;\n          let repeat = 0;\n          addTimeEvent(() => {\n            highRepair(this.map.statues.length + (repeat++));\n          }, 250, 4);\n        }, time);\n        time += 250 * 4;\n        addTimeEvent(() => {\n          obelisk.startAnimation();\n        }, time);\n        time += MagicCircleAnimation.animationDuration * 2;\n        addTimeEvent(() => {\n          musicPlayer.unpause();\n        }, time);\n        addTimeEvent(() => {\n          emit(GameEvent.GAME_END);\n        }, time);\n      }, delay + interval * this.map.statues.length);\n    });\n\n    // DEBUG: force statue final camera pan\n    // addTimeEvent(() => {\n    //   emit(GameEvent.END_SEQUECE_START);\n    // }, 5000);\n\n    this.gameData = new GameData();\n    this.map = new GameMap(160, 160, this.gameData);\n    this.cat = new Player(60, 85, this.map, this.gameData);\n    // this.cat = new Player(94, 133, this.map, this.gameData);\n    this.actions = new Actions(this.map, this.cat);\n    this.hud = new HUD(this.map, this.cat, this.actions, this.gameData);\n    this.story = new GameStory();\n    \n    this.map.set(this.cat.col, this.cat.row, this.cat);\n    drawEngine.setCamera(this.cat.x, this.cat.y, 20, true);\n    drawEngine.cameraLerpSpeed = 0.01;\n  }\n\n  onUpdate(timeElapsed: number) {\n    const zoom = 5 + this.zoomOffset + (MAX_LIVES - this.gameData.lives) / MAX_LIVES;\n    \n    if (this.cameraFollowsCat) {\n      drawEngine.setCamera(this.cat.x, this.cat.y, zoom);\n      this.cameraPos = { x: this.cat.x, y: this.cat.y };\n    } else {\n      drawEngine.cameraLerpSpeed = 0.01;\n      drawEngine.setCamera(this.cameraPos.x, this.cameraPos.y, 7);\n    }\n    drawEngine.updateCamera();\n\n    if (this.gameData.lives > 0) {\n      if (!this.gameData.cutscene) {\n        this.actions.update();\n      }\n      this.map.update(timeElapsed, this.gameData.cutscene);\n      this.hud.update(timeElapsed);\n      this.gameData.update(timeElapsed);\n    }\n    this.story.update(timeElapsed);\n    updateTimeEvents(timeElapsed);\n\n    if (this.gameData.lives > 0 && !this.gameData.win) {\n      this.map.draw(drawEngine.cameraX, drawEngine.cameraY);\n      this.hud.draw();\n    } else {\n      if (this.gameData.lives > 0) {\n        this.hud.draw();\n      }\n      this.cat.updateAnimation(timeElapsed);\n      this.cat.draw();\n      if (this.showGameOver) {\n        drawEngine.drawText(\n          'You ran out of lives',\n          drawEngine.canvasWidth / 2,\n          drawEngine.canvasHeight * 3 / 4,\n          colors.black,\n          1,\n          0,\n          5,\n          1,\n          drawEngine.ctx3,\n        );\n        drawEngine.drawText(\n          '> Press space',\n          drawEngine.canvasWidth / 2,\n          drawEngine.canvasHeight * 3 / 4 + 40,\n          colors.green5,\n          1,\n          0,\n          5,\n          1,\n          drawEngine.ctx3,\n        );\n        if (controls.isAction1 && controls.previousState.isAction1) {\n          this.showGameOver = false;\n          addTimeEvent(() => gameStateMachine.setState(menuState), 1000);\n        }\n      }\n    }\n\n    if (this.isFading) {\n      this.fadeTimer += timeElapsed;\n      const alpha = Math.min(255, Math.floor(((this.fadeTimer / 4000)) * 255));\n      const alphaHex = alpha.toString(16).padStart(2, '0');\n      drawEngine.ctx3.fillStyle = colors.green3 + alphaHex;\n      drawEngine.ctx3.fillRect(0, 0, drawEngine.canvasWidth, drawEngine.canvasHeight);\n    }\n\n    drawEngine.resetCamera();\n  }\n}\n","import { State } from '@/core/state';\nimport { drawEngine } from '@/core/draw-engine';\nimport { controls } from '@/core/controls';\nimport { gameStateMachine } from '@/game-state-machine';\nimport { GameState } from './game.state';\nimport { colors } from '@/core/util/color';\nimport { GameAssets } from '@/game/game-assets';\nimport { SeededRandom } from '@/core/util/rng';\n\nconst toggleFullscreen = () => {\n  if (!document.fullscreenElement) {\n    document.documentElement.requestFullscreen();\n  } else {\n    document.exitFullscreen();\n  }\n};\n\nconst rng = new SeededRandom(0);\n\nconst drawBackground = () => {\n  const bgColors = [\n    colors.blue4,\n    colors.blue3,\n    colors.blue2,\n    colors.blue1,\n    colors.blue0,\n  ];\n  const sectionHeight = Math.ceil(c2.height / bgColors.length);\n  const sections = 32;\n  const sectionW = c2.width / sections;\n  const offsetFreq = 4;\n  const offsetAmplitude = 16;\n  for (let index = 0; index < sections; index++) {\n    const yOffset = Math.round(\n      offsetAmplitude * Math.sin(1 - offsetFreq * 2 * Math.PI * index / sections)\n      / 10\n    ) * 10;\n    bgColors.forEach((color, row) => {\n      drawEngine.ctx1.fillStyle = color;\n      drawEngine.ctx1.fillRect(\n        sectionW * index,\n        yOffset + sectionHeight * row - 20,\n        Math.ceil(c2.width / sections),\n        sectionHeight\n      );\n    });\n  }\n\n  const iconSize = 32;\n  const iconInterval = 22;\n  const cols = c2.width / iconInterval;\n  const rows = (c2.height / 2) / iconInterval; // fill half the screen\n  const oak: HTMLImageElement = GameAssets.oak;\n  const spruce: HTMLImageElement = GameAssets.spruce;\n\n  if (!oak) {\n    return;\n  }\n\n  for (let col = 0; col <= cols + iconSize; col++) {\n    const mountainHeight = rows * (1.2 - Math.cos((col / cols) * 2 * Math.PI));\n    for(let row = mountainHeight; row > 0; row--) {\n      const offsetX = 5 * Math.sin(12 * Math.PI * (row / rows));\n      drawEngine.drawBackgroundImage(\n        0.2 + rng.next() > (row / (rows)) ? oak : spruce,\n        col * iconInterval + offsetX - iconSize/2,\n        c2.height - (row * iconInterval + rng.next() * 0.7) / 2,\n        false,\n        iconSize,\n        iconSize,\n      );\n    }\n  }\n\n  rng.rngSeed = 0;\n};\n\nclass MenuState implements State {\n  animationTimer = 0;\n  previousFPressed = false;\n\n  onUpdate(timeElapsed: number) {\n    this.animationTimer += timeElapsed;\n\n    drawBackground();\n    const xCenter = drawEngine.ctx2.canvas.width / 2;\n    drawEngine.drawText(\n      'Meow Mountain',\n      xCenter,\n      100,\n      colors.blue0,\n      1, // center\n      0, // top\n      15\n    );\n    drawEngine.drawText(\n      'Press Enter to start',\n      xCenter,\n      230,\n      colors.white,\n      1, // center\n      0, // top\n      4\n    );\n    drawEngine.drawText(\n      'Press F to toggle fullscreen',\n      xCenter,\n      280,\n      colors.blue4,\n      1, // center\n      0, // top\n      4\n    );\n    this.updateControls();\n  }\n\n  updateControls() {\n    if (controls.isConfirm && !controls.previousState.isConfirm) {\n      gameStateMachine.setState(new GameState());\n    }\n\n    const fPressed = Boolean(controls.keyMap.get('KeyF'));\n    if (fPressed && !this.previousFPressed) {\n      toggleFullscreen();\n    }\n    this.previousFPressed = fPressed;\n  }\n};\n\nexport const menuState = new MenuState();\n","import { createGameStateMachine, gameStateMachine } from './game-state-machine';\nimport { controls } from '@/core/controls';\nimport { drawEngine } from './core/draw-engine';\nimport { updateTimeEvents } from './core/timer';\nimport { menuState } from './game-states/menu.state';\nimport { emit } from './core/event';\nimport { GameEvent } from './game/event-manifest';\n\n// @ts-ignore -- is not undefined for sure\ndocument.querySelector('link[type=\"image/x-icon\"]').href = 'data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 100 100\\'%3E%3Ctext y=\\'.9em\\' font-size=\\'85\\'%3E💜%3C/text%3E%3C/svg%3E';\n\nlet previousTime = 0;\n// let fpsBacklog: number[] = [];\nlet paused = false;\n\nwindow.addEventListener('blur', () => {\n  emit(GameEvent.PAUSE);\n  paused = true;\n});\nwindow.addEventListener('focus', () => {\n  emit(GameEvent.UNPAUSE);\n  paused = false;\n});\n\nfunction update(currentTime: number) {\n  if (paused) return;\n\n  currentTime = performance.now();\n  let delta = currentTime - previousTime;\n  previousTime = currentTime;\n  if (delta > 1000) {\n    return;\n  }\n    \n  // fpsBacklog.push(1000 / delta);\n  // if (fpsBacklog.length === 15) {\n  //   fps.innerHTML = `${Math.round(fpsBacklog.reduce((a, b) => a + b) / 15)} FPS`;\n  //   fpsBacklog = [];\n  // }\n\n  drawEngine.clear();\n\n  const state = gameStateMachine.getState();\n  controls.queryController();\n  state.onUpdate(delta);\n  updateTimeEvents(delta);\n};\n\n\ncreateGameStateMachine(menuState);\nsetInterval(update, 16);\n","import { State } from './state';\n\nexport class StateMachine {\n  private currentState: State;\n\n  constructor(initialState: State, ...enterArgs: any) {\n    this.currentState = initialState;\n    this.currentState.onEnter?.(...enterArgs);\n  }\n\n  setState(newState: State, ...enterArgs: any) {\n    this.currentState.onLeave?.();\n    this.currentState = newState;\n    this.currentState.onEnter?.(...enterArgs);\n  }\n\n  getState() {\n    return this.currentState;\n  }\n}\n"],"names":["addTimeEvent","callback","time","repeat","delay","timeEvents","push","timeLeft","updateTimeEvents","delta","i","length","timeEvent","splice","updatePositionSmoothly","state","timeElapsed","axis","targetPos","d","step","Math","sign","speed","abs","moving","round","gameStateMachine","controls","constructor","this","isUp","isDown","isLeft","isRight","isConfirm","isEscape","isAction1","isMoving","keyMap","Map","previousState","document","addEventListener","event","toggleKey","inputDirection","DOMPoint","queryController","gamepad","navigator","getGamepads","isButtonPressed","button","buttons","pressed","leftVal","get","rightVal","upVal","downVal","x","y","hypot","isPressed","set","code","getCtx","canvas","getContext","createCanvasWithCtx","w","h","c","createElement","width","height","createCanvas","quantizeToPalette","r","g","b","a","emojiToPixelArt","emoji","fontSize","spriteSize","floor","padding","_","tmpCtx","font","textBaseline","clearRect","translate","fillText","data","getImageData","outImg","createImageData","outData","outCanvas","outCtx","putImageData","img","Image","src","toDataURL","generateImageData","icon","iconPalette","transparent","palette","colorsPerByte","bytesPerColor","bitMask","size","sqrt","setAttribute","ctx","imgData","map","z","charCodeAt","bit","paletteIndex","hex","replace","parseInt","substring","NewTileset","spriteSheet","animations","tileSize","animationName","frames","Object","entries","frameData","colors","cat","villager","statue","obelisk","oak","spruce","grass","house","ground","split","e","GameAssets","initialize","superCat","cornerImage","cornerColor","fillStyle","fillRect","createCornerImage","goldPalette","statueGold","obeliskGold","tinyFont","characterCanvases","MAGIC","getCharacterData","letter","paddedBinary","leftmostCol","charWidth","toString","String","padStart","rightmostCol","col","row","min","max","makeCircle","centerX","centerY","radiusX","radiusY","skew","normalizedY","halfWidth","offset","rect","DrawEngine","canvasWidth","canvasHeight","cameraX","cameraY","zoom","targetCameraX","targetCameraY","targetZoom","cameraLerpSpeed","moveCameraLinearly","ctx1","c1","ctx2","c2","ctx3","c3","ctx4","c4","resizeCanvas","window","ctxs","imageSmoothingEnabled","drawCircumference","color","strokeWidth","save","beginPath","clip","fill","restore","drawText","text","textAlign","space","context","spacing","characters","toUpperCase","totalWidth","charPositions","forEach","character","char","letterHeight","offsetX","offsetY","charX","cacheKey","$","N","F","scaledWidth","match","bitIndex","adjustedCol","createCharacterCanvas","getCharacterCanvas","drawImage","mirrored","imgWidth","imgWeight","scale","drawBackgroundImage","imgHeight","setCamera","immediate","cx","cy","setTransform","updateCamera","deltaX","deltaY","deltaZoom","resetCamera","clear","worldToScreen","worldX","worldY","drawEngine","CELL_WIDTH","CELL_HEIGHT","MAX_REPAIR","paths","clearings","statues","heart","name","moon","ear","eye","foot","tail","GameObject","tileset","type","animation","animationTime","animationFrame","aD","animationLoop","ceil","random","setPos","update","draw","listeners","on","listener","eventName","handler","detail","emit","dispatchEvent","CustomEvent","linePixels","x0","y0","x1","y1","pixels","e2","dx","sx","dy","sy","err","PentagramAnimation","animationDone","pentagramRotation","PI","radius","elapsed","trailLength","cycles","maxCycles","active","points","angle","cos","sin","pentagramVertices","allPixels","totalDuration","newOffset","effectiveTrailLength","idx","isActive","forEachSurroundingCell","centerCol","centerRow","includeCenter","deltaRow","deltaCol","audioCtx","playSound","f","AudioContext","m","createBuffer","getChannelData","s","createBufferSource","buffer","connect","destination","start","n","repair","pitch","exp","highRepair","phase","pow","Player","gameData","super","sleeping","sitting","attacking","scared","inVillage","pentagramAttack","stepSoundTimer","sittingTimer","playerLookingAt","updateAnimation","cellVillage","grid","village","coords","innerText","cutscene","isSurrounded","newRow","content","newCol","autoSelectTarget","attackAllEnemiesAround","attackEnemyInFront","cell","takeDamage","spiritCount","currentCell","getLookingAt","directions","facing","spiritTarget","statueTarget","spiritFacing","statueFacing","dir","contentType","GameStaticObject","Tree","treeType","neighbors","top","bottom","left","right","setNeighbors","SeededRandom","rngSeed","next","range","House","Villager","lastDirection","moveTimer","moveInterval","isScared","seesCat","takeNextStep","isValidMove","checkCol","checkRow","Farm","Village","center","houseCount","population","houses","farms","villagers","generatePosition","rng","existing","distance","some","item","generateHouses","pos","generateFarms","farmCount","generateVillagers","Icon","toKey","reconstructPath","parents","goal","path","current","unshift","defaultColors","drawHpBar","hp","maxHp","colorHP","hpWidth","barX","barY","spirits","reduce","acc","index","level","Spirit","opacity","searchRadius","dead","recoil","attackTimer","attackDuration","attackTarget","attackOffsetX","attackOffsetY","species","playerCoords","lookAroundForPlayer","moveTowardsPlayer","updateAttack","progress","dirX","dirY","windProgress","attackProgress","restProgress","searchCol","searchRow","maxSteps","steps","queue","visited","Set","shift","neighbour","has","add","findShortestPath","nextStep","globalAlpha","filter","damage","exorcise","MagicCircleAnimation","animationTimer","isDone","animationDuration","animationProgress","maxWidth","maxHeight","Statue","maxSpirits","spawnTimer","spawnInterval","spawnChance","spawnRadius","State","BROKEN","spiritsExorcised","lastClearTime","magicCircleAnimation","REPAIRED","ANIMATING","getLevel","spawnSpirit","replaceSpirit","spirit","drawFaries","postDraw","clearCircleWithJitter","t","theta","offsetDist","emptyCells","selectedPosition","spiritTypes","values","randomType","Obelisk","startAnimation","attemptRepair","magic","GameMap","colCount","rowCount","villages","Array","from","_a","_b","tree","clearPathWithJitter","clearing","farm","fillCenterWithGrass","statueProps","farmCol","farmRow","clearPlants","converage","heartsPeak","villagePath","to","pathWidth","jitterAmount","jitterX","jitterY","ox","oy","clearX","clearY","fieldsOnly","border","probability","adjustedRadius","clearProbability","isCutscene","renderWidth","renderHeight","minCol","maxCol","minRow","maxRow","postDrawDrawables","drawHighlight","seenRadius","seen","drawable","easeInOutSine","pixelColors","field","unseen","default","MiniMap","lastUpdate","updateInterval","player","mapSize","my","mx","arc","DialogBox","dialog","boxHeight","margin","boxWidth","HUD","actions","renderSuperstition","renderLives","renderMagic","villageName","villageNameTimer","miniMap","dialogBox","drawLives","drawMagic","drawGoals","drawSuperstition","drawActions","drawInfoBox","enabled","startX","symbol","fullHearts","lives","emptyHearts","halfHearts","partialHearts","boxW","fullMagic","emptyMagic","maxMagic","noMagic","MAX_MAGIC","goals","label","boxY","NOTIFICATION_DURATION","boxH","superstition","drawInfo","yPos","Actions","cellInFront","canTeleport","canRestore","canSleep","canAttack","doRestore","object","GameData","hasClearedIntro","win","scene","q","heal","Story","script","currentStateKey","currentDialogIndex","previousSpacePressed","currentState","fullText","visibleCharacters","textAnimationTimer","charactersPerSecond","textAnimationState","stateKey","enterState","showCurrentDialog","spacePressed","spaceJustPressed","targetCharacters","emitCurrentVisibleText","handleSpacePress","dialogs","exitCurrentState","visibleText","GameStory","story","magicLevel","musicPlayer","startTime","isPlaying","audioContext","webkitAudioContext","resume","audioWorklet","addModule","musicProcessorNode","AudioWorkletNode","startMelody","port","postMessage","pause","unpause","stop","disconnect","GameState","playMusic","zoomOffset","cameraFollowsCat","cameraPos","fadeTimer","isFading","showGameOver","onLeave","Ct","Vt","removeEventListener","clearEvents","onEnter","setState","menuState","interval","hud","onUpdate","alphaHex","previousFPressed","bgColors","sectionHeight","sectionW","yOffset","offsetFreq","cols","rows","iconSize","drawBackground","xCenter","updateControls","fPressed","fullscreenElement","exitFullscreen","documentElement","requestFullscreen","querySelector","href","previousTime","paused","initialState","enterArgs","newState","getState","createGameStateMachine","setInterval","currentTime","performance","now"],"mappings":"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"}